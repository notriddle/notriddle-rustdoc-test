window.SIDEBAR_ITEMS = {"enum":[["CaptureKind","How a local is captured by a closure"]],"fn":[["any_parent_has_attr",""],["any_parent_is_automatically_derived",""],["binop_traits","Converts `BinOpKind::Add` to `(LangItem::Add, LangItem::AddAssign)`, for example"],["both","Checks if the two `Option`s are both `None` or some equal values as per `eq_fn`."],["can_move_expr_to_closure","Checks if the expression can be moved into a closure as is. This will return a list of captures if so, otherwise, `None`."],["can_move_expr_to_closure_no_visit","Checks if the top level expression can be moved into a closure as is. Currently checks for:"],["can_mut_borrow_both","Checks if two expressions can be mutably borrowed simultaneously and they aren’t dependent on borrowing same thing twice"],["capture_local_usage","Given an expression referencing a local, determines how it would be captured in a closure. Note as this will walk up to parent expressions until the capture can be determined it should only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or function argument (other than a receiver)."],["clip","clip unused bytes"],["contains_name","Checks if an `Expr` contains a certain name."],["contains_return","Returns `true` if `expr` contains a return expression"],["count_eq","Counts how many elements of the slices are equal as per `eq_fn`."],["def_path_res","Resolves a def path like `std::vec::Vec`. This function is expensive and should be used sparingly."],["eq_expr_value","Checks if two expressions evaluate to the same value, and don’t contain any side effects."],["expr_custom_deref_adjustment","Gets the mutability of the custom deref adjustment, if any."],["expr_or_init","If the given expression is a local binding, find the initializer expression. If that initializer expression is another local binding, find its initializer again. This process repeats as long as possible (but usually no more than once). Initializer expressions with adjustments are ignored. If this is not desired, use [`find_binding_init`] instead."],["find_binding_init","Finds the initializer expression for a local binding. Returns `None` if the binding is mutable. By only considering immutable bindings, we guarantee that the returned expression represents the value of the binding wherever it is referenced."],["fn_def_id","Returns the `DefId` of the callee if the given expression is a function or method call."],["fn_has_unsatisfiable_preds","Check if it’s even possible to satisfy the `where` clause for the item."],["get_async_fn_body","Peels away all the compiler generated code surrounding the body of an async function,"],["get_enclosing_block",""],["get_enclosing_loop_or_multi_call_closure","Gets the loop or closure enclosing the given expression, if any."],["get_expr_use_or_unification_node","Gets the node where an expression is either used, or it’s type is unified with another branch. Returns both the node and the `HirId` of the closest child node."],["get_item_name","Gets the name of the item the expression is in, if available."],["get_parent_as_impl","Gets the parent node if it’s an impl block."],["get_parent_expr","Gets the parent expression, if any –- this is useful to constrain a lint."],["get_parent_expr_for_hir","This retrieves the parent for the given `HirId` if it’s an expression. This is useful for constraint lints"],["get_parent_node","Gets the parent node, if any."],["get_trait_def_id","Convenience function to get the `DefId` of a trait by path. It could be a trait or trait alias."],["has_attr",""],["hash_expr",""],["hash_stmt",""],["if_sequence","Returns the list of condition expressions and the list of blocks in a sequence of `if/else`. E.g., this returns `([a, b], [c, d, e])` for the expression `if a { c } else if b { d } else { e }`."],["in_constant","Returns `true` if the given `NodeId` is inside a constant context"],["int_bits",""],["is_adjusted","Returns `true` if the given `Expr` has been coerced before."],["is_async_fn","Checks if the given function kind is an async function."],["is_ctor_or_promotable_const_function","Checks if an expression is constructing a tuple-like enum variant or struct"],["is_default_equivalent","Returns true if the expr is equal to `Default::default()` of it’s type when evaluated. It doesn’t cover all cases, for example indirect function calls (some of std functions are supported) but it is the best we have."],["is_default_equivalent_call","Return true if the expr is equal to `Default::default` when evaluated."],["is_default_equivalent_ctor","Returns true if the `def_id` associated with the `path` is recognized as a “default-equivalent” constructor from the std library"],["is_diag_item_method","Checks if a method is defined in an impl of a diagnostic item"],["is_diag_trait_item","Checks if a method is in a diagnostic item trait"],["is_direct_expn_of","Returns the pre-expansion span if the span directly comes from an expansion of the macro `name`. The difference with [`is_expn_of`] is that in"],["is_else_clause","Checks if the given expression is the else clause of either an `if` or `if let` expression."],["is_entrypoint_fn","Returns `true` if the provided `def_id` is an entrypoint to a program."],["is_expn_of","Returns the pre-expansion span if this comes from an expansion of the macro `name`. See also [`is_direct_expn_of`]."],["is_expr_final_block_expr","Checks if the expression is the final expression returned from a block."],["is_expr_identity_function","Checks if an expression represents the identity function Only examines closures and `std::convert::identity`"],["is_expr_path_def_path","If the expression is a path, resolves it to a `DefId` and checks if it matches the given path."],["is_expr_used_or_unified","Checks if the result of an expression is used, or it’s type is unified with another branch."],["is_from_proc_macro","Checks if the item likely came from a proc-macro."],["is_hir_ty_cfg_dependant",""],["is_in_cfg_test","Checks if the item containing the given `HirId` has `#[cfg(test)]` attribute applied"],["is_in_panic_handler","Returns `true` if the expression is in the program’s `#[panic_handler]`."],["is_in_test_function","Checks if the function containing the given `HirId` is a `#[test]` function"],["is_integer_const","Checks whether the given expression is a constant integer of the given value. unlike `is_integer_literal`, this version does const folding"],["is_integer_literal","Checks whether the given expression is a constant literal of the given value."],["is_lang_ctor","Checks if a `QPath` resolves to a constructor of a `LangItem`. For example, use this to check whether a function call or a pattern is `Some(..)`."],["is_lint_allowed","Returns `true` if the lint is allowed in the current context. This is useful for skipping long running code when it’s unnecessary"],["is_must_use_func_call",""],["is_no_core_crate",""],["is_no_std_crate",""],["is_path_diagnostic_item","If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if it matches the given diagnostic item."],["is_refutable","Returns `true` if a pattern is refutable."],["is_self",""],["is_self_ty",""],["is_slice_of_primitives","Returns Option where String is a textual representation of the type encapsulated in the slice iff the given expression is a slice of primitives (as defined in the `is_recursively_primitive_type` function) and None otherwise."],["is_span_if","Checks if the span actually refers to an if expression"],["is_span_match","Checks if the span actually refers to a match expression"],["is_test_module_or_function","Checks whether item either has `test` attribute applied, or is a module with `test` in its name."],["is_trait_impl_item","Check if parent of a hir node is a trait implementation block. For example, `f` in"],["is_trait_item","Checks if the given expression is a path referring an item on the trait that is marked with the given diagnostic item."],["is_trait_method","Checks if the method call given in `expr` belongs to the given trait."],["is_try","Checks if a given expression is a match expression expanded from the `?` operator or the `try` macro."],["is_unit_expr",""],["is_wild","Checks if given pattern is a wildcard (`_`)"],["iter_input_pats",""],["last_path_segment",""],["line_span","Extends the span to the beginning of the spans line, incl. whitespaces."],["match_any_def_paths","Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if any."],["match_def_path","Checks if the given `DefId` matches the path."],["match_function_call","Matches a function call with the given path and returns the arguments."],["match_libc_symbol","Checks if the given `DefId` matches the `libc` item."],["match_path","THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from `QPath::Resolved.1.res.opt_def_id()`."],["match_qpath","THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from `QPath::Resolved.1.res.opt_def_id()`."],["match_trait_method","Checks if the method call given in `expr` belongs to the given trait. This is a deprecated function, consider using [`is_trait_method`]."],["meets_msrv",""],["method_calls","Returns the method names and argument list of nested method call expressions that make up `expr`. method/span lists are sorted with the most recent call first."],["method_chain_args","Matches an `Expr` against a chain of methods, and return the matched `Expr`s."],["nth_arg","Convenience function to get the nth argument type of a function."],["over","Checks if two slices are equal as per `eq_fn`."],["parse_msrv",""],["path_def_id","If `maybe_path` is a path node which resolves to an item, retrieves the item ID"],["path_res","If `maybe_path` is a path node, resolves it, otherwise returns `Res::Err`"],["path_to_local","If the expression is a path to a local, returns the canonical `HirId` of the local."],["path_to_local_id","Returns true if the expression is a path to a local with the specified `HirId`. Use this function to see if an expression matches a function argument or a match binding."],["peel_blocks","Removes blocks around an expression, only if the block contains just one expression and no statements. Unsafe blocks are not removed."],["peel_blocks_with_stmt","Removes blocks around an expression, only if the block contains just one expression or just one expression statement with a semicolon. Unsafe blocks are not removed."],["peel_hir_expr_refs","Peels off all references on the expression. Returns the underlying expression and the number of references removed."],["peel_hir_expr_while","Peels of expressions while the given closure returns `Some`."],["peel_hir_pat_refs","Peels off all references on the pattern. Returns the underlying pattern and the number of references removed."],["peel_hir_ty_refs","Peels off all references on the type. Returns the underlying type and the number of references removed."],["peel_n_hir_expr_refs","Peels off up to the given number of references on the expression. Returns the underlying expression and the number of references removed."],["peel_ref_operators","Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is dereferenced. An overloaded deref such as `Vec` to slice would not be removed."],["projection_stack","This method will return tuple of projection stack and root of the expression, used in `can_mut_borrow_both`."],["qpath_generic_tys",""],["recurse_or_patterns","If the pattern is an `or` pattern, call the function once for each sub pattern. Otherwise, call the function once on the given pattern."],["return_ty","Convenience function to get the return type of a function."],["search_same","returns list of all pairs (a, b) from `exprs` such that `eq(a, b)` `hash` must be comformed with `eq`"],["sext","Turn a constant int byte representation into an i128"],["span_contains_comment","Checks whether a given span has any comment token This checks for all types of comment: line “//”, block “/**”, doc “///” “//!”"],["std_or_core",""],["strip_pat_refs",""],["trait_ref_of_method","Gets the `hir::TraitRef` of the trait the given method is implemented for."],["unsext","clip unused bytes"],["walk_to_expr_usage","Walks the HIR tree from the given expression, up to the node where the value produced by the expression is consumed. Calls the function for every node encountered this way until it returns `Some`."],["with_test_item_names",""]],"macro":[["extract_msrv_attr",""],["maybe_path",""],["op_utils",""],["sym","Convenience wrapper around rustc’s `Symbol::intern`"]],"mod":[["ast_utils","Utilities for manipulating and extracting information from `rustc_ast::ast`."],["attrs",""],["check_proc_macro","This module handles checking if the span given is from a proc-macro or not."],["comparisons","Utility functions about comparison operators."],["consts",""],["diagnostics","Clippy wrappers around rustc’s diagnostic functions."],["eager_or_lazy","Utilities for evaluating whether eagerly evaluated expressions can be made lazy and vice versa."],["higher","This module contains functions that retrieve specific elements."],["hir_utils",""],["macros",""],["msrvs",""],["numeric_literal",""],["paths","This module contains paths to types and functions Clippy needs to know about."],["ptr",""],["qualify_min_const_fn",""],["source","Utils for extracting, inspecting or transforming source code"],["str_utils",""],["sugg","Contains utility functions to generate suggestions."],["sym_helper",""],["ty","Util methods for [`rustc_middle::ty`]"],["usage",""],["visitors",""]],"static":[["BINOP_TRAITS","Binary operation traits like `LangItem::Add`"],["OP_ASSIGN_TRAITS","Operator-Assign traits like `LangItem::AddAssign`"],["TEST_ITEM_NAMES_CACHE",""]],"struct":[["ContainsName",""],["HirEqInterExpr",""],["SpanlessEq","Type used to check whether two ast are the same. This is different from the operator `==` on ast types as this operator would compare true equality with ID and span."],["SpanlessHash","Type used to hash an ast element. This is different from the `Hash` trait on ast types as this trait would consider IDs and spans."]],"trait":[["MaybePath",""]],"type":[["MethodArguments","Arguments of a method: the receiver and all the additional arguments."]]};