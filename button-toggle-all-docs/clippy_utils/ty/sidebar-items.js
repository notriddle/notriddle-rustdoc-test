window.SIDEBAR_ITEMS = {"enum":[["EnumValue",""],["ExprFnSig","A signature for a function like type."]],"fn":[["all_predicates_of","Gets an iterator over all predicates which apply to the given item."],["approx_ty_size","Comes up with an “at least” guesstimate for the type’s size, not taking into account the layout of type parameters."],["can_partially_move_ty","Checks whether a type can be partially moved."],["contains_adt_constructor","Walks into `ty` and returns `true` if any inner type is an instance of the given adt constructor."],["expr_sig","If the expression is function like, get the signature for it."],["for_each_top_level_late_bound_region",""],["get_associated_type","Returns the associated type `name` for `ty` as an implementation of `trait_id`. Do not invoke without first verifying that the type implements the trait."],["get_discriminant_value","Gets the value of the given variant."],["get_iterator_item_ty","Resolves `<T as Iterator>::Item` for `T` Do not invoke without first verifying that the type implements `Iterator`"],["get_type_diagnostic_name","Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type implements a trait marked with a diagnostic item use [`implements_trait`]."],["has_drop","Checks whether this type implements `Drop`."],["has_iter_method","Returns true if ty has `iter` or `iter_mut` methods"],["implements_trait","Checks whether a type implements a trait. The function returns false in case the type contains an inference variable."],["implements_trait_with_env","Same as `implements_trait` but allows using a `ParamEnv` different from the lint context."],["is_c_void","Check if the given type is either `core::ffi::c_void`, `std::os::raw::c_void`, or one of the platform specific `libc::<platform>::c_void` types in libc."],["is_copy",""],["is_isize_or_usize","Return `true` if the passed `typ` is `isize` or `usize`."],["is_must_use_ty",""],["is_non_aggregate_primitive_type","Returns `true` if the given type is a non aggregate primitive (a `bool` or `char`, any integer or floating-point number type). For checking aggregation of primitive types (e.g. tuples and slices of primitive type) see `is_recursively_primitive_type`"],["is_normalizable","Checks if `Ty` is normalizable. This function is useful to avoid crashes on `layout_of`."],["is_normalizable_helper",""],["is_recursively_primitive_type","Returns `true` if the given type is a primitive (a `bool` or `char`, any integer or floating-point number type, a `str`, or an array, slice, or tuple of those types)."],["is_type_diagnostic_item","Checks if the type is equal to a diagnostic item. To check if a type implements a trait marked with a diagnostic item use [`implements_trait`]."],["is_type_lang_item","Checks if the type is equal to a lang item."],["is_type_ref_to_diagnostic_item","Checks if the type is a reference equals to a diagnostic item"],["is_uninit_value_valid_for_ty","Checks if a given type looks safe to be uninitialized."],["match_type","Checks if type is struct, enum or union type with the given def path."],["needs_ordered_drop","Checks if the drop order for a type matters. Some std types implement drop solely to deallocate memory. For these types, and composites containing them, changing the drop order won’t result in any observable side effects."],["peel_mid_ty_refs","Peels off all references on the type. Returns the underlying type and the number of references removed."],["peel_mid_ty_refs_is_mutable","Peels off all references on the type. Returns the underlying type, the number of references removed, and whether the pointer is ultimately mutable or not."],["read_explicit_enum_value","Attempts to read the given constant as though it were an an enum value."],["same_type_and_consts","Returns `true` if types `a` and `b` are same types having same `Const` generic args, otherwise returns `false`"],["sig_for_projection",""],["sig_from_bounds",""],["ty_is_fn_once_param","Checks if the type is a type parameter implementing `FnOnce`, but not `FnMut`."],["ty_sig","If the type is function like, get the signature for it."],["type_is_unsafe_function","Returns `true` if the given type is an `unsafe` function."],["variant_of_res","Gets the struct or enum variant from the given `Res`"],["walk_ptrs_hir_ty","Returns the base type for HIR references and pointers."],["walk_ptrs_ty_depth","Returns the base type for references and raw pointers, and count reference depth."]]};