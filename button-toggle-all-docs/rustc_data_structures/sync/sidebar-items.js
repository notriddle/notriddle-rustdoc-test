window.SIDEBAR_ITEMS = {"enum":[["Ordering","Atomic memory orderings"]],"fn":[["assert_send",""],["assert_send_sync_val",""],["assert_send_val",""],["assert_sync",""],["join",""],["par_for_each_in",""],["par_iter",""]],"struct":[["Atomic","This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc. It has explicit ordering arguments and is only intended for use with the native atomic types. You should use this type through the `AtomicU64`, `AtomicUsize`, etc, type aliases as it’s not intended to be used separately."],["Lock",""],["LockGuard","A wrapper type for a mutably borrowed value from a `RefCell<T>`."],["Lrc","A single-threaded reference-counting pointer. ‘Rc’ stands for ‘Reference Counted’."],["MTLock",""],["MappedLockGuard","A wrapper type for a mutably borrowed value from a `RefCell<T>`."],["MappedReadGuard","Wraps a borrowed reference to a value in a `RefCell` box. A wrapper type for an immutably borrowed value from a `RefCell<T>`."],["MappedWriteGuard","A wrapper type for a mutably borrowed value from a `RefCell<T>`."],["OnceCell","A cell which can be written to only once."],["OneThread","A type which only allows its inner value to be used in one thread. It will panic if it is used on multiple threads."],["ReadGuard","Wraps a borrowed reference to a value in a `RefCell` box. A wrapper type for an immutably borrowed value from a `RefCell<T>`."],["RwLock",""],["Weak","`Weak` is a version of [`Rc`] that holds a non-owning reference to the managed allocation. The allocation is accessed by calling `upgrade` on the `Weak` pointer, which returns an [Option]<[Rc]<T>>."],["WorkerLocal",""],["WriteGuard","A wrapper type for a mutably borrowed value from a `RefCell<T>`."]],"trait":[["HashMapExt",""],["ParallelIterator","An interface for dealing with iterators."],["Send",""],["Sync",""]],"type":[["AtomicBool",""],["AtomicU32",""],["AtomicU64",""],["AtomicUsize",""],["MTRef",""],["MetadataRef",""]]};