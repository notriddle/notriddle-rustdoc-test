window.SIDEBAR_ITEMS = {"enum":[["DefiningAnchor",""],["FixupError",""],["IntVarValue",""],["LateBoundRegionConversionTime","Times when we replace late-bound regions with variables:"],["NllRegionVariableOrigin",""],["RegionResolutionError",""],["RegionVariableOrigin","Reasons to create a region inference variable"],["SubregionOrigin","The origin of a `r1 <= r2` constraint."],["TyOrConstInferVar","Helper for `ty_or_const_infer_var_changed` (see comment on that), currently used only for `traits::fulfill`’s list of `stalled_on` inference variables."],["ValuePairs","See the `error_reporting` module for more details."]],"mod":[["at","A nice interface for working with the infcx. The basic idea is to do `infcx.at(cause, param_env)`, which sets the “cause” of the operation as well as the surrounding parameter environment. Then you can do something like `.sub(a, b)` or `.eq(a, b)` to create a subtype or equality relationship respectively. The first argument is always the “expected” output from the POV of diagnostics."],["canonical","Canonicalization is the key to constructing a query in the middle of type inference. Ordinarily, it is not possible to store types from type inference in query keys, because they contain references to inference variables whose lifetimes are too short and so forth. Canonicalizing a value T1 using `canonicalize_query` produces two things:"],["error_reporting","Error Reporting Code for the inference engine"],["free_regions","This module handles the relationships between “free regions”, i.e., lifetime parameters. Ordinarily, free regions are unrelated to one another, but they can be related via implied or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type, and use that to decide when one free region outlives another, and so forth."],["lattice","Lattice variables"],["nll_relate","This code is kind of an alternate way of doing subtyping, supertyping, and type equating, distinct from the `combine.rs` code but very similar in its effect and design. Eventually the two ought to be merged. This code is intended for use in NLL and chalk."],["opaque_types",""],["outlives","Various code related to computing outlives relations."],["region_constraints","See `README.md`."],["resolve",""],["type_variable",""]],"struct":[["CombinedSnapshot",""],["InferCtxt",""],["InferCtxtBuilder","A temporary returned by `tcx.infer_ctxt()`. This is necessary for multiple `InferCtxt` to share the same `in_progress_typeck_results` without using `Rc` or something similar."],["InferCtxtInner","This type contains all the things within `InferCtxt` that sit within a `RefCell` and are involved with taking/rolling back snapshots. Snapshot operations are hot enough that we want only one call to `borrow_mut` per call to `start_snapshot` and `rollback_to`."],["InferOk",""],["RegionObligation","See the `region_obligations` field for more information."],["TypeFreshener",""],["TypeTrace","The trace designates the path through inference that we took to encounter an error or subtyping constraint."]],"trait":[["InferCtxtBuilderExt",""],["InferCtxtExt",""],["TyCtxtInferExt",""]],"type":[["Bound",""],["FixupResult",""],["InferResult",""],["UnitResult",""]]};