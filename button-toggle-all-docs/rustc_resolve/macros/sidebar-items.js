window.SIDEBAR_ITEMS = {"enum":[["MacroRulesScope","The scope introduced by a `macro_rules!` macro. This starts at the macro’s definition and ends at the end of the macro’s parent module (named or unnamed), or even further if it escapes with `#[macro_use]`. Some macro invocations need to introduce `macro_rules` scopes too because they can potentially expand into macro definitions."]],"fn":[["fast_print_path",""],["registered_tools",""],["soft_custom_inner_attributes_gate",""],["sub_namespace_match","Macro namespace is separated into two sub-namespaces, one for bang macros and one for attribute-like macros (attributes, derives). We ignore resolutions from one sub-namespace when searching names in scope for another."]],"struct":[["MacroRulesBinding","Binding produced by a `macro_rules` item. Not modularized, can shadow previous `macro_rules` bindings, etc."]],"type":[["MacroRulesScopeRef","`macro_rules!` scopes are always kept by reference and inside a cell. The reason is that we update scopes with value `MacroRulesScope::Invocation(invoc_id)` in-place after `invoc_id` gets expanded. This helps to avoid uncontrollable growth of `macro_rules!` scope chains, which usually grow linearly with the number of macro invocations in a module (including derives) and hurt performance."],["Res",""]]};