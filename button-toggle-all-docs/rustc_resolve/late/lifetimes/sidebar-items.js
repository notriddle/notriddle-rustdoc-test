window.SIDEBAR_ITEMS = {"constant":[["ROOT_SCOPE",""]],"enum":[["BinderScopeType",""],["Scope",""]],"fn":[["convert_named_region_map",""],["do_resolve",""],["is_late_bound_map","Detects late-bound lifetimes and inserts them into `late_bound`."],["item_for","Finds the `Item` that contains the given `LocalDefId`"],["late_region_as_bound_region",""],["object_lifetime_default",""],["provide",""],["resolve_lifetimes","Computes the `ResolveLifetimes` map that contains data for an entire `Item`. You should not read the result of this query directly, but rather use `named_region_map`, `is_late_bound_map`, etc."],["resolve_lifetimes_for","Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution. There are two important things this does. First, we have to resolve lifetimes for the entire `Item` that contains this owner, because that’s the largest “scope” where we can have relevant lifetimes. Second, if we are asking for lifetimes in a trait definition, we use `resolve_lifetimes_trait_definition` instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics. This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner other than the trait itself (like the trait methods or associated types), then we just use the regular `resolve_lifetimes`."],["resolve_lifetimes_trait_definition","Like `resolve_lifetimes`, but does not resolve lifetimes for trait items. Also does not generate any diagnostics."]],"struct":[["LifetimeContext",""],["NamedRegionMap","Maps the id of each lifetime reference to the lifetime decl that it corresponds to."],["TruncatedScopeDebug",""]],"trait":[["RegionExt",""]],"type":[["ScopeRef",""]]};