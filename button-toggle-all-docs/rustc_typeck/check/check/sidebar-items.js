window.SIDEBAR_ITEMS = {"fn":[["async_opaque_type_cycle_error",""],["check_abi",""],["check_alloc_error_fn",""],["check_enum",""],["check_fn","Helper used for fns and closures. Does the grungy work of checking a function body and returns the function context used for that purpose, since in the case of a fn item there is still a bit more to do."],["check_impl_items_against_trait",""],["check_item_type",""],["check_mod_item_types",""],["check_on_unimplemented",""],["check_opaque","Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo` projections that would result in “inheriting lifetimes”."],["check_opaque_for_cycles","Checks that an opaque type does not contain cycles."],["check_opaque_for_inheriting_lifetimes","Checks that an opaque type does not use `Self` or `T::Foo` projections that would result in “inheriting lifetimes”."],["check_opaque_meets_bounds","Check that the concrete type behind `impl Trait` actually implements `Trait`."],["check_packed",""],["check_packed_inner",""],["check_panic_info_fn",""],["check_representable","Checks whether a type can be represented in memory. In particular, it identifies types that contain themselves without indirection through a pointer, which would mean their size is unbounded."],["check_simd",""],["check_specialization_validity",""],["check_static_inhabited","Check that a `static` is inhabited."],["check_struct",""],["check_transparent",""],["check_type_params_are_used",""],["check_union",""],["check_union_fields","Check that the fields of the `union` do not need dropping."],["detect_discriminant_duplicate","Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal"],["opaque_type_cycle_error","Emit an error for recursive opaque types."]]};