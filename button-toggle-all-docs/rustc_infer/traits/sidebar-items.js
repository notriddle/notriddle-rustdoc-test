window.SIDEBAR_ITEMS = {"enum":[["CodegenObligationError","These are the error cases for `codegen_select_candidate`."],["EvaluationResult","The result of trait evaluation. The order is important here as the evaluation of a list is the maximum of the evaluations."],["FulfillmentErrorCode",""],["ImplSource","Given the successful resolution of an obligation, the `ImplSource` indicates where the impl comes from."],["MethodViolationCode","Reasons a method might not be object-safe."],["ObjectSafetyViolation",""],["ObligationCauseCode",""],["OverflowError","Indicates that trait evaluation caused overflow and in which pass."],["ProjectionCacheEntry",""],["Reveal","Depending on the stage of compilation, we want projection to be more or less conservative."],["SelectionError",""],["StatementAsExpression",""],["WellFormedLoc","The ‘location’ at which we try to perform HIR-based wf checking. This information is used to obtain an `hir::Ty`, which we can walk in order to obtain precise spans for any ‘nested’ types (e.g. `Foo` in `Option<Foo>`)."]],"mod":[["engine",""],["error_reporting",""],["project","Code for projecting associated types out of trait references."],["query","Experimental types for the trait query interface. The methods defined in this module are all based on canonicalization, which makes a canonical query by replacing unbound inference variables and regions, so that results can be reused more broadly. The providers for the queries defined here can be found in `rustc_traits`."],["select","Candidate selection. See the rustc dev guide for more information on how this works."],["specialization_graph",""],["structural_impls",""],["util",""]],"struct":[["ChalkEnvironmentAndGoal","A chalk environment and goal."],["ChalkRustInterner",""],["DerivedObligationCause",""],["FulfillmentError",""],["IfExpressionCause",""],["ImplDerivedObligationCause",""],["ImplSourceAutoImplData",""],["ImplSourceBuiltinData",""],["ImplSourceClosureData",""],["ImplSourceConstDestructData",""],["ImplSourceDiscriminantKindData",""],["ImplSourceFnPointerData",""],["ImplSourceGeneratorData",""],["ImplSourceObjectData",""],["ImplSourcePointeeData",""],["ImplSourceTraitAliasData",""],["ImplSourceTraitUpcastingData",""],["ImplSourceUserDefinedData","Identifies a particular impl in the source, along with a set of substitutions from the impl’s type/lifetime parameters. The `nested` vector corresponds to the nested obligations attached to the impl’s type parameters."],["InternedObligationCauseCode",""],["MatchExpressionArmCause",""],["MismatchedProjectionTypes",""],["Normalized",""],["Obligation","An `Obligation` represents some trait reference (e.g., `i32: Eq`) for which the “impl_source” must be found. The process of finding an “impl_source” is called “resolving” the `Obligation`. This process consists of either identifying an `impl` (e.g., `impl Eq for i32`) that satisfies the obligation, or else finding a bound that is in scope. The eventual result is usually a `Selection` (defined below)."],["ObligationCause","The reason why we incurred this obligation; used for error reporting."],["ProjectionCache","The projection cache. Unlike the standard caches, this can include infcx-dependent type variables, therefore we have to roll the cache back each time we roll a snapshot back, to avoid assumptions on yet-unresolved inference variables. Types with placeholder regions also have to be removed when the respective snapshot ends."],["ProjectionCacheKey",""],["ProjectionCacheStorage",""],["UnifyReceiverContext",""]],"trait":[["TraitEngine",""],["TraitEngineExt",""]],"type":[["CanonicalChalkEnvironmentAndGoal",""],["EvaluationCache",""],["NormalizedTy",""],["PredicateObligation",""],["PredicateObligations",""],["Selection",""],["SelectionCache",""],["SelectionResult","When performing resolution, it is typically the case that there can be one of three outcomes:"],["TraitObligation",""]]};