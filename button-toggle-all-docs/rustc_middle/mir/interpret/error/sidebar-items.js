window.SIDEBAR_ITEMS = {"enum":[["CheckInAllocMsg","Details of why a pointer had to be in-bounds."],["ErrorHandled",""],["InterpError",""],["InvalidProgramInfo","Error information for when the program we executed turned out not to actually be a valid program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp where we work on generic code or execution does not have all information available."],["ResourceExhaustionInfo","Error information for when the program exhausted the resources granted to it by the interpreter."],["UndefinedBehaviorInfo","Error information for when the program caused Undefined Behavior."],["UnsupportedOpInfo","Error information for when the program did something that might (or might not) be correct to do according to the Rust spec, but due to limitations in the interpreter, the operation could not be carried out. These limitations can differ between CTFE and the Miri engine, e.g., CTFE does not support dereferencing pointers at integral addresses."]],"fn":[["print_backtrace",""],["struct_error",""]],"struct":[["InterpErrorInfo","Packages the kind of error we got from the const code interpreter up with a Rust-level backtrace of where the error occurred. These should always be constructed by calling `.into()` on an `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*` macros for this."],["InterpErrorInfoInner",""],["ScalarSizeMismatch","Information about a size mismatch."],["UninitBytesAccess","Details of an access to uninitialized bytes where it is not allowed."]],"trait":[["AsAny","A trait to work around not having trait object upcasting."],["MachineStopType","A trait for machine-specific errors (or other “machine stop” conditions)."]],"type":[["EvalToAllocationRawResult",""],["EvalToConstValueResult",""],["EvalToValTreeResult",""],["InterpResult",""]]};