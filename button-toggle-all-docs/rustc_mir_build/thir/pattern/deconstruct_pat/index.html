<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="[`super::usefulness`] explains most of what is happening in this file. As explained there, values and patterns are made from constructors applied to fields. This file defines a `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert them from/to patterns."><meta name="keywords" content="rust, rustlang, rust-lang, deconstruct_pat"><title>rustc_mir_build::thir::pattern::deconstruct_pat - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../../normalize.css"><link rel="stylesheet" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../../ayu.css" disabled><link rel="stylesheet" href="../../../../dark.css" disabled><link rel="stylesheet" href="../../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../../storage.js"></script><script defer src="../../../../main.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../../rustc_mir_build/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../../rustc_mir_build/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module deconstruct_pat</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../../rustc_mir_build/index.html"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../../../index.html">rustc_mir_build</a>::<wbr><a href="../../index.html">thir</a>::<wbr><a href="../index.html">pattern</a>::<wbr><a class="mod" href="#">deconstruct_pat</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../../src/rustc_mir_build/thir/pattern/deconstruct_pat.rs.html#1-1720">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="../usefulness/index.html" title="super::usefulness"><code>super::usefulness</code></a> explains most of what is happening in this file. As explained there,
values and patterns are made from constructors applied to fields. This file defines a
<code>Constructor</code> enum, a <code>Fields</code> struct, and various operations to manipulate them and convert
them from/to patterns.</p>
<p>Thereâ€™s one idea that is not detailed in <a href="../usefulness/index.html" title="super::usefulness"><code>super::usefulness</code></a> because the details are not
needed there: <em>constructor splitting</em>.</p>
<h2 id="constructor-splitting"><a href="#constructor-splitting">Constructor splitting</a></h2>
<p>The idea is as follows: given a constructor <code>c</code> and a matrix, we want to specialize in turn
with all the value constructors that are covered by <code>c</code>, and compute usefulness for each.
Instead of listing all those constructors (which is intractable), we group those value
constructors together as much as possible. Example:</p>

<div class="example-wrap compile_fail"><div class='tooltip'>â“˜</div><pre class="rust rust-example-rendered"><code><span class="kw">match </span>(<span class="number">0</span>, <span class="bool-val">false</span>) {
    (<span class="number">0 </span>..=<span class="number">100</span>, <span class="bool-val">true</span>) =&gt; {} <span class="comment">// `p_1`
    </span>(<span class="number">50</span>..=<span class="number">150</span>, <span class="bool-val">false</span>) =&gt; {} <span class="comment">// `p_2`
    </span>(<span class="number">0 </span>..=<span class="number">200</span>, <span class="kw">_</span>) =&gt; {} <span class="comment">// `q`
</span>}</code></pre></div>
<p>The naive approach would try all numbers in the range <code>0..=200</code>. But we can be a lot more
clever: <code>0</code> and <code>1</code> for example will match the exact same rows, and return equivalent
witnesses. In fact all of <code>0..50</code> would. We can thus restrict our exploration to 4
constructors: <code>0..50</code>, <code>50..=100</code>, <code>101..=150</code> and <code>151..=200</code>. That is enough and infinitely
more tractable.</p>
<p>We capture this idea in a function <code>split(p_1 ... p_n, c)</code> which returns a list of constructors
<code>c'</code> covered by <code>c</code>. Given such a <code>c'</code>, we require that all value ctors <code>c''</code> covered by <code>c'</code>
return an equivalent set of witnesses after specializing and computing usefulness.
In the example above, witnesses for specializing by <code>c''</code> covered by <code>0..50</code> will only differ
in their first element.</p>
<p>We usually also ask that the <code>c'</code> together cover all of the original <code>c</code>. However we allow
skipping some constructors as long as it doesnâ€™t change whether the resulting list of witnesses
is empty of not. We use this in the wildcard <code>_</code> case.</p>
<p>Splitting is implemented in the <a href="enum.Constructor.html#method.split" title="Constructor::split"><code>Constructor::split</code></a> function. We donâ€™t do splitting for
or-patterns; instead we just try the alternatives one-by-one. For details on splitting
wildcards, see <a href="struct.SplitWildcard.html" title="SplitWildcard"><code>SplitWildcard</code></a>; for integer ranges, see <a href="struct.SplitIntRange.html" title="SplitIntRange"><code>SplitIntRange</code></a>; for slices, see
<a href="struct.SplitVarLenSlice.html" title="SplitVarLenSlice"><code>SplitVarLenSlice</code></a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.DeconstructedPat.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::DeconstructedPat struct">DeconstructedPat</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Values and patterns can be represented as a constructor applied to some fields. This represents
a pattern in this form.
This also keeps track of whether the pattern has been found reachable during analysis. For this
reason we should be careful not to clone patterns for which we care about that. Use
<code>clone_and_forget_reachability</code> if youâ€™re sure.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.Fields.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::Fields struct">Fields</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">A value can be decomposed into a constructor applied to some fields. This struct represents
those fields, generalized to allow patterns in each field. See also <code>Constructor</code>.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.IntRange.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::IntRange struct">IntRange</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">An inclusive interval, used for precise integer exhaustiveness checking.
<code>IntRange</code>s always store a contiguous range. This means that values are
encoded such that <code>0</code> encodes the minimum value for the integer,
regardless of the signedness.
For example, the pattern <code>-128..=127i8</code> is encoded as <code>0..=255</code>.
This makes comparisons and arithmetic on interval endpoints much more
straightforward. See <code>signed_bias</code> for details.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.Slice.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::Slice struct">Slice</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">A constructor for array and slice patterns.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.SplitIntRange.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::SplitIntRange struct">SplitIntRange</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">A range of integers that is partitioned into disjoint subranges. This does constructor
splitting for integer ranges as explained at the top of the file.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.SplitVarLenSlice.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::SplitVarLenSlice struct">SplitVarLenSlice</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">This computes constructor splitting for variable-length slices, as explained at the top of the
file.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.SplitWildcard.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::SplitWildcard struct">SplitWildcard</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">A wildcard constructor that we split relative to the constructors in the matrix, as explained
at the top of the file.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="enum" href="enum.Constructor.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::Constructor enum">Constructor</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">A value can be decomposed into a constructor applied to some fields. This struct represents
the constructor. See also <code>Fields</code>.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="enum" href="enum.IntBorder.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::IntBorder enum">IntBorder</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Represents a border between 2 integers. Because the intervals spanning borders must be able to
cover every integer, we need to be able to represent 2^128 + 1 such borders.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="enum" href="enum.SliceKind.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::SliceKind enum">SliceKind</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.expand_or_pat.html" title="rustc_mir_build::thir::pattern::deconstruct_pat::expand_or_pat fn">expand_or_pat</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Recursively expand this pattern into its subpatterns. Only useful for or-patterns.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="rustc_mir_build" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0-dev" ></div></body></html>