window.SIDEBAR_ITEMS = {"enum":[["ArmType",""],["Reachability","Indicates whether or not a given arm is reachable."],["Usefulness","This carries the results of computing usefulness, as described at the top of the file. When checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track of potential unreachable sub-patterns (in the presence of or-patterns). When checking exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of witnesses of non-exhaustiveness when there are any. Which variant to use is dictated by `ArmType`."]],"fn":[["compute_match_usefulness","The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which of its arms are reachable."],["is_useful","Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html. The algorithm from the paper has been modified to correctly handle empty types. The changes are: (0) We donâ€™t exit early if the pattern matrix has zero rows. We just continue to recurse over columns. (1) all_constructors will only return constructors that are statically possible. E.g., it will only return `Ok` for `Result<T, !>`."],["lint_non_exhaustive_omitted_patterns","Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns` is not exhaustive enough."]],"struct":[["MatchArm","The arm of a match expression."],["MatchCheckCtxt",""],["Matrix","A 2D matrix."],["PatCtxt",""],["PatStack","A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]` works well."],["UsefulnessReport","The output of checking a match for exhaustiveness and arm reachability."],["Witness","A witness of non-exhaustiveness for error reporting, represented as a list of patterns (in reverse order of construction) with wildcards inside to represent elements that can take any inhabitant of the type as a value."]]};