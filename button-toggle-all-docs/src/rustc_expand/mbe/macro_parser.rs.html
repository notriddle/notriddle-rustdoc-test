<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `compiler/rustc_expand/src/mbe/macro_parser.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>macro_parser.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rustc_expand/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../rustc_expand/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rustc_expand/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
</pre><pre class="rust"><code><span class="doccomment">//! This is an NFA-based parser, which calls out to the main Rust parser for named non-terminals
//! (which it commits to fully when it hits one in a grammar). There&#39;s a set of current NFA threads
//! and a set of next ones. Instead of NTs, we have a special case for Kleene star. The big-O, in
//! pathological cases, is worse than traditional use of NFA or Earley parsing, but it&#39;s an easier
//! fit for Macro-by-Example-style rules.
//!
//! (In order to prevent the pathological case, we&#39;d need to lazily construct the resulting
//! `NamedMatch`es at the very end. It&#39;d be a pain, and require more memory to keep around old
//! matcher positions, but it would also save overhead)
//!
//! We don&#39;t say this parser uses the Earley algorithm, because it&#39;s unnecessarily inaccurate.
//! The macro parser restricts itself to the features of finite state automata. Earley parsers
//! can be described as an extension of NFAs with completion rules, prediction rules, and recursion.
//!
//! Quick intro to how the parser works:
//!
//! A &quot;matcher position&quot; (a.k.a. &quot;position&quot; or &quot;mp&quot;) is a dot in the middle of a matcher, usually
//! written as a `·`. For example `· a $( a )* a b` is one, as is `a $( · a )* a b`.
//!
//! The parser walks through the input a token at a time, maintaining a list
//! of threads consistent with the current position in the input string: `cur_mps`.
//!
//! As it processes them, it fills up `eof_mps` with threads that would be valid if
//! the macro invocation is now over, `bb_mps` with threads that are waiting on
//! a Rust non-terminal like `$e:expr`, and `next_mps` with threads that are waiting
//! on a particular token. Most of the logic concerns moving the · through the
//! repetitions indicated by Kleene stars. The rules for moving the · without
//! consuming any input are called epsilon transitions. It only advances or calls
//! out to the real Rust parser when no `cur_mps` threads remain.
//!
//! Example:
//!
//! ```text, ignore
//! Start parsing a a a a b against [· a $( a )* a b].
//!
//! Remaining input: a a a a b
//! next: [· a $( a )* a b]
//!
//! - - - Advance over an a. - - -
//!
//! Remaining input: a a a b
//! cur: [a · $( a )* a b]
//! Descend/Skip (first position).
//! next: [a $( · a )* a b]  [a $( a )* · a b].
//!
//! - - - Advance over an a. - - -
//!
//! Remaining input: a a b
//! cur: [a $( a · )* a b]  [a $( a )* a · b]
//! Follow epsilon transition: Finish/Repeat (first position)
//! next: [a $( a )* · a b]  [a $( · a )* a b]  [a $( a )* a · b]
//!
//! - - - Advance over an a. - - - (this looks exactly like the last step)
//!
//! Remaining input: a b
//! cur: [a $( a · )* a b]  [a $( a )* a · b]
//! Follow epsilon transition: Finish/Repeat (first position)
//! next: [a $( a )* · a b]  [a $( · a )* a b]  [a $( a )* a · b]
//!
//! - - - Advance over an a. - - - (this looks exactly like the last step)
//!
//! Remaining input: b
//! cur: [a $( a · )* a b]  [a $( a )* a · b]
//! Follow epsilon transition: Finish/Repeat (first position)
//! next: [a $( a )* · a b]  [a $( · a )* a b]  [a $( a )* a · b]
//!
//! - - - Advance over a b. - - -
//!
//! Remaining input: &#39;&#39;
//! eof: [a $( a )* a b ·]
//! ```

</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use </span><a href="#343">NamedMatch</a>::<span class="kw-2">*</span>;
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use </span><a href="#265">ParseResult</a>::<span class="kw-2">*</span>;

<span class="kw">use </span><span class="kw">crate</span>::mbe::{<a href="../mbe.rs.html#55">KleeneOp</a>, <a href="../mbe.rs.html#67">TokenTree</a>};

<span class="kw">use </span>rustc_ast::token::{<a class="self" href="../../../rustc_ast/token/index.html">self</a>, DocComment, <a href="../../../rustc_ast/token/enum.Nonterminal.html">Nonterminal</a>, <a href="../../../rustc_ast/token/enum.NonterminalKind.html">NonterminalKind</a>, <a href="../../../rustc_ast/token/struct.Token.html">Token</a>};
<span class="kw">use </span><a href="../../../rustc_lint_defs/macro.pluralize.html">rustc_lint_defs::pluralize</a>;
<span class="kw">use </span>rustc_parse::parser::{<a href="../../../rustc_parse/parser/enum.NtOrTt.html">NtOrTt</a>, <a href="../../../rustc_parse/parser/struct.Parser.html">Parser</a>};
<span class="kw">use </span><a href="../../../rustc_span/symbol/struct.MacroRulesNormalizedIdent.html">rustc_span::symbol::MacroRulesNormalizedIdent</a>;
<span class="kw">use </span><a href="../../../rustc_span/span_encoding/struct.Span.html">rustc_span::Span</a>;

<span class="kw">use </span>rustc_data_structures::fx::FxHashMap;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/alloc/rc/struct.Rc.html">rustc_data_structures::sync::Lrc</a>;
<span class="kw">use </span><a href="../../../rustc_span/symbol/struct.Ident.html">rustc_span::symbol::Ident</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html">std::borrow::Cow</a>;
<span class="kw">use </span>std::collections::hash_map::Entry::{Occupied, Vacant};

<span class="doccomment">/// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)
/// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.
/// Notable differences to `mbe::TokenTree`:
/// - It is non-recursive, i.e. there is no nesting.
/// - The end pieces of each sequence (the separator, if present, and the Kleene op) are
///   represented explicitly, as is the very end of the matcher.
///
/// This means a matcher can be represented by `&amp;[MatcherLoc]`, and traversal mostly involves
/// simply incrementing the current matcher position index by one.
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">enum </span>MatcherLoc {
    Token {
        token: <a href="../../../rustc_ast/token/struct.Token.html">Token</a>,
    },
    Delimited,
    Sequence {
        op: <a href="../mbe.rs.html#55">KleeneOp</a>,
        num_metavar_decls: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        idx_first_after: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        next_metavar: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        seq_depth: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    },
    SequenceKleeneOpNoSep {
        op: <a href="../mbe.rs.html#55">KleeneOp</a>,
        idx_first: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    },
    SequenceSep {
        separator: <a href="../../../rustc_ast/token/struct.Token.html">Token</a>,
    },
    SequenceKleeneOpAfterSep {
        idx_first: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    },
    MetaVarDecl {
        span: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>,
        bind: <a href="../../../rustc_span/symbol/struct.Ident.html">Ident</a>,
        kind: <span class="prelude-ty">Option</span>&lt;<a href="../../../rustc_ast/token/enum.NonterminalKind.html">NonterminalKind</a>&gt;,
        next_metavar: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        seq_depth: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    },
    Eof,
}

<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>compute_locs(matcher: <span class="kw-2">&amp;</span>[<a href="../mbe.rs.html#67">TokenTree</a>]) -&gt; Vec&lt;<a href="#99">MatcherLoc</a>&gt; {
    <span class="kw">fn </span>inner(
        tts: <span class="kw-2">&amp;</span>[<a href="../mbe.rs.html#67">TokenTree</a>],
        locs: <span class="kw-2">&amp;mut </span>Vec&lt;<a href="#99">MatcherLoc</a>&gt;,
        next_metavar: <span class="kw-2">&amp;mut </span><a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        seq_depth: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    ) {
        <span class="kw">for </span>tt <span class="kw">in </span>tts {
            <span class="kw">match </span>tt {
                TokenTree::Token(token) =&gt; {
                    locs.push(MatcherLoc::Token { token: token.clone() });
                }
                TokenTree::Delimited(span, delimited) =&gt; {
                    <span class="kw">let </span>open_token = Token::new(token::OpenDelim(delimited.delim), span.open);
                    <span class="kw">let </span>close_token = Token::new(token::CloseDelim(delimited.delim), span.close);

                    locs.push(MatcherLoc::Delimited);
                    locs.push(MatcherLoc::Token { token: open_token });
                    inner(<span class="kw-2">&amp;</span>delimited.tts, locs, next_metavar, seq_depth);
                    locs.push(MatcherLoc::Token { token: close_token });
                }
                TokenTree::Sequence(<span class="kw">_</span>, seq) =&gt; {
                    <span class="comment">// We can&#39;t determine `idx_first_after` and construct the final
                    // `MatcherLoc::Sequence` until after `inner()` is called and the sequence end
                    // pieces are processed. So we push a dummy value (`Eof` is cheapest to
                    // construct) now, and overwrite it with the proper value below.
                    </span><span class="kw">let </span>dummy = MatcherLoc::Eof;
                    locs.push(dummy);

                    <span class="kw">let </span>next_metavar_orig = <span class="kw-2">*</span>next_metavar;
                    <span class="kw">let </span>op = seq.kleene.op;
                    <span class="kw">let </span>idx_first = locs.len();
                    <span class="kw">let </span>idx_seq = idx_first - <span class="number">1</span>;
                    inner(<span class="kw-2">&amp;</span>seq.tts, locs, next_metavar, seq_depth + <span class="number">1</span>);

                    <span class="kw">if let </span><span class="prelude-val">Some</span>(separator) = <span class="kw-2">&amp;</span>seq.separator {
                        locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });
                        locs.push(MatcherLoc::SequenceKleeneOpAfterSep { idx_first });
                    } <span class="kw">else </span>{
                        locs.push(MatcherLoc::SequenceKleeneOpNoSep { op, idx_first });
                    }

                    <span class="comment">// Overwrite the dummy value pushed above with the proper value.
                    </span>locs[idx_seq] = MatcherLoc::Sequence {
                        op,
                        num_metavar_decls: seq.num_captures,
                        idx_first_after: locs.len(),
                        next_metavar: next_metavar_orig,
                        seq_depth,
                    };
                }
                <span class="kw-2">&amp;</span>TokenTree::MetaVarDecl(span, bind, kind) =&gt; {
                    locs.push(MatcherLoc::MetaVarDecl {
                        span,
                        bind,
                        kind,
                        next_metavar: <span class="kw-2">*</span>next_metavar,
                        seq_depth,
                    });
                    <span class="kw-2">*</span>next_metavar += <span class="number">1</span>;
                }
                TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) =&gt; <span class="macro">unreachable!</span>(),
            }
        }
    }

    <span class="kw">let </span><span class="kw-2">mut </span>locs = <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[];
    <span class="kw">let </span><span class="kw-2">mut </span>next_metavar = <span class="number">0</span>;
    <a href="#132-137">inner</a>(<a href="#131">matcher</a>, <span class="kw-2">&amp;mut </span><a href="#197">locs</a>, <span class="kw-2">&amp;mut </span><a href="#198">next_metavar</a>, <span class="comment">/* seq_depth */ </span><span class="number">0</span>);

    <span class="comment">// A final entry is needed for eof.
    </span><a href="#197">locs</a>.push(<a href="#128">MatcherLoc::Eof</a>);

    <a href="#197">locs</a>
}

<span class="doccomment">/// A single matcher position, representing the state of matching.
</span><span class="kw">struct </span>MatcherPos {
    <span class="doccomment">/// The index into `TtParser::locs`, which represents the &quot;dot&quot;.
    </span>idx: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,

    <span class="doccomment">/// The matches made against metavar decls so far. On a successful match, this vector ends up
    /// with one element per metavar decl in the matcher. Each element records token trees matched
    /// against the relevant metavar by the black box parser. An element will be a `MatchedSeq` if
    /// the corresponding metavar decl is within a sequence.
    ///
    /// It is critical to performance that this is an `Lrc`, because it gets cloned frequently when
    /// processing sequences. Mostly for sequence-ending possibilities that must be tried but end
    /// up failing.
    </span>matches: Lrc&lt;Vec&lt;<a href="#343">NamedMatch</a>&gt;&gt;,
}

<span class="comment">// This type is used a lot. Make sure it doesn&#39;t unintentionally get bigger.
</span><span class="attribute">#[cfg(all(target_arch = <span class="string">&quot;x86_64&quot;</span>, target_pointer_width = <span class="string">&quot;64&quot;</span>))]
</span><a class="macro" href="../../../rustc_index/rustc_index/macro.static_assert_size.html">rustc_data_structures::static_assert_size!</a>(MatcherPos, <span class="number">16</span>);

<span class="kw">impl </span><a href="#208">MatcherPos</a> {
    <span class="doccomment">/// Adds `m` as a named match for the `metavar_idx`-th metavar. There are only two call sites,
    /// and both are hot enough to be always worth inlining.
    </span><span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>push_match(<span class="kw-2">&amp;mut </span><span class="self">self</span>, metavar_idx: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, seq_depth: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, m: <a href="#343">NamedMatch</a>) {
        <span class="kw">let </span>matches = Lrc::make_mut(<span class="kw-2">&amp;mut </span><a class="self" href="#231">self</a>.matches);
        <span class="kw">match </span><a href="#231">seq_depth</a> {
            <span class="number">0 </span>=&gt; {
                <span class="comment">// We are not within a sequence. Just append `m`.
                </span><a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(metavar_idx, matches.len());
                <a href="#232">matches</a>.push(<a href="#231">m</a>);
            }
            <span class="kw">_ </span>=&gt; {
                <span class="comment">// We are within a sequence. Find the final `MatchedSeq` at the appropriate depth
                // and append `m` to its vector.
                </span><span class="kw">let </span><span class="kw-2">mut </span>curr = <span class="kw-2">&amp;mut </span><a href="#232">matches</a>[<a href="#231">metavar_idx</a>];
                <span class="kw">for _ in </span><span class="number">0</span>..seq_depth - <span class="number">1 </span>{
                    <span class="kw">match </span>curr {
                        MatchedSeq(seq) =&gt; curr = seq.last_mut().unwrap(),
                        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
                    }
                }
                <span class="kw">match </span><a href="#242">curr</a> {
                    <a href="#344">MatchedSeq</a>(seq) =&gt; <a href="#250">seq</a>.push(<a href="#231">m</a>),
                    <span class="kw">_ </span>=&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.unreachable.html">unreachable!</a>(),
                }
            }
        }
    }
}

<span class="kw">enum </span>EofMatcherPositions {
    <span class="prelude-val">None</span>,
    One(<a href="#208">MatcherPos</a>),
    Multiple,
}

<span class="doccomment">/// Represents the possible results of an attempted parse.
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">enum </span>ParseResult&lt;T&gt; {
    <span class="doccomment">/// Parsed successfully.
    </span>Success(T),
    <span class="doccomment">/// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected
    /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.
    </span>Failure(<a href="../../../rustc_ast/token/struct.Token.html">Token</a>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span><a href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>),
    <span class="doccomment">/// Fatal error (malformed macro?). Abort compilation.
    </span>Error(<a href="../../../rustc_span/span_encoding/struct.Span.html">rustc_span::Span</a>, <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html">String</a>),
    ErrorReported,
}

<span class="doccomment">/// A `ParseResult` where the `Success` variant contains a mapping of
/// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping
/// of metavars to the token trees they bind to.
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">type </span>NamedParseResult = ParseResult&lt;FxHashMap&lt;<a href="../../../rustc_span/symbol/struct.MacroRulesNormalizedIdent.html">MacroRulesNormalizedIdent</a>, <a href="#343">NamedMatch</a>&gt;&gt;;

<span class="doccomment">/// Count how many metavars declarations are in `matcher`.
</span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>count_metavar_decls(matcher: <span class="kw-2">&amp;</span>[<a href="../mbe.rs.html#67">TokenTree</a>]) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> {
    <a href="#282">matcher</a>
        .iter()
        .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|tt| <span class="kw">match </span><a href="#285">tt</a> {
            <a href="../mbe.rs.html#76">TokenTree::MetaVarDecl</a>(..) =&gt; <span class="number">1</span>,
            <a href="../mbe.rs.html#72">TokenTree::Sequence</a>(<span class="kw">_</span>, seq) =&gt; <a href="#287">seq</a>.num_captures,
            <a href="../mbe.rs.html#70">TokenTree::Delimited</a>(<span class="kw">_</span>, delim) =&gt; <a href="#282">count_metavar_decls</a>(<span class="kw-2">&amp;</span><a href="#288">delim</a>.tts),
            <a href="../mbe.rs.html#68">TokenTree::Token</a>(..) =&gt; <span class="number">0</span>,
            <a href="../mbe.rs.html#74">TokenTree::MetaVar</a>(..) | <a href="../mbe.rs.html#78">TokenTree::MetaVarExpr</a>(..) =&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.unreachable.html">unreachable!</a>(),
        })
        .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">sum</a>()
}

<span class="doccomment">/// `NamedMatch` is a pattern-match result for a single metavar. All
/// `MatchedNonterminal`s in the `NamedMatch` have the same non-terminal type
/// (expr, item, etc).
///
/// The in-memory structure of a particular `NamedMatch` represents the match
/// that occurred when a particular subset of a matcher was applied to a
/// particular token tree.
///
/// The width of each `MatchedSeq` in the `NamedMatch`, and the identity of
/// the `MatchedNtNonTts`s, will depend on the token tree it was applied
/// to: each `MatchedSeq` corresponds to a single repetition in the originating
/// token tree. The depth of the `NamedMatch` structure will therefore depend
/// only on the nesting depth of repetitions in the originating token tree it
/// was derived from.
///
/// In layperson&#39;s terms: `NamedMatch` will form a tree representing nested matches of a particular
/// meta variable. For example, if we are matching the following macro against the following
/// invocation...
///
/// ```rust
/// macro_rules! foo {
///   ($($($x:ident),+);+) =&gt; {}
/// }
///
/// foo!(a, b, c, d; a, b, c, d, e);
/// ```
///
/// Then, the tree will have the following shape:
///
/// ```ignore (private-internal)
/// # use NamedMatch::*;
/// MatchedSeq([
///   MatchedSeq([
///     MatchedNonterminal(a),
///     MatchedNonterminal(b),
///     MatchedNonterminal(c),
///     MatchedNonterminal(d),
///   ]),
///   MatchedSeq([
///     MatchedNonterminal(a),
///     MatchedNonterminal(b),
///     MatchedNonterminal(c),
///     MatchedNonterminal(d),
///     MatchedNonterminal(e),
///   ])
/// ])
/// ```
</span><span class="attribute">#[derive(Debug, Clone)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">enum </span>NamedMatch {
    MatchedSeq(Vec&lt;<a href="#343">NamedMatch</a>&gt;),

    <span class="comment">// A metavar match of type `tt`.
    </span>MatchedTokenTree(<a href="../../../rustc_ast/tokenstream/enum.TokenTree.html">rustc_ast::tokenstream::TokenTree</a>),

    <span class="comment">// A metavar match of any type other than `tt`.
    </span>MatchedNonterminal(Lrc&lt;<a href="../../../rustc_ast/token/enum.Nonterminal.html">Nonterminal</a>&gt;),
}

<span class="doccomment">/// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)
</span><span class="kw">fn </span>token_name_eq(t1: <span class="kw-2">&amp;</span><a href="../../../rustc_ast/token/struct.Token.html">Token</a>, t2: <span class="kw-2">&amp;</span><a href="../../../rustc_ast/token/struct.Token.html">Token</a>) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
    <span class="kw">if let </span>(<span class="prelude-val">Some</span>((ident1, is_raw1)), <span class="prelude-val">Some</span>((ident2, is_raw2))) = (<a href="#354">t1</a>.ident(), <a href="#354">t2</a>.ident()) {
        <a href="#355">ident1</a>.name == <a href="#355">ident2</a>.name &amp;&amp; <a href="#355">is_raw1</a> == <a href="#355">is_raw2</a>
    } <span class="kw">else if let </span>(<span class="prelude-val">Some</span>(ident1), <span class="prelude-val">Some</span>(ident2)) = (<a href="#354">t1</a>.lifetime(), <a href="#354">t2</a>.lifetime()) {
        <a href="#357">ident1</a>.name == <a href="#357">ident2</a>.name
    } <span class="kw">else </span>{
        <a href="#354">t1</a>.kind == <a href="#354">t2</a>.kind
    }
}

<span class="comment">// Note: the vectors could be created and dropped within `parse_tt`, but to avoid excess
// allocations we have a single vector for each kind that is cleared and reused repeatedly.
</span><span class="kw">pub struct </span>TtParser {
    macro_name: <a href="../../../rustc_span/symbol/struct.Ident.html">Ident</a>,

    <span class="doccomment">/// The set of current mps to be processed. This should be empty by the end of a successful
    /// execution of `parse_tt_inner`.
    </span>cur_mps: Vec&lt;<a href="#208">MatcherPos</a>&gt;,

    <span class="doccomment">/// The set of newly generated mps. These are used to replenish `cur_mps` in the function
    /// `parse_tt`.
    </span>next_mps: Vec&lt;<a href="#208">MatcherPos</a>&gt;,

    <span class="doccomment">/// The set of mps that are waiting for the black-box parser.
    </span>bb_mps: Vec&lt;<a href="#208">MatcherPos</a>&gt;,

    <span class="doccomment">/// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules
    /// that have no metavars.
    </span>empty_matches: Lrc&lt;Vec&lt;<a href="#343">NamedMatch</a>&gt;&gt;,
}

<span class="kw">impl </span><a href="#366">TtParser</a> {
    <span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>new(macro_name: <a href="../../../rustc_span/symbol/struct.Ident.html">Ident</a>) -&gt; <a href="#366">TtParser</a> {
        <a href="#366">TtParser</a> {
            <a href="#386">macro_name</a>,
            cur_mps: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[],
            next_mps: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[],
            bb_mps: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[],
            empty_matches: Lrc::new(<a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[]),
        }
    }

    <span class="doccomment">/// Process the matcher positions of `cur_mps` until it is empty. In the process, this will
    /// produce more mps in `next_mps` and `bb_mps`.
    ///
    /// # Returns
    ///
    /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept
    /// track of through the mps generated.
    </span><span class="kw">fn </span>parse_tt_inner(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        matcher: <span class="kw-2">&amp;</span>[<a href="#99">MatcherLoc</a>],
        token: <span class="kw-2">&amp;</span><a href="../../../rustc_ast/token/struct.Token.html">Token</a>,
    ) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="#279">NamedParseResult</a>&gt; {
        <span class="comment">// Matcher positions that would be valid if the macro invocation was over now. Only
        // modified if `token == Eof`.
        </span><span class="kw">let </span><span class="kw-2">mut </span>eof_mps = <a href="#259">EofMatcherPositions::None</a>;

        <span class="kw">while let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>mp) = <span class="self">self</span>.cur_mps.pop() {
            <span class="kw">match </span><span class="kw-2">&amp;</span>matcher[mp.idx] {
                MatcherLoc::Token { token: t } =&gt; {
                    <span class="comment">// If it&#39;s a doc comment, we just ignore it and move on to the next tt in the
                    // matcher. This is a bug, but #95267 showed that existing programs rely on
                    // this behaviour, and changing it would require some care and a transition
                    // period.
                    //
                    // If the token matches, we can just advance the parser.
                    //
                    // Otherwise, this match has failed, there is nothing to do, and hopefully
                    // another mp in `cur_mps` will match.
                    </span><span class="kw">if </span><span class="macro">matches!</span>(t, Token { kind: DocComment(..), .. }) {
                        mp.idx += <span class="number">1</span>;
                        <span class="self">self</span>.cur_mps.push(mp);
                    } <span class="kw">else if </span>token_name_eq(<span class="kw-2">&amp;</span>t, token) {
                        mp.idx += <span class="number">1</span>;
                        <span class="self">self</span>.next_mps.push(mp);
                    }
                }
                MatcherLoc::Delimited =&gt; {
                    <span class="comment">// Entering the delimiter is trivial.
                    </span>mp.idx += <span class="number">1</span>;
                    <span class="self">self</span>.cur_mps.push(mp);
                }
                <span class="kw-2">&amp;</span>MatcherLoc::Sequence {
                    op,
                    num_metavar_decls,
                    idx_first_after,
                    next_metavar,
                    seq_depth,
                } =&gt; {
                    <span class="comment">// Install an empty vec for each metavar within the sequence.
                    </span><span class="kw">for </span>metavar_idx <span class="kw">in </span>next_metavar..next_metavar + num_metavar_decls {
                        mp.push_match(metavar_idx, seq_depth, MatchedSeq(<span class="macro">vec!</span>[]));
                    }

                    <span class="kw">if </span>op == KleeneOp::ZeroOrMore || op == KleeneOp::ZeroOrOne {
                        <span class="comment">// Try zero matches of this sequence, by skipping over it.
                        </span><span class="self">self</span>.cur_mps.push(MatcherPos {
                            idx: idx_first_after,
                            matches: mp.matches.clone(), <span class="comment">// a cheap clone
                        </span>});
                    }

                    <span class="comment">// Try one or more matches of this sequence, by entering it.
                    </span>mp.idx += <span class="number">1</span>;
                    <span class="self">self</span>.cur_mps.push(mp);
                }
                <span class="kw-2">&amp;</span>MatcherLoc::SequenceKleeneOpNoSep { op, idx_first } =&gt; {
                    <span class="comment">// We are past the end of a sequence with no separator. Try ending the
                    // sequence. If that&#39;s not possible, `ending_mp` will fail quietly when it is
                    // processed next time around the loop.
                    </span><span class="kw">let </span>ending_mp = MatcherPos {
                        idx: mp.idx + <span class="number">1</span>,             <span class="comment">// +1 skips the Kleene op
                        </span>matches: mp.matches.clone(), <span class="comment">// a cheap clone
                    </span>};
                    <span class="self">self</span>.cur_mps.push(ending_mp);

                    <span class="kw">if </span>op != KleeneOp::ZeroOrOne {
                        <span class="comment">// Try another repetition.
                        </span>mp.idx = idx_first;
                        <span class="self">self</span>.cur_mps.push(mp);
                    }
                }
                MatcherLoc::SequenceSep { separator } =&gt; {
                    <span class="comment">// We are past the end of a sequence with a separator but we haven&#39;t seen the
                    // separator yet. Try ending the sequence. If that&#39;s not possible, `ending_mp`
                    // will fail quietly when it is processed next time around the loop.
                    </span><span class="kw">let </span>ending_mp = MatcherPos {
                        idx: mp.idx + <span class="number">2</span>,             <span class="comment">// +2 skips the separator and the Kleene op
                        </span>matches: mp.matches.clone(), <span class="comment">// a cheap clone
                    </span>};
                    <span class="self">self</span>.cur_mps.push(ending_mp);

                    <span class="kw">if </span>token_name_eq(token, separator) {
                        <span class="comment">// The separator matches the current token. Advance past it.
                        </span>mp.idx += <span class="number">1</span>;
                        <span class="self">self</span>.next_mps.push(mp);
                    }
                }
                <span class="kw-2">&amp;</span>MatcherLoc::SequenceKleeneOpAfterSep { idx_first } =&gt; {
                    <span class="comment">// We are past the sequence separator. This can&#39;t be a `?` Kleene op, because
                    // they don&#39;t permit separators. Try another repetition.
                    </span>mp.idx = idx_first;
                    <span class="self">self</span>.cur_mps.push(mp);
                }
                <span class="kw-2">&amp;</span>MatcherLoc::MetaVarDecl { span, kind, .. } =&gt; {
                    <span class="comment">// Built-in nonterminals never start with these tokens, so we can eliminate
                    // them from consideration. We use the span of the metavariable declaration
                    // to determine any edition-specific matching behavior for non-terminals.
                    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(kind) = kind {
                        <span class="kw">if </span>Parser::nonterminal_may_begin_with(kind, token) {
                            <span class="self">self</span>.bb_mps.push(mp);
                        }
                    } <span class="kw">else </span>{
                        <span class="comment">// E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.
                        // Both this check and the one in `nameize` are necessary, surprisingly.
                        </span><span class="kw">return </span><span class="prelude-val">Some</span>(Error(span, <span class="string">&quot;missing fragment specifier&quot;</span>.to_string()));
                    }
                }
                MatcherLoc::Eof =&gt; {
                    <span class="comment">// We are past the matcher&#39;s end, and not in a sequence. Try to end things.
                    </span><span class="macro">debug_assert_eq!</span>(mp.idx, matcher.len() - <span class="number">1</span>);
                    <span class="kw">if </span><span class="kw-2">*</span>token == token::Eof {
                        eof_mps = <span class="kw">match </span>eof_mps {
                            EofMatcherPositions::None =&gt; EofMatcherPositions::One(mp),
                            EofMatcherPositions::One(<span class="kw">_</span>) | EofMatcherPositions::Multiple =&gt; {
                                EofMatcherPositions::Multiple
                            }
                        }
                    }
                }
            }
        }

        <span class="comment">// If we reached the end of input, check that there is EXACTLY ONE possible matcher.
        // Otherwise, either the parse is ambiguous (which is an error) or there is a syntax error.
        </span><span class="kw">if </span><span class="kw-2">*</span>token == token::Eof {
            <span class="prelude-val">Some</span>(<span class="kw">match </span><a href="#410">eof_mps</a> {
                <a href="#260">EofMatcherPositions::One</a>(<span class="kw-2">mut </span>eof_mp) =&gt; {
                    <span class="comment">// Need to take ownership of the matches from within the `Lrc`.
                    </span>Lrc::make_mut(<span class="kw-2">&amp;mut </span><a href="#532">eof_mp</a>.matches);
                    <span class="kw">let </span>matches = Lrc::try_unwrap(<a href="#532">eof_mp</a>.matches).unwrap().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html">into_iter</a>();
                    <a class="self" href="#404">self</a>.<a href="#678-682">nameize</a>(<a href="#405">matcher</a>, <a href="#535">matches</a>)
                }
                <a href="#261">EofMatcherPositions::Multiple</a> =&gt; {
                    <a href="#272">Error</a>(<a href="#406">token</a>.span, <span class="string">&quot;ambiguity: multiple successful parses&quot;</span>.<a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html">to_string</a>())
                }
                <a href="#259">EofMatcherPositions::None</a> =&gt; <a href="#270">Failure</a>(
                    Token::new(
                        token::Eof,
                        <span class="kw">if </span>token.span.is_dummy() { <a href="#406">token</a>.span } <span class="kw">else </span>{ <a href="#406">token</a>.span.shrink_to_hi() },
                    ),
                    <span class="string">&quot;missing tokens in macro arguments&quot;</span>,
                ),
            })
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }

    <span class="doccomment">/// Match the token stream from `parser` against `matcher`.
    </span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>parse_tt(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        parser: <span class="kw-2">&amp;mut </span>Cow&lt;<span class="lifetime">&#39;_</span>, Parser&lt;<span class="lifetime">&#39;_</span>&gt;&gt;,
        matcher: <span class="kw-2">&amp;</span>[<a href="#99">MatcherLoc</a>],
    ) -&gt; <a href="#279">NamedParseResult</a> {
        <span class="comment">// A queue of possible matcher positions. We initialize it with the matcher position in
        // which the &quot;dot&quot; is before the first token of the first token tree in `matcher`.
        // `parse_tt_inner` then processes all of these possible matcher positions and produces
        // possible next positions into `next_mps`. After some post-processing, the contents of
        // `next_mps` replenish `cur_mps` and we start over again.
        </span><a class="self" href="#556">self</a>.cur_mps.clear();
        <a class="self" href="#556">self</a>.cur_mps.push(<a href="#208">MatcherPos</a> { idx: <span class="number">0</span>, matches: <a class="self" href="#556">self</a>.empty_matches.<a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">clone</a>() });

        <span class="kw">loop </span>{
            <a class="self" href="#556">self</a>.next_mps.clear();
            <a class="self" href="#556">self</a>.bb_mps.clear();

            <span class="comment">// Process `cur_mps` until either we have finished the input or we need to get some
            // parsing from the black-box parser done.
            </span><span class="kw">if let </span><span class="prelude-val">Some</span>(res) = <a class="self" href="#556">self</a>.<a href="#403-407">parse_tt_inner</a>(<a href="#558">matcher</a>, <span class="kw-2">&amp;</span><a href="#557">parser</a>.token) {
                <span class="kw">return </span><a href="#574">res</a>;
            }

            <span class="comment">// `parse_tt_inner` handled all of `cur_mps`, so it&#39;s empty.
            </span><a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(<span class="self">self</span>.cur_mps.is_empty());

            <span class="comment">// Error messages here could be improved with links to original rules.
            </span><span class="kw">match </span>(<a class="self" href="#556">self</a>.next_mps.len(), <a class="self" href="#556">self</a>.bb_mps.len()) {
                (<span class="number">0</span>, <span class="number">0</span>) =&gt; {
                    <span class="comment">// There are no possible next positions AND we aren&#39;t waiting for the black-box
                    // parser: syntax error.
                    </span><span class="kw">return </span><a href="#270">Failure</a>(
                        <a href="#557">parser</a>.token.<a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">clone</a>(),
                        <span class="string">&quot;no rules expected this token in macro call&quot;</span>,
                    );
                }

                (<span class="kw">_</span>, <span class="number">0</span>) =&gt; {
                    <span class="comment">// Dump all possible `next_mps` into `cur_mps` for the next iteration. Then
                    // process the next token.
                    </span><a class="self" href="#556">self</a>.cur_mps.append(<span class="kw-2">&amp;mut </span><a class="self" href="#556">self</a>.next_mps);
                    <a href="#557">parser</a>.to_mut().bump();
                }

                (<span class="number">0</span>, <span class="number">1</span>) =&gt; {
                    <span class="comment">// We need to call the black-box parser to get some nonterminal.
                    </span><span class="kw">let </span><span class="kw-2">mut </span>mp = <a class="self" href="#556">self</a>.bb_mps.pop().unwrap();
                    <span class="kw">let </span>loc = <span class="kw-2">&amp;</span><a href="#558">matcher</a>[<a href="#601">mp</a>.idx];
                    <span class="kw">if let </span><span class="kw-2">&amp;</span><a href="#121">MatcherLoc::MetaVarDecl</a> {
                        span,
                        kind: <span class="prelude-val">Some</span>(kind),
                        next_metavar,
                        seq_depth,
                        ..
                    } = <a href="#602">loc</a>
                    {
                        <span class="comment">// We use the span of the metavariable declaration to determine any
                        // edition-specific matching behavior for non-terminals.
                        </span><span class="kw">let </span>nt = <span class="kw">match </span><a href="#557">parser</a>.to_mut().parse_nonterminal(<a href="#605">kind</a>) {
                            <span class="prelude-val">Err</span>(<span class="kw-2">mut </span>err) =&gt; {
                                <a href="#614">err</a>.span_label(
                                    <a href="#604">span</a>,
                                    <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(
                                        <span class="string">&quot;while parsing argument for this `{kind}` macro fragment&quot;
                                    </span>),
                                )
                                .emit();
                                <span class="kw">return </span><a href="#273">ErrorReported</a>;
                            }
                            <span class="prelude-val">Ok</span>(nt) =&gt; <a href="#624">nt</a>,
                        };
                        <span class="kw">let </span>m = <span class="kw">match </span><a href="#613">nt</a> {
                            NtOrTt::Nt(nt) =&gt; <a href="#350">MatchedNonterminal</a>(Lrc::new(<a href="#627">nt</a>)),
                            NtOrTt::Tt(tt) =&gt; <a href="#347">MatchedTokenTree</a>(<a href="#628">tt</a>),
                        };
                        <a href="#601">mp</a>.<a href="#231">push_match</a>(<a href="#606">next_metavar</a>, <a href="#607">seq_depth</a>, <a href="#626">m</a>);
                        <a href="#601">mp</a>.idx += <span class="number">1</span>;
                    } <span class="kw">else </span>{
                        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.unreachable.html">unreachable!</a>()
                    }
                    <a class="self" href="#556">self</a>.cur_mps.push(<a href="#601">mp</a>);
                }

                (<span class="kw">_</span>, <span class="kw">_</span>) =&gt; {
                    <span class="comment">// Too many possibilities!
                    </span><span class="kw">return </span><a class="self" href="#556">self</a>.<a href="#648-652">ambiguity_error</a>(<a href="#558">matcher</a>, <a href="#557">parser</a>.token.span);
                }
            }

            <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(!<span class="self">self</span>.cur_mps.is_empty());
        }
    }

    <span class="kw">fn </span>ambiguity_error(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        matcher: <span class="kw-2">&amp;</span>[<a href="#99">MatcherLoc</a>],
        token_span: <a href="../../../rustc_span/span_encoding/struct.Span.html">rustc_span::Span</a>,
    ) -&gt; <a href="#279">NamedParseResult</a> {
        <span class="kw">let </span>nts = <span class="self"><a href="#649">self</a>
            </span>.bb_mps
            .iter()
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|mp| <span class="kw">match </span><span class="kw-2">&amp;</span><a href="#650">matcher</a>[<a href="#656">mp</a>.idx] {
                <a href="#121">MatcherLoc::MetaVarDecl</a> { bind, kind: <span class="prelude-val">Some</span>(kind), .. } =&gt; {
                    <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(<span class="string">&quot;{} (&#39;{}&#39;)&quot;</span>, kind, bind)
                }
                <span class="kw">_ </span>=&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.unreachable.html">unreachable!</a>(),
            })
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>::&lt;Vec&lt;<a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html">String</a>&gt;&gt;()
            .join(<span class="string">&quot; or &quot;</span>);

        <a href="#272">Error</a>(
            <a href="#651">token_span</a>,
            <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(
                <span class="string">&quot;local ambiguity when calling macro `{}`: multiple parsing options: {}&quot;</span>,
                <span class="self">self</span>.macro_name,
                <span class="kw">match </span><span class="self">self</span>.next_mps.len() {
                    <span class="number">0 </span>=&gt; <span class="macro">format!</span>(<span class="string">&quot;built-in NTs {}.&quot;</span>, nts),
                    n =&gt; <span class="macro">format!</span>(<span class="string">&quot;built-in NTs {} or {n} other option{s}.&quot;</span>, nts, s = <span class="macro">pluralize!</span>(n)),
                }
            ),
        )
    }

    <span class="kw">fn </span>nameize&lt;I: Iterator&lt;Item = <a href="#343">NamedMatch</a>&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        matcher: <span class="kw-2">&amp;</span>[<a href="#99">MatcherLoc</a>],
        <span class="kw-2">mut </span>res: I,
    ) -&gt; <a href="#279">NamedParseResult</a> {
        <span class="comment">// Make that each metavar has _exactly one_ binding. If so, insert the binding into the
        // `NamedParseResult`. Otherwise, it&#39;s an error.
        </span><span class="kw">let </span><span class="kw-2">mut </span>ret_val = FxHashMap::default();
        <span class="kw">for </span>loc <span class="kw">in </span>matcher {
            <span class="kw">if let </span><span class="kw-2">&amp;</span>MatcherLoc::MetaVarDecl { span, bind, kind, .. } = loc {
                <span class="kw">if </span>kind.is_some() {
                    <span class="kw">match </span>ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {
                        Vacant(spot) =&gt; spot.insert(res.next().unwrap()),
                        Occupied(..) =&gt; {
                            <span class="kw">return </span>Error(span, <span class="macro">format!</span>(<span class="string">&quot;duplicated bind name: {}&quot;</span>, bind));
                        }
                    };
                } <span class="kw">else </span>{
                    <span class="comment">// E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.
                    // Both this check and the one in `parse_tt_inner` are necessary, surprisingly.
                    </span><span class="kw">return </span>Error(span, <span class="string">&quot;missing fragment specifier&quot;</span>.to_string());
                }
            }
        }
        <a href="#267">Success</a>(<a href="#685">ret_val</a>)
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rustc_expand" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0-dev" ></div></body></html>