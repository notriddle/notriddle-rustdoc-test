<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `compiler/rustc_middle/src/ty/layout.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>layout.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rustc_middle/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../rustc_middle/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rustc_middle/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
<span id="1913">1913</span>
<span id="1914">1914</span>
<span id="1915">1915</span>
<span id="1916">1916</span>
<span id="1917">1917</span>
<span id="1918">1918</span>
<span id="1919">1919</span>
<span id="1920">1920</span>
<span id="1921">1921</span>
<span id="1922">1922</span>
<span id="1923">1923</span>
<span id="1924">1924</span>
<span id="1925">1925</span>
<span id="1926">1926</span>
<span id="1927">1927</span>
<span id="1928">1928</span>
<span id="1929">1929</span>
<span id="1930">1930</span>
<span id="1931">1931</span>
<span id="1932">1932</span>
<span id="1933">1933</span>
<span id="1934">1934</span>
<span id="1935">1935</span>
<span id="1936">1936</span>
<span id="1937">1937</span>
<span id="1938">1938</span>
<span id="1939">1939</span>
<span id="1940">1940</span>
<span id="1941">1941</span>
<span id="1942">1942</span>
<span id="1943">1943</span>
<span id="1944">1944</span>
<span id="1945">1945</span>
<span id="1946">1946</span>
<span id="1947">1947</span>
<span id="1948">1948</span>
<span id="1949">1949</span>
<span id="1950">1950</span>
<span id="1951">1951</span>
<span id="1952">1952</span>
<span id="1953">1953</span>
<span id="1954">1954</span>
<span id="1955">1955</span>
<span id="1956">1956</span>
<span id="1957">1957</span>
<span id="1958">1958</span>
<span id="1959">1959</span>
<span id="1960">1960</span>
<span id="1961">1961</span>
<span id="1962">1962</span>
<span id="1963">1963</span>
<span id="1964">1964</span>
<span id="1965">1965</span>
<span id="1966">1966</span>
<span id="1967">1967</span>
<span id="1968">1968</span>
<span id="1969">1969</span>
<span id="1970">1970</span>
<span id="1971">1971</span>
<span id="1972">1972</span>
<span id="1973">1973</span>
<span id="1974">1974</span>
<span id="1975">1975</span>
<span id="1976">1976</span>
<span id="1977">1977</span>
<span id="1978">1978</span>
<span id="1979">1979</span>
<span id="1980">1980</span>
<span id="1981">1981</span>
<span id="1982">1982</span>
<span id="1983">1983</span>
<span id="1984">1984</span>
<span id="1985">1985</span>
<span id="1986">1986</span>
<span id="1987">1987</span>
<span id="1988">1988</span>
<span id="1989">1989</span>
<span id="1990">1990</span>
<span id="1991">1991</span>
<span id="1992">1992</span>
<span id="1993">1993</span>
<span id="1994">1994</span>
<span id="1995">1995</span>
<span id="1996">1996</span>
<span id="1997">1997</span>
<span id="1998">1998</span>
<span id="1999">1999</span>
<span id="2000">2000</span>
<span id="2001">2001</span>
<span id="2002">2002</span>
<span id="2003">2003</span>
<span id="2004">2004</span>
<span id="2005">2005</span>
<span id="2006">2006</span>
<span id="2007">2007</span>
<span id="2008">2008</span>
<span id="2009">2009</span>
<span id="2010">2010</span>
<span id="2011">2011</span>
<span id="2012">2012</span>
<span id="2013">2013</span>
<span id="2014">2014</span>
<span id="2015">2015</span>
<span id="2016">2016</span>
<span id="2017">2017</span>
<span id="2018">2018</span>
<span id="2019">2019</span>
<span id="2020">2020</span>
<span id="2021">2021</span>
<span id="2022">2022</span>
<span id="2023">2023</span>
<span id="2024">2024</span>
<span id="2025">2025</span>
<span id="2026">2026</span>
<span id="2027">2027</span>
<span id="2028">2028</span>
<span id="2029">2029</span>
<span id="2030">2030</span>
<span id="2031">2031</span>
<span id="2032">2032</span>
<span id="2033">2033</span>
<span id="2034">2034</span>
<span id="2035">2035</span>
<span id="2036">2036</span>
<span id="2037">2037</span>
<span id="2038">2038</span>
<span id="2039">2039</span>
<span id="2040">2040</span>
<span id="2041">2041</span>
<span id="2042">2042</span>
<span id="2043">2043</span>
<span id="2044">2044</span>
<span id="2045">2045</span>
<span id="2046">2046</span>
<span id="2047">2047</span>
<span id="2048">2048</span>
<span id="2049">2049</span>
<span id="2050">2050</span>
<span id="2051">2051</span>
<span id="2052">2052</span>
<span id="2053">2053</span>
<span id="2054">2054</span>
<span id="2055">2055</span>
<span id="2056">2056</span>
<span id="2057">2057</span>
<span id="2058">2058</span>
<span id="2059">2059</span>
<span id="2060">2060</span>
<span id="2061">2061</span>
<span id="2062">2062</span>
<span id="2063">2063</span>
<span id="2064">2064</span>
<span id="2065">2065</span>
<span id="2066">2066</span>
<span id="2067">2067</span>
<span id="2068">2068</span>
<span id="2069">2069</span>
<span id="2070">2070</span>
<span id="2071">2071</span>
<span id="2072">2072</span>
<span id="2073">2073</span>
<span id="2074">2074</span>
<span id="2075">2075</span>
<span id="2076">2076</span>
<span id="2077">2077</span>
<span id="2078">2078</span>
<span id="2079">2079</span>
<span id="2080">2080</span>
<span id="2081">2081</span>
<span id="2082">2082</span>
<span id="2083">2083</span>
<span id="2084">2084</span>
<span id="2085">2085</span>
<span id="2086">2086</span>
<span id="2087">2087</span>
<span id="2088">2088</span>
<span id="2089">2089</span>
<span id="2090">2090</span>
<span id="2091">2091</span>
<span id="2092">2092</span>
<span id="2093">2093</span>
<span id="2094">2094</span>
<span id="2095">2095</span>
<span id="2096">2096</span>
<span id="2097">2097</span>
<span id="2098">2098</span>
<span id="2099">2099</span>
<span id="2100">2100</span>
<span id="2101">2101</span>
<span id="2102">2102</span>
<span id="2103">2103</span>
<span id="2104">2104</span>
<span id="2105">2105</span>
<span id="2106">2106</span>
<span id="2107">2107</span>
<span id="2108">2108</span>
<span id="2109">2109</span>
<span id="2110">2110</span>
<span id="2111">2111</span>
<span id="2112">2112</span>
<span id="2113">2113</span>
<span id="2114">2114</span>
<span id="2115">2115</span>
<span id="2116">2116</span>
<span id="2117">2117</span>
<span id="2118">2118</span>
<span id="2119">2119</span>
<span id="2120">2120</span>
<span id="2121">2121</span>
<span id="2122">2122</span>
<span id="2123">2123</span>
<span id="2124">2124</span>
<span id="2125">2125</span>
<span id="2126">2126</span>
<span id="2127">2127</span>
<span id="2128">2128</span>
<span id="2129">2129</span>
<span id="2130">2130</span>
<span id="2131">2131</span>
<span id="2132">2132</span>
<span id="2133">2133</span>
<span id="2134">2134</span>
<span id="2135">2135</span>
<span id="2136">2136</span>
<span id="2137">2137</span>
<span id="2138">2138</span>
<span id="2139">2139</span>
<span id="2140">2140</span>
<span id="2141">2141</span>
<span id="2142">2142</span>
<span id="2143">2143</span>
<span id="2144">2144</span>
<span id="2145">2145</span>
<span id="2146">2146</span>
<span id="2147">2147</span>
<span id="2148">2148</span>
<span id="2149">2149</span>
<span id="2150">2150</span>
<span id="2151">2151</span>
<span id="2152">2152</span>
<span id="2153">2153</span>
<span id="2154">2154</span>
<span id="2155">2155</span>
<span id="2156">2156</span>
<span id="2157">2157</span>
<span id="2158">2158</span>
<span id="2159">2159</span>
<span id="2160">2160</span>
<span id="2161">2161</span>
<span id="2162">2162</span>
<span id="2163">2163</span>
<span id="2164">2164</span>
<span id="2165">2165</span>
<span id="2166">2166</span>
<span id="2167">2167</span>
<span id="2168">2168</span>
<span id="2169">2169</span>
<span id="2170">2170</span>
<span id="2171">2171</span>
<span id="2172">2172</span>
<span id="2173">2173</span>
<span id="2174">2174</span>
<span id="2175">2175</span>
<span id="2176">2176</span>
<span id="2177">2177</span>
<span id="2178">2178</span>
<span id="2179">2179</span>
<span id="2180">2180</span>
<span id="2181">2181</span>
<span id="2182">2182</span>
<span id="2183">2183</span>
<span id="2184">2184</span>
<span id="2185">2185</span>
<span id="2186">2186</span>
<span id="2187">2187</span>
<span id="2188">2188</span>
<span id="2189">2189</span>
<span id="2190">2190</span>
<span id="2191">2191</span>
<span id="2192">2192</span>
<span id="2193">2193</span>
<span id="2194">2194</span>
<span id="2195">2195</span>
<span id="2196">2196</span>
<span id="2197">2197</span>
<span id="2198">2198</span>
<span id="2199">2199</span>
<span id="2200">2200</span>
<span id="2201">2201</span>
<span id="2202">2202</span>
<span id="2203">2203</span>
<span id="2204">2204</span>
<span id="2205">2205</span>
<span id="2206">2206</span>
<span id="2207">2207</span>
<span id="2208">2208</span>
<span id="2209">2209</span>
<span id="2210">2210</span>
<span id="2211">2211</span>
<span id="2212">2212</span>
<span id="2213">2213</span>
<span id="2214">2214</span>
<span id="2215">2215</span>
<span id="2216">2216</span>
<span id="2217">2217</span>
<span id="2218">2218</span>
<span id="2219">2219</span>
<span id="2220">2220</span>
<span id="2221">2221</span>
<span id="2222">2222</span>
<span id="2223">2223</span>
<span id="2224">2224</span>
<span id="2225">2225</span>
<span id="2226">2226</span>
<span id="2227">2227</span>
<span id="2228">2228</span>
<span id="2229">2229</span>
<span id="2230">2230</span>
<span id="2231">2231</span>
<span id="2232">2232</span>
<span id="2233">2233</span>
<span id="2234">2234</span>
<span id="2235">2235</span>
<span id="2236">2236</span>
<span id="2237">2237</span>
<span id="2238">2238</span>
<span id="2239">2239</span>
<span id="2240">2240</span>
<span id="2241">2241</span>
<span id="2242">2242</span>
<span id="2243">2243</span>
<span id="2244">2244</span>
<span id="2245">2245</span>
<span id="2246">2246</span>
<span id="2247">2247</span>
<span id="2248">2248</span>
<span id="2249">2249</span>
<span id="2250">2250</span>
<span id="2251">2251</span>
<span id="2252">2252</span>
<span id="2253">2253</span>
<span id="2254">2254</span>
<span id="2255">2255</span>
<span id="2256">2256</span>
<span id="2257">2257</span>
<span id="2258">2258</span>
<span id="2259">2259</span>
<span id="2260">2260</span>
<span id="2261">2261</span>
<span id="2262">2262</span>
<span id="2263">2263</span>
<span id="2264">2264</span>
<span id="2265">2265</span>
<span id="2266">2266</span>
<span id="2267">2267</span>
<span id="2268">2268</span>
<span id="2269">2269</span>
<span id="2270">2270</span>
<span id="2271">2271</span>
<span id="2272">2272</span>
<span id="2273">2273</span>
<span id="2274">2274</span>
<span id="2275">2275</span>
<span id="2276">2276</span>
<span id="2277">2277</span>
<span id="2278">2278</span>
<span id="2279">2279</span>
<span id="2280">2280</span>
<span id="2281">2281</span>
<span id="2282">2282</span>
<span id="2283">2283</span>
<span id="2284">2284</span>
<span id="2285">2285</span>
<span id="2286">2286</span>
<span id="2287">2287</span>
<span id="2288">2288</span>
<span id="2289">2289</span>
<span id="2290">2290</span>
<span id="2291">2291</span>
<span id="2292">2292</span>
<span id="2293">2293</span>
<span id="2294">2294</span>
<span id="2295">2295</span>
<span id="2296">2296</span>
<span id="2297">2297</span>
<span id="2298">2298</span>
<span id="2299">2299</span>
<span id="2300">2300</span>
<span id="2301">2301</span>
<span id="2302">2302</span>
<span id="2303">2303</span>
<span id="2304">2304</span>
<span id="2305">2305</span>
<span id="2306">2306</span>
<span id="2307">2307</span>
<span id="2308">2308</span>
<span id="2309">2309</span>
<span id="2310">2310</span>
<span id="2311">2311</span>
<span id="2312">2312</span>
<span id="2313">2313</span>
<span id="2314">2314</span>
<span id="2315">2315</span>
<span id="2316">2316</span>
<span id="2317">2317</span>
<span id="2318">2318</span>
<span id="2319">2319</span>
<span id="2320">2320</span>
<span id="2321">2321</span>
<span id="2322">2322</span>
<span id="2323">2323</span>
<span id="2324">2324</span>
<span id="2325">2325</span>
<span id="2326">2326</span>
<span id="2327">2327</span>
<span id="2328">2328</span>
<span id="2329">2329</span>
<span id="2330">2330</span>
<span id="2331">2331</span>
<span id="2332">2332</span>
<span id="2333">2333</span>
<span id="2334">2334</span>
<span id="2335">2335</span>
<span id="2336">2336</span>
<span id="2337">2337</span>
<span id="2338">2338</span>
<span id="2339">2339</span>
<span id="2340">2340</span>
<span id="2341">2341</span>
<span id="2342">2342</span>
<span id="2343">2343</span>
<span id="2344">2344</span>
<span id="2345">2345</span>
<span id="2346">2346</span>
<span id="2347">2347</span>
<span id="2348">2348</span>
<span id="2349">2349</span>
<span id="2350">2350</span>
<span id="2351">2351</span>
<span id="2352">2352</span>
<span id="2353">2353</span>
<span id="2354">2354</span>
<span id="2355">2355</span>
<span id="2356">2356</span>
<span id="2357">2357</span>
<span id="2358">2358</span>
<span id="2359">2359</span>
<span id="2360">2360</span>
<span id="2361">2361</span>
<span id="2362">2362</span>
<span id="2363">2363</span>
<span id="2364">2364</span>
<span id="2365">2365</span>
<span id="2366">2366</span>
<span id="2367">2367</span>
<span id="2368">2368</span>
<span id="2369">2369</span>
<span id="2370">2370</span>
<span id="2371">2371</span>
<span id="2372">2372</span>
<span id="2373">2373</span>
<span id="2374">2374</span>
<span id="2375">2375</span>
<span id="2376">2376</span>
<span id="2377">2377</span>
<span id="2378">2378</span>
<span id="2379">2379</span>
<span id="2380">2380</span>
<span id="2381">2381</span>
<span id="2382">2382</span>
<span id="2383">2383</span>
<span id="2384">2384</span>
<span id="2385">2385</span>
<span id="2386">2386</span>
<span id="2387">2387</span>
<span id="2388">2388</span>
<span id="2389">2389</span>
<span id="2390">2390</span>
<span id="2391">2391</span>
<span id="2392">2392</span>
<span id="2393">2393</span>
<span id="2394">2394</span>
<span id="2395">2395</span>
<span id="2396">2396</span>
<span id="2397">2397</span>
<span id="2398">2398</span>
<span id="2399">2399</span>
<span id="2400">2400</span>
<span id="2401">2401</span>
<span id="2402">2402</span>
<span id="2403">2403</span>
<span id="2404">2404</span>
<span id="2405">2405</span>
<span id="2406">2406</span>
<span id="2407">2407</span>
<span id="2408">2408</span>
<span id="2409">2409</span>
<span id="2410">2410</span>
<span id="2411">2411</span>
<span id="2412">2412</span>
<span id="2413">2413</span>
<span id="2414">2414</span>
<span id="2415">2415</span>
<span id="2416">2416</span>
<span id="2417">2417</span>
<span id="2418">2418</span>
<span id="2419">2419</span>
<span id="2420">2420</span>
<span id="2421">2421</span>
<span id="2422">2422</span>
<span id="2423">2423</span>
<span id="2424">2424</span>
<span id="2425">2425</span>
<span id="2426">2426</span>
<span id="2427">2427</span>
<span id="2428">2428</span>
<span id="2429">2429</span>
<span id="2430">2430</span>
<span id="2431">2431</span>
<span id="2432">2432</span>
<span id="2433">2433</span>
<span id="2434">2434</span>
<span id="2435">2435</span>
<span id="2436">2436</span>
<span id="2437">2437</span>
<span id="2438">2438</span>
<span id="2439">2439</span>
<span id="2440">2440</span>
<span id="2441">2441</span>
<span id="2442">2442</span>
<span id="2443">2443</span>
<span id="2444">2444</span>
<span id="2445">2445</span>
<span id="2446">2446</span>
<span id="2447">2447</span>
<span id="2448">2448</span>
<span id="2449">2449</span>
<span id="2450">2450</span>
<span id="2451">2451</span>
<span id="2452">2452</span>
<span id="2453">2453</span>
<span id="2454">2454</span>
<span id="2455">2455</span>
<span id="2456">2456</span>
<span id="2457">2457</span>
<span id="2458">2458</span>
<span id="2459">2459</span>
<span id="2460">2460</span>
<span id="2461">2461</span>
<span id="2462">2462</span>
<span id="2463">2463</span>
<span id="2464">2464</span>
<span id="2465">2465</span>
<span id="2466">2466</span>
<span id="2467">2467</span>
<span id="2468">2468</span>
<span id="2469">2469</span>
<span id="2470">2470</span>
<span id="2471">2471</span>
<span id="2472">2472</span>
<span id="2473">2473</span>
<span id="2474">2474</span>
<span id="2475">2475</span>
<span id="2476">2476</span>
<span id="2477">2477</span>
<span id="2478">2478</span>
<span id="2479">2479</span>
<span id="2480">2480</span>
<span id="2481">2481</span>
<span id="2482">2482</span>
<span id="2483">2483</span>
<span id="2484">2484</span>
<span id="2485">2485</span>
<span id="2486">2486</span>
<span id="2487">2487</span>
<span id="2488">2488</span>
<span id="2489">2489</span>
<span id="2490">2490</span>
<span id="2491">2491</span>
<span id="2492">2492</span>
<span id="2493">2493</span>
<span id="2494">2494</span>
<span id="2495">2495</span>
<span id="2496">2496</span>
<span id="2497">2497</span>
<span id="2498">2498</span>
<span id="2499">2499</span>
<span id="2500">2500</span>
<span id="2501">2501</span>
<span id="2502">2502</span>
<span id="2503">2503</span>
<span id="2504">2504</span>
<span id="2505">2505</span>
<span id="2506">2506</span>
<span id="2507">2507</span>
<span id="2508">2508</span>
<span id="2509">2509</span>
<span id="2510">2510</span>
<span id="2511">2511</span>
<span id="2512">2512</span>
<span id="2513">2513</span>
<span id="2514">2514</span>
<span id="2515">2515</span>
<span id="2516">2516</span>
<span id="2517">2517</span>
<span id="2518">2518</span>
<span id="2519">2519</span>
<span id="2520">2520</span>
<span id="2521">2521</span>
<span id="2522">2522</span>
<span id="2523">2523</span>
<span id="2524">2524</span>
<span id="2525">2525</span>
<span id="2526">2526</span>
<span id="2527">2527</span>
<span id="2528">2528</span>
<span id="2529">2529</span>
<span id="2530">2530</span>
<span id="2531">2531</span>
<span id="2532">2532</span>
<span id="2533">2533</span>
<span id="2534">2534</span>
<span id="2535">2535</span>
<span id="2536">2536</span>
<span id="2537">2537</span>
<span id="2538">2538</span>
<span id="2539">2539</span>
<span id="2540">2540</span>
<span id="2541">2541</span>
<span id="2542">2542</span>
<span id="2543">2543</span>
<span id="2544">2544</span>
<span id="2545">2545</span>
<span id="2546">2546</span>
<span id="2547">2547</span>
<span id="2548">2548</span>
<span id="2549">2549</span>
<span id="2550">2550</span>
<span id="2551">2551</span>
<span id="2552">2552</span>
<span id="2553">2553</span>
<span id="2554">2554</span>
<span id="2555">2555</span>
<span id="2556">2556</span>
<span id="2557">2557</span>
<span id="2558">2558</span>
<span id="2559">2559</span>
<span id="2560">2560</span>
<span id="2561">2561</span>
<span id="2562">2562</span>
<span id="2563">2563</span>
<span id="2564">2564</span>
<span id="2565">2565</span>
<span id="2566">2566</span>
<span id="2567">2567</span>
<span id="2568">2568</span>
<span id="2569">2569</span>
<span id="2570">2570</span>
<span id="2571">2571</span>
<span id="2572">2572</span>
<span id="2573">2573</span>
<span id="2574">2574</span>
<span id="2575">2575</span>
<span id="2576">2576</span>
<span id="2577">2577</span>
<span id="2578">2578</span>
<span id="2579">2579</span>
<span id="2580">2580</span>
<span id="2581">2581</span>
<span id="2582">2582</span>
<span id="2583">2583</span>
<span id="2584">2584</span>
<span id="2585">2585</span>
<span id="2586">2586</span>
<span id="2587">2587</span>
<span id="2588">2588</span>
<span id="2589">2589</span>
<span id="2590">2590</span>
<span id="2591">2591</span>
<span id="2592">2592</span>
<span id="2593">2593</span>
<span id="2594">2594</span>
<span id="2595">2595</span>
<span id="2596">2596</span>
<span id="2597">2597</span>
<span id="2598">2598</span>
<span id="2599">2599</span>
<span id="2600">2600</span>
<span id="2601">2601</span>
<span id="2602">2602</span>
<span id="2603">2603</span>
<span id="2604">2604</span>
<span id="2605">2605</span>
<span id="2606">2606</span>
<span id="2607">2607</span>
<span id="2608">2608</span>
<span id="2609">2609</span>
<span id="2610">2610</span>
<span id="2611">2611</span>
<span id="2612">2612</span>
<span id="2613">2613</span>
<span id="2614">2614</span>
<span id="2615">2615</span>
<span id="2616">2616</span>
<span id="2617">2617</span>
<span id="2618">2618</span>
<span id="2619">2619</span>
<span id="2620">2620</span>
<span id="2621">2621</span>
<span id="2622">2622</span>
<span id="2623">2623</span>
<span id="2624">2624</span>
<span id="2625">2625</span>
<span id="2626">2626</span>
<span id="2627">2627</span>
<span id="2628">2628</span>
<span id="2629">2629</span>
<span id="2630">2630</span>
<span id="2631">2631</span>
<span id="2632">2632</span>
<span id="2633">2633</span>
<span id="2634">2634</span>
<span id="2635">2635</span>
<span id="2636">2636</span>
<span id="2637">2637</span>
<span id="2638">2638</span>
<span id="2639">2639</span>
<span id="2640">2640</span>
<span id="2641">2641</span>
<span id="2642">2642</span>
<span id="2643">2643</span>
<span id="2644">2644</span>
<span id="2645">2645</span>
<span id="2646">2646</span>
<span id="2647">2647</span>
<span id="2648">2648</span>
<span id="2649">2649</span>
<span id="2650">2650</span>
<span id="2651">2651</span>
<span id="2652">2652</span>
<span id="2653">2653</span>
<span id="2654">2654</span>
<span id="2655">2655</span>
<span id="2656">2656</span>
<span id="2657">2657</span>
<span id="2658">2658</span>
<span id="2659">2659</span>
<span id="2660">2660</span>
<span id="2661">2661</span>
<span id="2662">2662</span>
<span id="2663">2663</span>
<span id="2664">2664</span>
<span id="2665">2665</span>
<span id="2666">2666</span>
<span id="2667">2667</span>
<span id="2668">2668</span>
<span id="2669">2669</span>
<span id="2670">2670</span>
<span id="2671">2671</span>
<span id="2672">2672</span>
<span id="2673">2673</span>
<span id="2674">2674</span>
<span id="2675">2675</span>
<span id="2676">2676</span>
<span id="2677">2677</span>
<span id="2678">2678</span>
<span id="2679">2679</span>
<span id="2680">2680</span>
<span id="2681">2681</span>
<span id="2682">2682</span>
<span id="2683">2683</span>
<span id="2684">2684</span>
<span id="2685">2685</span>
<span id="2686">2686</span>
<span id="2687">2687</span>
<span id="2688">2688</span>
<span id="2689">2689</span>
<span id="2690">2690</span>
<span id="2691">2691</span>
<span id="2692">2692</span>
<span id="2693">2693</span>
<span id="2694">2694</span>
<span id="2695">2695</span>
<span id="2696">2696</span>
<span id="2697">2697</span>
<span id="2698">2698</span>
<span id="2699">2699</span>
<span id="2700">2700</span>
<span id="2701">2701</span>
<span id="2702">2702</span>
<span id="2703">2703</span>
<span id="2704">2704</span>
<span id="2705">2705</span>
<span id="2706">2706</span>
<span id="2707">2707</span>
<span id="2708">2708</span>
<span id="2709">2709</span>
<span id="2710">2710</span>
<span id="2711">2711</span>
<span id="2712">2712</span>
<span id="2713">2713</span>
<span id="2714">2714</span>
<span id="2715">2715</span>
<span id="2716">2716</span>
<span id="2717">2717</span>
<span id="2718">2718</span>
<span id="2719">2719</span>
<span id="2720">2720</span>
<span id="2721">2721</span>
<span id="2722">2722</span>
<span id="2723">2723</span>
<span id="2724">2724</span>
<span id="2725">2725</span>
<span id="2726">2726</span>
<span id="2727">2727</span>
<span id="2728">2728</span>
<span id="2729">2729</span>
<span id="2730">2730</span>
<span id="2731">2731</span>
<span id="2732">2732</span>
<span id="2733">2733</span>
<span id="2734">2734</span>
<span id="2735">2735</span>
<span id="2736">2736</span>
<span id="2737">2737</span>
<span id="2738">2738</span>
<span id="2739">2739</span>
<span id="2740">2740</span>
<span id="2741">2741</span>
<span id="2742">2742</span>
<span id="2743">2743</span>
<span id="2744">2744</span>
<span id="2745">2745</span>
<span id="2746">2746</span>
<span id="2747">2747</span>
<span id="2748">2748</span>
<span id="2749">2749</span>
<span id="2750">2750</span>
<span id="2751">2751</span>
<span id="2752">2752</span>
<span id="2753">2753</span>
<span id="2754">2754</span>
<span id="2755">2755</span>
<span id="2756">2756</span>
<span id="2757">2757</span>
<span id="2758">2758</span>
<span id="2759">2759</span>
<span id="2760">2760</span>
<span id="2761">2761</span>
<span id="2762">2762</span>
<span id="2763">2763</span>
<span id="2764">2764</span>
<span id="2765">2765</span>
<span id="2766">2766</span>
<span id="2767">2767</span>
<span id="2768">2768</span>
<span id="2769">2769</span>
<span id="2770">2770</span>
<span id="2771">2771</span>
<span id="2772">2772</span>
<span id="2773">2773</span>
<span id="2774">2774</span>
<span id="2775">2775</span>
<span id="2776">2776</span>
<span id="2777">2777</span>
<span id="2778">2778</span>
<span id="2779">2779</span>
<span id="2780">2780</span>
<span id="2781">2781</span>
<span id="2782">2782</span>
<span id="2783">2783</span>
<span id="2784">2784</span>
<span id="2785">2785</span>
<span id="2786">2786</span>
<span id="2787">2787</span>
<span id="2788">2788</span>
<span id="2789">2789</span>
<span id="2790">2790</span>
<span id="2791">2791</span>
<span id="2792">2792</span>
<span id="2793">2793</span>
<span id="2794">2794</span>
<span id="2795">2795</span>
<span id="2796">2796</span>
<span id="2797">2797</span>
<span id="2798">2798</span>
<span id="2799">2799</span>
<span id="2800">2800</span>
<span id="2801">2801</span>
<span id="2802">2802</span>
<span id="2803">2803</span>
<span id="2804">2804</span>
<span id="2805">2805</span>
<span id="2806">2806</span>
<span id="2807">2807</span>
<span id="2808">2808</span>
<span id="2809">2809</span>
<span id="2810">2810</span>
<span id="2811">2811</span>
<span id="2812">2812</span>
<span id="2813">2813</span>
<span id="2814">2814</span>
<span id="2815">2815</span>
<span id="2816">2816</span>
<span id="2817">2817</span>
<span id="2818">2818</span>
<span id="2819">2819</span>
<span id="2820">2820</span>
<span id="2821">2821</span>
<span id="2822">2822</span>
<span id="2823">2823</span>
<span id="2824">2824</span>
<span id="2825">2825</span>
<span id="2826">2826</span>
<span id="2827">2827</span>
<span id="2828">2828</span>
<span id="2829">2829</span>
<span id="2830">2830</span>
<span id="2831">2831</span>
<span id="2832">2832</span>
<span id="2833">2833</span>
<span id="2834">2834</span>
<span id="2835">2835</span>
<span id="2836">2836</span>
<span id="2837">2837</span>
<span id="2838">2838</span>
<span id="2839">2839</span>
<span id="2840">2840</span>
<span id="2841">2841</span>
<span id="2842">2842</span>
<span id="2843">2843</span>
<span id="2844">2844</span>
<span id="2845">2845</span>
<span id="2846">2846</span>
<span id="2847">2847</span>
<span id="2848">2848</span>
<span id="2849">2849</span>
<span id="2850">2850</span>
<span id="2851">2851</span>
<span id="2852">2852</span>
<span id="2853">2853</span>
<span id="2854">2854</span>
<span id="2855">2855</span>
<span id="2856">2856</span>
<span id="2857">2857</span>
<span id="2858">2858</span>
<span id="2859">2859</span>
<span id="2860">2860</span>
<span id="2861">2861</span>
<span id="2862">2862</span>
<span id="2863">2863</span>
<span id="2864">2864</span>
<span id="2865">2865</span>
<span id="2866">2866</span>
<span id="2867">2867</span>
<span id="2868">2868</span>
<span id="2869">2869</span>
<span id="2870">2870</span>
<span id="2871">2871</span>
<span id="2872">2872</span>
<span id="2873">2873</span>
<span id="2874">2874</span>
<span id="2875">2875</span>
<span id="2876">2876</span>
<span id="2877">2877</span>
<span id="2878">2878</span>
<span id="2879">2879</span>
<span id="2880">2880</span>
<span id="2881">2881</span>
<span id="2882">2882</span>
<span id="2883">2883</span>
<span id="2884">2884</span>
<span id="2885">2885</span>
<span id="2886">2886</span>
<span id="2887">2887</span>
<span id="2888">2888</span>
<span id="2889">2889</span>
<span id="2890">2890</span>
<span id="2891">2891</span>
<span id="2892">2892</span>
<span id="2893">2893</span>
<span id="2894">2894</span>
<span id="2895">2895</span>
<span id="2896">2896</span>
<span id="2897">2897</span>
<span id="2898">2898</span>
<span id="2899">2899</span>
<span id="2900">2900</span>
<span id="2901">2901</span>
<span id="2902">2902</span>
<span id="2903">2903</span>
<span id="2904">2904</span>
<span id="2905">2905</span>
<span id="2906">2906</span>
<span id="2907">2907</span>
<span id="2908">2908</span>
<span id="2909">2909</span>
<span id="2910">2910</span>
<span id="2911">2911</span>
<span id="2912">2912</span>
<span id="2913">2913</span>
<span id="2914">2914</span>
<span id="2915">2915</span>
<span id="2916">2916</span>
<span id="2917">2917</span>
<span id="2918">2918</span>
<span id="2919">2919</span>
<span id="2920">2920</span>
<span id="2921">2921</span>
<span id="2922">2922</span>
<span id="2923">2923</span>
<span id="2924">2924</span>
<span id="2925">2925</span>
<span id="2926">2926</span>
<span id="2927">2927</span>
<span id="2928">2928</span>
<span id="2929">2929</span>
<span id="2930">2930</span>
<span id="2931">2931</span>
<span id="2932">2932</span>
<span id="2933">2933</span>
<span id="2934">2934</span>
<span id="2935">2935</span>
<span id="2936">2936</span>
<span id="2937">2937</span>
<span id="2938">2938</span>
<span id="2939">2939</span>
<span id="2940">2940</span>
<span id="2941">2941</span>
<span id="2942">2942</span>
<span id="2943">2943</span>
<span id="2944">2944</span>
<span id="2945">2945</span>
<span id="2946">2946</span>
<span id="2947">2947</span>
<span id="2948">2948</span>
<span id="2949">2949</span>
<span id="2950">2950</span>
<span id="2951">2951</span>
<span id="2952">2952</span>
<span id="2953">2953</span>
<span id="2954">2954</span>
<span id="2955">2955</span>
<span id="2956">2956</span>
<span id="2957">2957</span>
<span id="2958">2958</span>
<span id="2959">2959</span>
<span id="2960">2960</span>
<span id="2961">2961</span>
<span id="2962">2962</span>
<span id="2963">2963</span>
<span id="2964">2964</span>
<span id="2965">2965</span>
<span id="2966">2966</span>
<span id="2967">2967</span>
<span id="2968">2968</span>
<span id="2969">2969</span>
<span id="2970">2970</span>
<span id="2971">2971</span>
<span id="2972">2972</span>
<span id="2973">2973</span>
<span id="2974">2974</span>
<span id="2975">2975</span>
<span id="2976">2976</span>
<span id="2977">2977</span>
<span id="2978">2978</span>
<span id="2979">2979</span>
<span id="2980">2980</span>
<span id="2981">2981</span>
<span id="2982">2982</span>
<span id="2983">2983</span>
<span id="2984">2984</span>
<span id="2985">2985</span>
<span id="2986">2986</span>
<span id="2987">2987</span>
<span id="2988">2988</span>
<span id="2989">2989</span>
<span id="2990">2990</span>
<span id="2991">2991</span>
<span id="2992">2992</span>
<span id="2993">2993</span>
<span id="2994">2994</span>
<span id="2995">2995</span>
<span id="2996">2996</span>
<span id="2997">2997</span>
<span id="2998">2998</span>
<span id="2999">2999</span>
<span id="3000">3000</span>
<span id="3001">3001</span>
<span id="3002">3002</span>
<span id="3003">3003</span>
<span id="3004">3004</span>
<span id="3005">3005</span>
<span id="3006">3006</span>
<span id="3007">3007</span>
<span id="3008">3008</span>
<span id="3009">3009</span>
<span id="3010">3010</span>
<span id="3011">3011</span>
<span id="3012">3012</span>
<span id="3013">3013</span>
<span id="3014">3014</span>
<span id="3015">3015</span>
<span id="3016">3016</span>
<span id="3017">3017</span>
<span id="3018">3018</span>
<span id="3019">3019</span>
<span id="3020">3020</span>
<span id="3021">3021</span>
<span id="3022">3022</span>
<span id="3023">3023</span>
<span id="3024">3024</span>
<span id="3025">3025</span>
<span id="3026">3026</span>
<span id="3027">3027</span>
<span id="3028">3028</span>
<span id="3029">3029</span>
<span id="3030">3030</span>
<span id="3031">3031</span>
<span id="3032">3032</span>
<span id="3033">3033</span>
<span id="3034">3034</span>
<span id="3035">3035</span>
<span id="3036">3036</span>
<span id="3037">3037</span>
<span id="3038">3038</span>
<span id="3039">3039</span>
<span id="3040">3040</span>
<span id="3041">3041</span>
<span id="3042">3042</span>
<span id="3043">3043</span>
<span id="3044">3044</span>
<span id="3045">3045</span>
<span id="3046">3046</span>
<span id="3047">3047</span>
<span id="3048">3048</span>
<span id="3049">3049</span>
<span id="3050">3050</span>
<span id="3051">3051</span>
<span id="3052">3052</span>
<span id="3053">3053</span>
<span id="3054">3054</span>
<span id="3055">3055</span>
<span id="3056">3056</span>
<span id="3057">3057</span>
<span id="3058">3058</span>
<span id="3059">3059</span>
<span id="3060">3060</span>
<span id="3061">3061</span>
<span id="3062">3062</span>
<span id="3063">3063</span>
<span id="3064">3064</span>
<span id="3065">3065</span>
<span id="3066">3066</span>
<span id="3067">3067</span>
<span id="3068">3068</span>
<span id="3069">3069</span>
<span id="3070">3070</span>
<span id="3071">3071</span>
<span id="3072">3072</span>
<span id="3073">3073</span>
<span id="3074">3074</span>
<span id="3075">3075</span>
<span id="3076">3076</span>
<span id="3077">3077</span>
<span id="3078">3078</span>
<span id="3079">3079</span>
<span id="3080">3080</span>
<span id="3081">3081</span>
<span id="3082">3082</span>
<span id="3083">3083</span>
<span id="3084">3084</span>
<span id="3085">3085</span>
<span id="3086">3086</span>
<span id="3087">3087</span>
<span id="3088">3088</span>
<span id="3089">3089</span>
<span id="3090">3090</span>
<span id="3091">3091</span>
<span id="3092">3092</span>
<span id="3093">3093</span>
<span id="3094">3094</span>
<span id="3095">3095</span>
<span id="3096">3096</span>
<span id="3097">3097</span>
<span id="3098">3098</span>
<span id="3099">3099</span>
<span id="3100">3100</span>
<span id="3101">3101</span>
<span id="3102">3102</span>
<span id="3103">3103</span>
<span id="3104">3104</span>
<span id="3105">3105</span>
<span id="3106">3106</span>
<span id="3107">3107</span>
<span id="3108">3108</span>
<span id="3109">3109</span>
<span id="3110">3110</span>
<span id="3111">3111</span>
<span id="3112">3112</span>
<span id="3113">3113</span>
<span id="3114">3114</span>
<span id="3115">3115</span>
<span id="3116">3116</span>
<span id="3117">3117</span>
<span id="3118">3118</span>
<span id="3119">3119</span>
<span id="3120">3120</span>
<span id="3121">3121</span>
<span id="3122">3122</span>
<span id="3123">3123</span>
<span id="3124">3124</span>
<span id="3125">3125</span>
<span id="3126">3126</span>
<span id="3127">3127</span>
<span id="3128">3128</span>
<span id="3129">3129</span>
<span id="3130">3130</span>
<span id="3131">3131</span>
<span id="3132">3132</span>
<span id="3133">3133</span>
<span id="3134">3134</span>
<span id="3135">3135</span>
<span id="3136">3136</span>
<span id="3137">3137</span>
<span id="3138">3138</span>
<span id="3139">3139</span>
<span id="3140">3140</span>
<span id="3141">3141</span>
<span id="3142">3142</span>
<span id="3143">3143</span>
<span id="3144">3144</span>
<span id="3145">3145</span>
<span id="3146">3146</span>
<span id="3147">3147</span>
<span id="3148">3148</span>
<span id="3149">3149</span>
<span id="3150">3150</span>
<span id="3151">3151</span>
<span id="3152">3152</span>
<span id="3153">3153</span>
<span id="3154">3154</span>
<span id="3155">3155</span>
<span id="3156">3156</span>
<span id="3157">3157</span>
<span id="3158">3158</span>
<span id="3159">3159</span>
<span id="3160">3160</span>
<span id="3161">3161</span>
<span id="3162">3162</span>
<span id="3163">3163</span>
<span id="3164">3164</span>
<span id="3165">3165</span>
<span id="3166">3166</span>
<span id="3167">3167</span>
<span id="3168">3168</span>
<span id="3169">3169</span>
<span id="3170">3170</span>
<span id="3171">3171</span>
<span id="3172">3172</span>
<span id="3173">3173</span>
<span id="3174">3174</span>
<span id="3175">3175</span>
<span id="3176">3176</span>
<span id="3177">3177</span>
<span id="3178">3178</span>
<span id="3179">3179</span>
<span id="3180">3180</span>
<span id="3181">3181</span>
<span id="3182">3182</span>
<span id="3183">3183</span>
<span id="3184">3184</span>
<span id="3185">3185</span>
<span id="3186">3186</span>
<span id="3187">3187</span>
<span id="3188">3188</span>
<span id="3189">3189</span>
<span id="3190">3190</span>
<span id="3191">3191</span>
<span id="3192">3192</span>
<span id="3193">3193</span>
<span id="3194">3194</span>
<span id="3195">3195</span>
<span id="3196">3196</span>
<span id="3197">3197</span>
<span id="3198">3198</span>
<span id="3199">3199</span>
<span id="3200">3200</span>
<span id="3201">3201</span>
<span id="3202">3202</span>
<span id="3203">3203</span>
<span id="3204">3204</span>
<span id="3205">3205</span>
<span id="3206">3206</span>
<span id="3207">3207</span>
<span id="3208">3208</span>
<span id="3209">3209</span>
<span id="3210">3210</span>
<span id="3211">3211</span>
<span id="3212">3212</span>
<span id="3213">3213</span>
<span id="3214">3214</span>
<span id="3215">3215</span>
<span id="3216">3216</span>
<span id="3217">3217</span>
<span id="3218">3218</span>
<span id="3219">3219</span>
<span id="3220">3220</span>
<span id="3221">3221</span>
<span id="3222">3222</span>
<span id="3223">3223</span>
<span id="3224">3224</span>
<span id="3225">3225</span>
<span id="3226">3226</span>
<span id="3227">3227</span>
<span id="3228">3228</span>
<span id="3229">3229</span>
<span id="3230">3230</span>
<span id="3231">3231</span>
<span id="3232">3232</span>
<span id="3233">3233</span>
<span id="3234">3234</span>
<span id="3235">3235</span>
<span id="3236">3236</span>
<span id="3237">3237</span>
<span id="3238">3238</span>
<span id="3239">3239</span>
<span id="3240">3240</span>
<span id="3241">3241</span>
<span id="3242">3242</span>
<span id="3243">3243</span>
<span id="3244">3244</span>
<span id="3245">3245</span>
<span id="3246">3246</span>
<span id="3247">3247</span>
<span id="3248">3248</span>
<span id="3249">3249</span>
<span id="3250">3250</span>
<span id="3251">3251</span>
<span id="3252">3252</span>
<span id="3253">3253</span>
<span id="3254">3254</span>
<span id="3255">3255</span>
<span id="3256">3256</span>
<span id="3257">3257</span>
<span id="3258">3258</span>
<span id="3259">3259</span>
<span id="3260">3260</span>
<span id="3261">3261</span>
<span id="3262">3262</span>
<span id="3263">3263</span>
<span id="3264">3264</span>
<span id="3265">3265</span>
<span id="3266">3266</span>
<span id="3267">3267</span>
<span id="3268">3268</span>
<span id="3269">3269</span>
<span id="3270">3270</span>
<span id="3271">3271</span>
<span id="3272">3272</span>
<span id="3273">3273</span>
<span id="3274">3274</span>
<span id="3275">3275</span>
<span id="3276">3276</span>
<span id="3277">3277</span>
<span id="3278">3278</span>
<span id="3279">3279</span>
<span id="3280">3280</span>
<span id="3281">3281</span>
<span id="3282">3282</span>
<span id="3283">3283</span>
<span id="3284">3284</span>
<span id="3285">3285</span>
<span id="3286">3286</span>
<span id="3287">3287</span>
<span id="3288">3288</span>
<span id="3289">3289</span>
<span id="3290">3290</span>
<span id="3291">3291</span>
<span id="3292">3292</span>
<span id="3293">3293</span>
<span id="3294">3294</span>
<span id="3295">3295</span>
<span id="3296">3296</span>
<span id="3297">3297</span>
<span id="3298">3298</span>
<span id="3299">3299</span>
<span id="3300">3300</span>
<span id="3301">3301</span>
<span id="3302">3302</span>
<span id="3303">3303</span>
<span id="3304">3304</span>
<span id="3305">3305</span>
<span id="3306">3306</span>
<span id="3307">3307</span>
<span id="3308">3308</span>
<span id="3309">3309</span>
<span id="3310">3310</span>
<span id="3311">3311</span>
<span id="3312">3312</span>
<span id="3313">3313</span>
<span id="3314">3314</span>
<span id="3315">3315</span>
<span id="3316">3316</span>
<span id="3317">3317</span>
<span id="3318">3318</span>
<span id="3319">3319</span>
<span id="3320">3320</span>
<span id="3321">3321</span>
<span id="3322">3322</span>
<span id="3323">3323</span>
<span id="3324">3324</span>
<span id="3325">3325</span>
<span id="3326">3326</span>
<span id="3327">3327</span>
<span id="3328">3328</span>
<span id="3329">3329</span>
<span id="3330">3330</span>
<span id="3331">3331</span>
<span id="3332">3332</span>
<span id="3333">3333</span>
<span id="3334">3334</span>
<span id="3335">3335</span>
<span id="3336">3336</span>
<span id="3337">3337</span>
<span id="3338">3338</span>
<span id="3339">3339</span>
<span id="3340">3340</span>
<span id="3341">3341</span>
<span id="3342">3342</span>
<span id="3343">3343</span>
<span id="3344">3344</span>
<span id="3345">3345</span>
<span id="3346">3346</span>
<span id="3347">3347</span>
<span id="3348">3348</span>
<span id="3349">3349</span>
<span id="3350">3350</span>
<span id="3351">3351</span>
<span id="3352">3352</span>
<span id="3353">3353</span>
<span id="3354">3354</span>
<span id="3355">3355</span>
<span id="3356">3356</span>
<span id="3357">3357</span>
<span id="3358">3358</span>
<span id="3359">3359</span>
<span id="3360">3360</span>
<span id="3361">3361</span>
<span id="3362">3362</span>
<span id="3363">3363</span>
<span id="3364">3364</span>
<span id="3365">3365</span>
<span id="3366">3366</span>
<span id="3367">3367</span>
<span id="3368">3368</span>
<span id="3369">3369</span>
<span id="3370">3370</span>
<span id="3371">3371</span>
<span id="3372">3372</span>
<span id="3373">3373</span>
<span id="3374">3374</span>
<span id="3375">3375</span>
<span id="3376">3376</span>
<span id="3377">3377</span>
<span id="3378">3378</span>
<span id="3379">3379</span>
<span id="3380">3380</span>
<span id="3381">3381</span>
<span id="3382">3382</span>
<span id="3383">3383</span>
<span id="3384">3384</span>
<span id="3385">3385</span>
<span id="3386">3386</span>
<span id="3387">3387</span>
<span id="3388">3388</span>
<span id="3389">3389</span>
<span id="3390">3390</span>
<span id="3391">3391</span>
<span id="3392">3392</span>
<span id="3393">3393</span>
<span id="3394">3394</span>
<span id="3395">3395</span>
<span id="3396">3396</span>
<span id="3397">3397</span>
<span id="3398">3398</span>
<span id="3399">3399</span>
<span id="3400">3400</span>
<span id="3401">3401</span>
<span id="3402">3402</span>
<span id="3403">3403</span>
<span id="3404">3404</span>
<span id="3405">3405</span>
<span id="3406">3406</span>
<span id="3407">3407</span>
<span id="3408">3408</span>
<span id="3409">3409</span>
<span id="3410">3410</span>
<span id="3411">3411</span>
<span id="3412">3412</span>
<span id="3413">3413</span>
<span id="3414">3414</span>
<span id="3415">3415</span>
<span id="3416">3416</span>
<span id="3417">3417</span>
<span id="3418">3418</span>
<span id="3419">3419</span>
<span id="3420">3420</span>
<span id="3421">3421</span>
<span id="3422">3422</span>
<span id="3423">3423</span>
<span id="3424">3424</span>
<span id="3425">3425</span>
<span id="3426">3426</span>
<span id="3427">3427</span>
<span id="3428">3428</span>
<span id="3429">3429</span>
<span id="3430">3430</span>
<span id="3431">3431</span>
<span id="3432">3432</span>
<span id="3433">3433</span>
<span id="3434">3434</span>
<span id="3435">3435</span>
<span id="3436">3436</span>
<span id="3437">3437</span>
<span id="3438">3438</span>
<span id="3439">3439</span>
<span id="3440">3440</span>
<span id="3441">3441</span>
<span id="3442">3442</span>
<span id="3443">3443</span>
<span id="3444">3444</span>
<span id="3445">3445</span>
<span id="3446">3446</span>
<span id="3447">3447</span>
<span id="3448">3448</span>
<span id="3449">3449</span>
<span id="3450">3450</span>
<span id="3451">3451</span>
<span id="3452">3452</span>
<span id="3453">3453</span>
<span id="3454">3454</span>
<span id="3455">3455</span>
<span id="3456">3456</span>
<span id="3457">3457</span>
<span id="3458">3458</span>
<span id="3459">3459</span>
<span id="3460">3460</span>
<span id="3461">3461</span>
<span id="3462">3462</span>
<span id="3463">3463</span>
<span id="3464">3464</span>
<span id="3465">3465</span>
<span id="3466">3466</span>
<span id="3467">3467</span>
<span id="3468">3468</span>
<span id="3469">3469</span>
<span id="3470">3470</span>
<span id="3471">3471</span>
<span id="3472">3472</span>
<span id="3473">3473</span>
<span id="3474">3474</span>
<span id="3475">3475</span>
<span id="3476">3476</span>
<span id="3477">3477</span>
<span id="3478">3478</span>
<span id="3479">3479</span>
<span id="3480">3480</span>
<span id="3481">3481</span>
<span id="3482">3482</span>
<span id="3483">3483</span>
<span id="3484">3484</span>
<span id="3485">3485</span>
<span id="3486">3486</span>
<span id="3487">3487</span>
<span id="3488">3488</span>
<span id="3489">3489</span>
<span id="3490">3490</span>
<span id="3491">3491</span>
<span id="3492">3492</span>
<span id="3493">3493</span>
<span id="3494">3494</span>
<span id="3495">3495</span>
<span id="3496">3496</span>
<span id="3497">3497</span>
<span id="3498">3498</span>
<span id="3499">3499</span>
<span id="3500">3500</span>
<span id="3501">3501</span>
<span id="3502">3502</span>
<span id="3503">3503</span>
<span id="3504">3504</span>
<span id="3505">3505</span>
<span id="3506">3506</span>
<span id="3507">3507</span>
<span id="3508">3508</span>
</pre><pre class="rust"><code><span class="kw">use </span><a href="../middle/codegen_fn_attrs.rs.html#46-101"><span class="kw">crate</span>::middle::codegen_fn_attrs::CodegenFnAttrFlags</a>;
<span class="kw">use </span><span class="kw">crate</span>::mir::{<a href="../mir/query.rs.html#141">GeneratorLayout</a>, <a href="../mir/query.rs.html#132-137">GeneratorSavedLocal</a>};
<span class="kw">use </span><a href="normalize_erasing_regions.rs.html#17"><span class="kw">crate</span>::ty::normalize_erasing_regions::NormalizationError</a>;
<span class="kw">use </span><a href="subst.rs.html#502"><span class="kw">crate</span>::ty::subst::Subst</a>;
<span class="kw">use </span><span class="kw">crate</span>::ty::{
    <a class="self" href="../lib.rs.html#98">self</a>, <a href="layout_sanity_check.rs.html#10-13">layout_sanity_check::sanity_check_layout</a>, <a href="subst.rs.html#241">subst::SubstsRef</a>, <a href="sty.rs.html#920">EarlyBinder</a>, <a href="mod.rs.html#1955">ReprOptions</a>, <a href="mod.rs.html#484">Ty</a>,
    <a href="context.rs.html#1029">TyCtxt</a>, <a href="visit.rs.html#56">TypeVisitable</a>,
};
<span class="kw">use </span><a href="../../../rustc_ast/index.html">rustc_ast</a> <span class="kw">as </span>ast;
<span class="kw">use </span><a href="../../../rustc_attr/index.html">rustc_attr</a> <span class="kw">as </span>attr;
<span class="kw">use </span><a href="../../../rustc_hir/index.html">rustc_hir</a> <span class="kw">as </span>hir;
<span class="kw">use </span><a href="../../../rustc_span/def_id/struct.DefId.html">rustc_hir::def_id::DefId</a>;
<span class="kw">use </span><a href="../../../rustc_hir/lang_items/enum.LangItem.html">rustc_hir::lang_items::LangItem</a>;
<span class="kw">use </span><a href="../../../rustc_index/bit_set/struct.BitSet.html">rustc_index::bit_set::BitSet</a>;
<span class="kw">use </span>rustc_index::vec::{<a href="../../../rustc_index/vec/trait.Idx.html">Idx</a>, <a href="../../../rustc_index/vec/struct.IndexVec.html">IndexVec</a>};
<span class="kw">use </span>rustc_session::{<a href="../../../rustc_session/config/enum.OptLevel.html">config::OptLevel</a>, <a href="../../../rustc_session/code_stats/enum.DataTypeKind.html">DataTypeKind</a>, <a href="../../../rustc_session/code_stats/struct.FieldInfo.html">FieldInfo</a>, <a href="../../../rustc_session/code_stats/enum.SizeKind.html">SizeKind</a>, <a href="../../../rustc_session/code_stats/struct.VariantInfo.html">VariantInfo</a>};
<span class="kw">use </span><a href="../../../rustc_span/symbol/struct.Symbol.html">rustc_span::symbol::Symbol</a>;
<span class="kw">use </span>rustc_span::{<a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>, <a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>};
<span class="kw">use </span>rustc_target::abi::call::{
    <a href="../../../rustc_target/abi/call/struct.ArgAbi.html">ArgAbi</a>, <a href="../../../rustc_target/abi/call/attr_impl/struct.ArgAttribute.html">ArgAttribute</a>, <a href="../../../rustc_target/abi/call/struct.ArgAttributes.html">ArgAttributes</a>, <a href="../../../rustc_target/abi/call/enum.ArgExtension.html">ArgExtension</a>, <a href="../../../rustc_target/abi/call/enum.Conv.html">Conv</a>, <a href="../../../rustc_target/abi/call/struct.FnAbi.html">FnAbi</a>, <a href="../../../rustc_target/abi/call/enum.PassMode.html">PassMode</a>, <a href="../../../rustc_target/abi/call/struct.Reg.html">Reg</a>, <a href="../../../rustc_target/abi/call/enum.RegKind.html">RegKind</a>,
};
<span class="kw">use </span><a href="../../../rustc_target/abi/index.html">rustc_target::abi</a>::<span class="kw-2">*</span>;
<span class="kw">use </span>rustc_target::spec::{<a href="../../../rustc_target/spec/abi/enum.Abi.html">abi::Abi</a> <span class="kw">as </span>SpecAbi, <a href="../../../rustc_target/spec/trait.HasTargetSpec.html">HasTargetSpec</a>, <a href="../../../rustc_target/spec/enum.PanicStrategy.html">PanicStrategy</a>, <a href="../../../rustc_target/spec/struct.Target.html">Target</a>};

<span class="kw">use </span>std::cmp::{<a class="self" href="https://doc.rust-lang.org/nightly/core/cmp/index.html">self</a>, <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html">Ordering</a>};
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/alloc/fmt/index.html">std::fmt</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/core/iter/index.html">std::iter</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/core/num/nonzero/struct.NonZeroUsize.html">std::num::NonZeroUsize</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/core/ops/range/enum.Bound.html">std::ops::Bound</a>;

<span class="kw">use </span>rand::{<a href="https://rust-random.github.io/rand/rand/seq/trait.SliceRandom.html">seq::SliceRandom</a>, <a href="https://rust-random.github.io/rand/rand_core/trait.SeedableRng.html">SeedableRng</a>};
<span class="kw">use </span><a href="https://docs.rs/rand_xoshiro/0.6.0/rand_xoshiro/xoshiro128starstar/struct.Xoshiro128StarStar.html">rand_xoshiro::Xoshiro128StarStar</a>;

<span class="kw">pub fn </span>provide(providers: <span class="kw-2">&amp;mut </span><a href="query.rs.html#337">ty::query::Providers</a>) {
    <span class="kw-2">*</span><a href="#34">providers</a> =
        <a href="query.rs.html#337">ty::query::Providers</a> { <a href="#227">layout_of</a>, <a href="#3146-3149">fn_abi_of_fn_ptr</a>, <a href="#3155-3158">fn_abi_of_instance</a>, ..<span class="kw-2">*</span><a href="#34">providers</a> };
}

<span class="kw">pub trait </span>IntegerExt {
    <span class="kw">fn </span>to_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;, signed: <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;;
    <span class="kw">fn </span>from_attr&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, ity: <a href="../../../rustc_attr/builtin/enum.IntType.html">attr::IntType</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a>;
    <span class="kw">fn </span>from_int_ty&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, ity: <a href="../../../rustc_middle/ty/enum.IntTy.html">ty::IntTy</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a>;
    <span class="kw">fn </span>from_uint_ty&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, uty: <a href="../../../rustc_middle/ty/enum.UintTy.html">ty::UintTy</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a>;
    <span class="kw">fn </span>repr_discr&lt;<span class="lifetime">&#39;tcx</span>&gt;(
        tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        repr: <span class="kw-2">&amp;</span><a href="mod.rs.html#1955">ReprOptions</a>,
        min: <a href="https://doc.rust-lang.org/nightly/std/primitive.i128.html">i128</a>,
        max: <a href="https://doc.rust-lang.org/nightly/std/primitive.i128.html">i128</a>,
    ) -&gt; (<a href="../../../rustc_target/abi/enum.Integer.html">Integer</a>, <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>);
}

<span class="kw">impl </span><a href="#39">IntegerExt</a> <span class="kw">for </span><a href="../../../rustc_target/abi/enum.Integer.html">Integer</a> {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>to_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;, signed: <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">match </span>(<span class="kw-2">*</span><a class="self" href="#55">self</a>, <a href="#55">signed</a>) {
            (I8, <span class="bool-val">false</span>) =&gt; <a href="#55">tcx</a>.types.u8,
            (I16, <span class="bool-val">false</span>) =&gt; <a href="#55">tcx</a>.types.u16,
            (I32, <span class="bool-val">false</span>) =&gt; <a href="#55">tcx</a>.types.u32,
            (I64, <span class="bool-val">false</span>) =&gt; <a href="#55">tcx</a>.types.u64,
            (I128, <span class="bool-val">false</span>) =&gt; <a href="#55">tcx</a>.types.u128,
            (I8, <span class="bool-val">true</span>) =&gt; <a href="#55">tcx</a>.types.i8,
            (I16, <span class="bool-val">true</span>) =&gt; <a href="#55">tcx</a>.types.i16,
            (I32, <span class="bool-val">true</span>) =&gt; <a href="#55">tcx</a>.types.i32,
            (I64, <span class="bool-val">true</span>) =&gt; <a href="#55">tcx</a>.types.i64,
            (I128, <span class="bool-val">true</span>) =&gt; <a href="#55">tcx</a>.types.i128,
        }
    }

    <span class="doccomment">/// Gets the Integer type from an attr::IntType.
    </span><span class="kw">fn </span>from_attr&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, ity: <a href="../../../rustc_attr/builtin/enum.IntType.html">attr::IntType</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a> {
        <span class="kw">let </span>dl = <a href="#71">cx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>();

        <span class="kw">match </span><a href="#71">ity</a> {
            attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) =&gt; I8,
            attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) =&gt; I16,
            attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) =&gt; I32,
            attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) =&gt; I64,
            attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) =&gt; I128,
            attr::SignedInt(ast::IntTy::Isize) | attr::UnsignedInt(ast::UintTy::Usize) =&gt; {
                <a href="#72">dl</a>.ptr_sized_integer()
            }
        }
    }

    <span class="kw">fn </span>from_int_ty&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, ity: <a href="../../../rustc_middle/ty/enum.IntTy.html">ty::IntTy</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a> {
        <span class="kw">match </span><a href="#86">ity</a> {
            ty::IntTy::I8 =&gt; I8,
            ty::IntTy::I16 =&gt; I16,
            ty::IntTy::I32 =&gt; I32,
            ty::IntTy::I64 =&gt; I64,
            ty::IntTy::I128 =&gt; I128,
            ty::IntTy::Isize =&gt; <a href="#86">cx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>().ptr_sized_integer(),
        }
    }
    <span class="kw">fn </span>from_uint_ty&lt;C: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt;(cx: <span class="kw-2">&amp;</span>C, ity: <a href="../../../rustc_middle/ty/enum.UintTy.html">ty::UintTy</a>) -&gt; <a href="../../../rustc_target/abi/enum.Integer.html">Integer</a> {
        <span class="kw">match </span><a href="#96">ity</a> {
            ty::UintTy::U8 =&gt; I8,
            ty::UintTy::U16 =&gt; I16,
            ty::UintTy::U32 =&gt; I32,
            ty::UintTy::U64 =&gt; I64,
            ty::UintTy::U128 =&gt; I128,
            ty::UintTy::Usize =&gt; <a href="#96">cx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>().ptr_sized_integer(),
        }
    }

    <span class="doccomment">/// Finds the appropriate Integer type and signedness for the given
    /// signed discriminant range and `#[repr]` attribute.
    /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but
    /// that shouldn&#39;t affect anything, other than maybe debuginfo.
    </span><span class="kw">fn </span>repr_discr&lt;<span class="lifetime">&#39;tcx</span>&gt;(
        tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        repr: <span class="kw-2">&amp;</span><a href="mod.rs.html#1955">ReprOptions</a>,
        min: <a href="https://doc.rust-lang.org/nightly/std/primitive.i128.html">i128</a>,
        max: <a href="https://doc.rust-lang.org/nightly/std/primitive.i128.html">i128</a>,
    ) -&gt; (<a href="../../../rustc_target/abi/enum.Integer.html">Integer</a>, <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) {
        <span class="comment">// Theoretically, negative values could be larger in unsigned representation
        // than the unsigned representation of the signed minimum. However, if there
        // are any negative values, the only valid unsigned representation is u128
        // which can fit all i128 values, so the result remains unaffected.
        </span><span class="kw">let </span>unsigned_fit = Integer::fit_unsigned(cmp::max(<a href="#115">min</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a>, <a href="#116">max</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a>));
        <span class="kw">let </span>signed_fit = cmp::max(Integer::fit_signed(<a href="#115">min</a>), Integer::fit_signed(<a href="#116">max</a>));

        <span class="kw">if let </span><span class="prelude-val">Some</span>(ity) = <a href="#114">repr</a>.int {
            <span class="kw">let </span>discr = Integer::from_attr(<span class="kw-2">&amp;</span><a href="#112">tcx</a>, <a href="#125">ity</a>);
            <span class="kw">let </span>fit = <span class="kw">if </span>ity.is_signed() { <a href="#123">signed_fit</a> } <span class="kw">else </span>{ <a href="#122">unsigned_fit</a> };
            <span class="kw">if </span>discr &lt; fit {
                <a class="macro" href="../macros.rs.html#2-9">bug!</a>(
                    <span class="string">&quot;Integer::repr_discr: `#[repr]` hint too small for \
                      discriminant range of enum `{}&quot;</span>,
                    ty
                )
            }
            <span class="kw">return </span>(<a href="#126">discr</a>, <a href="#125">ity</a>.is_signed());
        }

        <span class="kw">let </span>at_least = <span class="kw">if </span>repr.c() {
            <span class="comment">// This is usually I32, however it can be different on some platforms,
            // notably hexagon and arm-none/thumb-none
            </span><a href="#112">tcx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>().c_enum_min_size
        } <span class="kw">else </span>{
            <span class="comment">// repr(Rust) enums try to be as small as possible
            </span>I8
        };

        <span class="comment">// If there are no negative values, we can use the unsigned fit.
        </span><span class="kw">if </span>min &gt;= <span class="number">0 </span>{
            (cmp::max(<a href="#122">unsigned_fit</a>, <a href="#138">at_least</a>), <span class="bool-val">false</span>)
        } <span class="kw">else </span>{
            (cmp::max(<a href="#123">signed_fit</a>, <a href="#138">at_least</a>), <span class="bool-val">true</span>)
        }
    }
}

<span class="kw">pub trait </span>PrimitiveExt {
    <span class="kw">fn </span>to_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;;
    <span class="kw">fn </span>to_int_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;;
}

<span class="kw">impl </span><a href="#156">PrimitiveExt</a> <span class="kw">for </span><a href="../../../rustc_target/abi/enum.Primitive.html">Primitive</a> {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>to_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self"><a href="#163">self</a> </span>{
            Int(i, signed) =&gt; <a href="#165">i</a>.<a href="#40">to_ty</a>(<a href="#163">tcx</a>, <a href="#165">signed</a>),
            F32 =&gt; <a href="#163">tcx</a>.types.f32,
            F64 =&gt; <a href="#163">tcx</a>.types.f64,
            Pointer =&gt; <a href="#163">tcx</a>.<a href="context.rs.html#2497">mk_mut_ptr</a>(<a href="#163">tcx</a>.<a href="context.rs.html#2526">mk_unit</a>()),
        }
    }

    <span class="doccomment">/// Return an *integer* type matching this primitive.
    /// Useful in particular when dealing with enum discriminants.
    </span><span class="attribute">#[inline]
    </span><span class="kw">fn </span>to_int_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self"><a href="#175">self</a> </span>{
            Int(i, signed) =&gt; <a href="#177">i</a>.<a href="#40">to_ty</a>(<a href="#175">tcx</a>, <a href="#177">signed</a>),
            Pointer =&gt; <a href="#175">tcx</a>.types.usize,
            F32 | F64 =&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;floats do not have an int type&quot;</span>),
        }
    }
}

<span class="doccomment">/// The first half of a fat pointer.
///
/// - For a trait object, this is the address of the box.
/// - For a slice, this is the base address.
</span><span class="kw">pub const </span>FAT_PTR_ADDR: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = <span class="number">0</span>;

<span class="doccomment">/// The second half of a fat pointer.
///
/// - For a trait object, this is the address of the vtable.
/// - For a slice, this is the length.
</span><span class="kw">pub const </span>FAT_PTR_EXTRA: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = <span class="number">1</span>;

<span class="doccomment">/// The maximum supported number of lanes in a SIMD vector.
///
/// This value is selected based on backend support:
/// * LLVM does not appear to have a vector width limit.
/// * Cranelift stores the base-2 log of the lane count in a 4 bit integer.
</span><span class="kw">pub const </span>MAX_SIMD_LANES: <a href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a> = <span class="number">1 </span>&lt;&lt; <span class="number">0xF</span>;

<span class="attribute">#[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]
</span><span class="kw">pub enum </span>LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    Unknown(Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;),
    SizeOverflow(Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;),
    NormalizationFailure(Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;, NormalizationError&lt;<span class="lifetime">&#39;tcx</span>&gt;),
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">fmt::Display</a> <span class="kw">for </span>LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html">fmt::Result</a> {
        <span class="kw">match </span><span class="kw-2">*</span><span class="self"><a href="#211">self</a> </span>{
            <a href="#205">LayoutError::Unknown</a>(ty) =&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.write.html">write!</a>(<a href="#211">f</a>, <span class="string">&quot;the type `{}` has an unknown layout&quot;</span>, ty),
            <a href="#206">LayoutError::SizeOverflow</a>(ty) =&gt; {
                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.write.html">write!</a>(<a href="#211">f</a>, <span class="string">&quot;values of the type `{}` are too big for the current architecture&quot;</span>, ty)
            }
            <a href="#207">LayoutError::NormalizationFailure</a>(t, e) =&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.write.html">write!</a>(
                <a href="#211">f</a>,
                <span class="string">&quot;unable to determine layout for `{}` because `{}` cannot be normalized&quot;</span>,
                t,
                e.get_type_for_failure()
            ),
        }
    }
}

<span class="attribute">#[instrument(skip(tcx, query), level = <span class="string">&quot;debug&quot;</span>)]
</span><span class="kw">fn </span>layout_of&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    query: ty::ParamEnvAnd&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">let </span>(param_env, ty) = query.into_parts();
    <span class="macro">debug!</span>(<span class="question-mark">?</span>ty);

    <span class="kw">let </span>param_env = param_env.with_reveal_all_normalized(tcx);
    <span class="kw">let </span>unnormalized_ty = ty;

    <span class="comment">// FIXME: We might want to have two different versions of `layout_of`:
    // One that can be called after typecheck has completed and can use
    // `normalize_erasing_regions` here and another one that can be called
    // before typecheck has completed and uses `try_normalize_erasing_regions`.
    </span><span class="kw">let </span>ty = <span class="kw">match </span>tcx.try_normalize_erasing_regions(param_env, ty) {
        <span class="prelude-val">Ok</span>(t) =&gt; t,
        <span class="prelude-val">Err</span>(normalization_error) =&gt; {
            <span class="kw">return </span><span class="prelude-val">Err</span>(LayoutError::NormalizationFailure(ty, normalization_error));
        }
    };

    <span class="kw">if </span>ty != unnormalized_ty {
        <span class="comment">// Ensure this layout is also cached for the normalized type.
        </span><span class="kw">return </span>tcx.layout_of(param_env.and(ty));
    }

    <span class="kw">let </span>cx = LayoutCx { tcx, param_env };

    <span class="kw">let </span>layout = cx.layout_of_uncached(ty)<span class="question-mark">?</span>;
    <span class="kw">let </span>layout = TyAndLayout { ty, layout };

    cx.record_layout_for_printing(layout);

    sanity_check_layout(<span class="kw-2">&amp;</span>cx, <span class="kw-2">&amp;</span>layout);

    <span class="prelude-val">Ok</span>(layout)
}

<span class="attribute">#[derive(Clone, Copy)]
</span><span class="kw">pub struct </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, C&gt; {
    <span class="kw">pub </span>tcx: C,
    <span class="kw">pub </span>param_env: ty::ParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;,
}

<span class="attribute">#[derive(Copy, Clone, Debug)]
</span><span class="kw">enum </span>StructKind {
    <span class="doccomment">/// A tuple, closure, or univariant which cannot be coerced to unsized.
    </span>AlwaysSized,
    <span class="doccomment">/// A univariant, the last field of which may be coerced to unsized.
    </span>MaybeUnsized,
    <span class="doccomment">/// A univariant, but with a prefix of an arbitrary size &amp; alignment (e.g., enum tag).
    </span>Prefixed(<a href="../../../rustc_target/abi/struct.Size.html">Size</a>, <a href="../../../rustc_target/abi/struct.Align.html">Align</a>),
}

<span class="comment">// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.
// This is used to go between `memory_index` (source field order to memory order)
// and `inverse_memory_index` (memory order to source field order).
// See also `FieldsShape::Arbitrary::memory_index` for more details.
// FIXME(eddyb) build a better abstraction for permutations, if possible.
</span><span class="kw">fn </span>invert_mapping(map: <span class="kw-2">&amp;</span>[<a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>]) -&gt; Vec&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>inverse = <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[<span class="number">0</span>; map.len()];
    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..map.len() {
        inverse[map[i] <span class="kw">as </span>usize] = i <span class="kw">as </span>u32;
    }
    <a href="#288">inverse</a>
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">fn </span>scalar_pair(<span class="kw-2">&amp;</span><span class="self">self</span>, a: <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar</a>, b: <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar</a>) -&gt; LayoutS&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">let </span>dl = <a class="self" href="#296">self</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>();
        <span class="kw">let </span>b_align = <a href="#296">b</a>.align(<a href="#297">dl</a>);
        <span class="kw">let </span>align = <a href="#296">a</a>.align(<a href="#297">dl</a>).max(<a href="#298">b_align</a>).max(<a href="#297">dl</a>.aggregate_align);
        <span class="kw">let </span>b_offset = <a href="#296">a</a>.size(<a href="#297">dl</a>).align_to(<a href="#298">b_align</a>.abi);
        <span class="kw">let </span>size = (<a href="#300">b_offset</a> + <a href="#296">b</a>.size(<a href="#297">dl</a>)).align_to(<a href="#299">align</a>.abi);

        <span class="comment">// HACK(nox): We iter on `b` and then `a` because `max_by_key`
        // returns the last maximum.
        </span><span class="kw">let </span>largest_niche = Niche::from_scalar(<a href="#297">dl</a>, <a href="#300">b_offset</a>, <a href="#296">b</a>)
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html">into_iter</a>()
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">chain</a>(Niche::from_scalar(<a href="#297">dl</a>, Size::ZERO, <a href="#296">a</a>))
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">max_by_key</a>(|niche| <a href="#308">niche</a>.available(<a href="#297">dl</a>));

        <a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
            variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
            fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> {
                offsets: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[Size::ZERO, b_offset],
                memory_index: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[<span class="number">0</span>, <span class="number">1</span>],
            },
            abi: Abi::ScalarPair(<a href="#296">a</a>, <a href="#296">b</a>),
            <a href="#305">largest_niche</a>,
            <a href="#299">align</a>,
            <a href="#301">size</a>,
        }
    }

    <span class="kw">fn </span>univariant_uninterned(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        fields: <span class="kw-2">&amp;</span>[TyAndLayout&lt;<span class="lifetime">&#39;_</span>&gt;],
        repr: <span class="kw-2">&amp;</span><a href="mod.rs.html#1955">ReprOptions</a>,
        kind: <a href="#273">StructKind</a>,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;LayoutS&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <span class="kw">let </span>dl = <a class="self" href="#324">self</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>();
        <span class="kw">let </span>pack = <a href="#327">repr</a>.pack;
        <span class="kw">if </span>pack.is_some() &amp;&amp; repr.align.is_some() {
            <a class="self" href="#324">self</a>.tcx.sess.delay_span_bug(<a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>, <span class="string">&quot;struct cannot be packed and aligned&quot;</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#325">ty</a>));
        }

        <span class="kw">let </span><span class="kw-2">mut </span>align = <span class="kw">if </span>pack.is_some() { <a href="#330">dl</a>.i8_align } <span class="kw">else </span>{ <a href="#330">dl</a>.aggregate_align };

        <span class="kw">let </span><span class="kw-2">mut </span>inverse_memory_index: Vec&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt; = (<span class="number">0</span>..<a href="#326">fields</a>.len() <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>).<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();

        <span class="kw">let </span>optimize = !<a href="#327">repr</a>.<a href="mod.rs.html#2069">inhibit_struct_field_reordering_opt</a>();
        <span class="kw">if </span>optimize {
            <span class="kw">let </span>end =
                <span class="kw">if let </span><a href="#277">StructKind::MaybeUnsized</a> = <a href="#328">kind</a> { <a href="#326">fields</a>.len() - <span class="number">1 </span>} <span class="kw">else </span>{ <a href="#326">fields</a>.len() };
            <span class="kw">let </span>optimizing = <span class="kw-2">&amp;mut </span><a href="#339">inverse_memory_index</a>[..<a href="#343">end</a>];
            <span class="kw">let </span>field_align = |f: <span class="kw-2">&amp;</span>TyAndLayout&lt;<span class="lifetime">&#39;_</span>&gt;| {
                <span class="kw">if let </span><span class="prelude-val">Some</span>(pack) = <a href="#331">pack</a> { <a href="#346">f</a>.align.abi.<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html">min</a>(<a href="#347">pack</a>) } <span class="kw">else </span>{ <a href="#346">f</a>.align.abi }
            };

            <span class="comment">// If `-Z randomize-layout` was enabled for the type definition we can shuffle
            // the field ordering to try and catch some code making assumptions about layouts
            // we don&#39;t guarantee
            </span><span class="kw">if </span>repr.can_randomize_type_layout() {
                <span class="comment">// `ReprOptions.layout_seed` is a deterministic seed that we can use to
                // randomize field ordering with
                </span><span class="kw">let </span><span class="kw-2">mut </span>rng = Xoshiro128StarStar::seed_from_u64(<a href="#327">repr</a>.field_shuffle_seed);

                <span class="comment">// Shuffle the ordering of the fields
                </span><a href="#345">optimizing</a>.<a href="https://rust-random.github.io/rand/rand/seq/trait.SliceRandom.html">shuffle</a>(<span class="kw-2">&amp;mut </span><a href="#356">rng</a>);

            <span class="comment">// Otherwise we just leave things alone and actually optimize the type&#39;s fields
            </span>} <span class="kw">else </span>{
                <span class="kw">match </span><a href="#328">kind</a> {
                    <a href="#275">StructKind::AlwaysSized</a> | <a href="#277">StructKind::MaybeUnsized</a> =&gt; {
                        <a href="#345">optimizing</a>.sort_by_key(|<span class="kw-2">&amp;</span>x| {
                            <span class="comment">// Place ZSTs first to avoid &quot;interesting offsets&quot;,
                            // especially with only one or two non-ZST fields.
                            </span><span class="kw">let </span>f = <span class="kw-2">&amp;</span><a href="#326">fields</a>[<a href="#365">x</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>];
                            (!<a href="#368">f</a>.is_zst(), cmp::Reverse(<a href="#346">field_align</a>(<a href="#368">f</a>)))
                        });
                    }

                    <a href="#279">StructKind::Prefixed</a>(..) =&gt; {
                        <span class="comment">// Sort in ascending alignment so that the layout stays optimal
                        // regardless of the prefix
                        </span><a href="#345">optimizing</a>.sort_by_key(|<span class="kw-2">&amp;</span>x| <a href="#346">field_align</a>(<span class="kw-2">&amp;</span><a href="#326">fields</a>[<a href="#376">x</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>]));
                    }
                }

                <span class="comment">// FIXME(Kixiron): We can always shuffle fields within a given alignment class
                //                 regardless of the status of `-Z randomize-layout`
            </span>}
        }

        <span class="comment">// inverse_memory_index holds field indices by increasing memory offset.
        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.
        // We now write field offsets to the corresponding offset slot;
        // field 5 with offset 0 puts 0 in offsets[5].
        // At the bottom of this function, we invert `inverse_memory_index` to
        // produce `memory_index` (see `invert_mapping`).

        </span><span class="kw">let </span><span class="kw-2">mut </span>sized = <span class="bool-val">true</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>offsets = <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[Size::ZERO; fields.len()];
        <span class="kw">let </span><span class="kw-2">mut </span>offset = Size::ZERO;
        <span class="kw">let </span><span class="kw-2">mut </span>largest_niche = <span class="prelude-val">None</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>largest_niche_available = <span class="number">0</span>;

        <span class="kw">if let </span><a href="#279">StructKind::Prefixed</a>(prefix_size, prefix_align) = <a href="#328">kind</a> {
            <span class="kw">let </span>prefix_align =
                <span class="kw">if let </span><span class="prelude-val">Some</span>(pack) = <a href="#331">pack</a> { <a href="#398">prefix_align</a>.<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html">min</a>(<a href="#400">pack</a>) } <span class="kw">else </span>{ <a href="#398">prefix_align</a> };
            <a href="#337">align</a> = <a href="#337">align</a>.max(AbiAndPrefAlign::new(<a href="#399">prefix_align</a>));
            <a href="#394">offset</a> = <a href="#398">prefix_size</a>.align_to(<a href="#399">prefix_align</a>);
        }

        <span class="kw">for </span><span class="kw-2">&amp;</span>i <span class="kw">in </span><span class="kw-2">&amp;</span>inverse_memory_index {
            <span class="kw">let </span>field = fields[i <span class="kw">as </span>usize];
            <span class="kw">if </span>!sized {
                <span class="self">self</span>.tcx.sess.delay_span_bug(
                    DUMMY_SP,
                    <span class="kw-2">&amp;</span><span class="macro">format!</span>(
                        <span class="string">&quot;univariant: field #{} of `{}` comes after unsized field&quot;</span>,
                        offsets.len(),
                        ty
                    ),
                );
            }

            <span class="kw">if </span>field.is_unsized() {
                sized = <span class="bool-val">false</span>;
            }

            <span class="comment">// Invariant: offset &lt; dl.obj_size_bound() &lt;= 1&lt;&lt;61
            </span><span class="kw">let </span>field_align = <span class="kw">if let </span><span class="prelude-val">Some</span>(pack) = pack {
                field.align.min(AbiAndPrefAlign::new(pack))
            } <span class="kw">else </span>{
                field.align
            };
            offset = offset.align_to(field_align.abi);
            align = align.max(field_align);

            <span class="macro">debug!</span>(<span class="string">&quot;univariant offset: {:?} field: {:#?}&quot;</span>, offset, field);
            offsets[i <span class="kw">as </span>usize] = offset;

            <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>niche) = field.largest_niche {
                <span class="kw">let </span>available = niche.available(dl);
                <span class="kw">if </span>available &gt; largest_niche_available {
                    largest_niche_available = available;
                    niche.offset += offset;
                    largest_niche = <span class="prelude-val">Some</span>(niche);
                }
            }

            offset = offset.checked_add(field.size, dl).ok_or(LayoutError::SizeOverflow(ty))<span class="question-mark">?</span>;
        }

        <span class="kw">if let </span><span class="prelude-val">Some</span>(repr_align) = <a href="#327">repr</a>.align {
            <a href="#337">align</a> = <a href="#337">align</a>.max(AbiAndPrefAlign::new(<a href="#446">repr_align</a>));
        }

        <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;univariant min_size: {:?}&quot;</span>, offset);
        <span class="kw">let </span>min_size = <a href="#394">offset</a>;

        <span class="comment">// As stated above, inverse_memory_index holds field indices by increasing offset.
        // This makes it an already-sorted view of the offsets vec.
        // To invert it, consider:
        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.
        // Field 5 would be the first element, so memory_index is i:
        // Note: if we didn&#39;t optimize, it&#39;s already right.

        </span><span class="kw">let </span>memory_index =
            <span class="kw">if </span>optimize { <a href="#287">invert_mapping</a>(<span class="kw-2">&amp;</span><a href="#339">inverse_memory_index</a>) } <span class="kw">else </span>{ <a href="#339">inverse_memory_index</a> };

        <span class="kw">let </span>size = <a href="#451">min_size</a>.align_to(<a href="#337">align</a>.abi);
        <span class="kw">let </span><span class="kw-2">mut </span>abi = <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { <a href="#392">sized</a> };

        <span class="comment">// Unpack newtype ABIs and find scalar pairs.
        </span><span class="kw">if </span>sized &amp;&amp; size.bytes() &gt; <span class="number">0 </span>{
            <span class="comment">// All other fields must be ZSTs.
            </span><span class="kw">let </span><span class="kw-2">mut </span>non_zst_fields = <a href="#326">fields</a>.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">enumerate</a>().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">filter</a>(|<span class="kw-2">&amp;</span>(<span class="kw">_</span>, f)| !<a href="#469">f</a>.is_zst());

            <span class="kw">match </span>(<a href="#469">non_zst_fields</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">next</a>(), <a href="#469">non_zst_fields</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">next</a>(), <a href="#469">non_zst_fields</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">next</a>()) {
                <span class="comment">// We have exactly one non-ZST field.
                </span>(<span class="prelude-val">Some</span>((i, field)), <span class="prelude-val">None</span>, <span class="prelude-val">None</span>) =&gt; {
                    <span class="comment">// Field fills the struct and it has a scalar or scalar pair ABI.
                    </span><span class="kw">if </span>offsets[i].bytes() == <span class="number">0 </span>&amp;&amp; align.abi == field.align.abi &amp;&amp; size == field.size
                    {
                        <span class="kw">match </span><a href="#473">field</a>.abi {
                            <span class="comment">// For plain scalars, or vectors of them, we can&#39;t unpack
                            // newtypes for `#[repr(C)]`, as that affects C ABIs.
                            </span>Abi::Scalar(<span class="kw">_</span>) | <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Vector</a> { .. } <span class="kw">if </span><a href="#341">optimize</a> =&gt; {
                                <a href="#464">abi</a> = <a href="#473">field</a>.abi;
                            }
                            <span class="comment">// But scalar pairs are Rust-specific and get
                            // treated as aggregates by C ABIs anyway.
                            </span>Abi::ScalarPair(..) =&gt; {
                                <a href="#464">abi</a> = <a href="#473">field</a>.abi;
                            }
                            <span class="kw">_ </span>=&gt; {}
                        }
                    }
                }

                <span class="comment">// Two non-ZST fields, and they&#39;re both scalars.
                </span>(<span class="prelude-val">Some</span>((i, a)), <span class="prelude-val">Some</span>((j, b)), <span class="prelude-val">None</span>) =&gt; {
                    <span class="kw">match </span>(<a href="#494">a</a>.abi, <a href="#494">b</a>.abi) {
                        (Abi::Scalar(a), Abi::Scalar(b)) =&gt; {
                            <span class="comment">// Order by the memory placement, not source order.
                            </span><span class="kw">let </span>((i, a), (j, b)) = <span class="kw">if </span>offsets[i] &lt; offsets[j] {
                                ((<a href="#494">i</a>, <a href="#496">a</a>), (<a href="#494">j</a>, <a href="#496">b</a>))
                            } <span class="kw">else </span>{
                                ((<a href="#494">j</a>, <a href="#496">b</a>), (<a href="#494">i</a>, <a href="#496">a</a>))
                            };
                            <span class="kw">let </span>pair = <a class="self" href="#324">self</a>.<a href="#296">scalar_pair</a>(<a href="#498">a</a>, <a href="#498">b</a>);
                            <span class="kw">let </span>pair_offsets = <span class="kw">match </span><a href="#503">pair</a>.fields {
                                <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { <span class="kw-2">ref </span>offsets, <span class="kw-2">ref </span>memory_index } =&gt; {
                                    <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(memory_index, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>]);
                                    <a href="#505">offsets</a>
                                }
                                <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
                            };
                            <span class="kw">if </span>offsets[i] == pair_offsets[<span class="number">0</span>]
                                &amp;&amp; offsets[j] == pair_offsets[<span class="number">1</span>]
                                &amp;&amp; align == pair.align
                                &amp;&amp; size == pair.size
                            {
                                <span class="comment">// We can use `ScalarPair` only when it matches our
                                // already computed layout (including `#[repr(C)]`).
                                </span><a href="#464">abi</a> = <a href="#503">pair</a>.abi;
                            }
                        }
                        <span class="kw">_ </span>=&gt; {}
                    }
                }

                <span class="kw">_ </span>=&gt; {}
            }
        }

        <span class="kw">if </span>fields.iter().any(|f| f.abi.is_uninhabited()) {
            <a href="#464">abi</a> = Abi::Uninhabited;
        }

        <span class="prelude-val">Ok</span>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
            variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
            fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { <a href="#393">offsets</a>, <a href="#460">memory_index</a> },
            <a href="#464">abi</a>,
            <a href="#395">largest_niche</a>,
            <a href="#337">align</a>,
            <a href="#463">size</a>,
        })
    }

    <span class="kw">fn </span>layout_of_uncached(<span class="kw-2">&amp;</span><span class="self">self</span>, ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;Layout&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <span class="kw">let </span>tcx = <a class="self" href="#543">self</a>.tcx;
        <span class="kw">let </span>param_env = <a class="self" href="#543">self</a>.param_env;
        <span class="kw">let </span>dl = <a class="self" href="#543">self</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>();
        <span class="kw">let </span>scalar_unit = |value: <a href="../../../rustc_target/abi/enum.Primitive.html">Primitive</a>| {
            <span class="kw">let </span>size = <a href="#547">value</a>.size(<a href="#546">dl</a>);
            <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(size.bits() &lt;= <span class="number">128</span>);
            <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> { <a href="#547">value</a>, valid_range: WrappingRange::full(<a href="#548">size</a>) }
        };
        <span class="kw">let </span>scalar =
            |value: <a href="../../../rustc_target/abi/enum.Primitive.html">Primitive</a>| <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a class="self" href="#543">self</a>, <a href="#547">scalar_unit</a>(<a href="#553">value</a>)));

        <span class="kw">let </span>univariant = |fields: <span class="kw-2">&amp;</span>[TyAndLayout&lt;<span class="lifetime">&#39;_</span>&gt;], repr: <span class="kw-2">&amp;</span><a href="mod.rs.html#1955">ReprOptions</a>, kind| {
            <span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<span class="self">self</span>.univariant_uninterned(ty, fields, repr, kind)<span class="question-mark">?</span>))
        };
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.debug_assert.html">debug_assert!</a>(!ty.has_infer_types_or_consts());

        <span class="prelude-val">Ok</span>(<span class="kw">match </span><span class="kw-2">*</span><a href="#543">ty</a>.<a href="sty.rs.html#1639">kind</a>() {
            <span class="comment">// Basic scalars.
            </span>ty::Bool =&gt; <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(
                <a class="self" href="#543">self</a>,
                <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> {
                    value: Int(I8, <span class="bool-val">false</span>),
                    valid_range: <a href="../../../rustc_target/abi/struct.WrappingRange.html">WrappingRange</a> { start: <span class="number">0</span>, end: <span class="number">1 </span>},
                },
            )),
            ty::Char =&gt; <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(
                <a class="self" href="#543">self</a>,
                <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> {
                    value: Int(I32, <span class="bool-val">false</span>),
                    valid_range: <a href="../../../rustc_target/abi/struct.WrappingRange.html">WrappingRange</a> { start: <span class="number">0</span>, end: <span class="number">0x10FFFF </span>},
                },
            )),
            ty::Int(ity) =&gt; <a href="#552">scalar</a>(Int(Integer::from_int_ty(<a href="#546">dl</a>, <a href="#576">ity</a>), <span class="bool-val">true</span>)),
            ty::Uint(ity) =&gt; <a href="#552">scalar</a>(Int(Integer::from_uint_ty(<a href="#546">dl</a>, <a href="#577">ity</a>), <span class="bool-val">false</span>)),
            ty::Float(fty) =&gt; <a href="#552">scalar</a>(<span class="kw">match </span><a href="#578">fty</a> {
                ty::FloatTy::F32 =&gt; F32,
                ty::FloatTy::F64 =&gt; F64,
            }),
            ty::FnPtr(<span class="kw">_</span>) =&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>ptr = <a href="#547">scalar_unit</a>(Pointer);
                <a href="#583">ptr</a>.valid_range_mut().start = <span class="number">1</span>;
                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a class="self" href="#543">self</a>, <a href="#583">ptr</a>))
            }

            <span class="comment">// The never type.
            </span>ty::Never =&gt; <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
                fields: FieldsShape::Primitive,
                abi: Abi::Uninhabited,
                largest_niche: <span class="prelude-val">None</span>,
                align: <a href="#546">dl</a>.i8_align,
                size: Size::ZERO,
            }),

            <span class="comment">// Potentially-wide pointers.
            </span>ty::Ref(<span class="kw">_</span>, pointee, <span class="kw">_</span>) | ty::RawPtr(<a href="sty.rs.html#43">ty::TypeAndMut</a> { ty: pointee, .. }) =&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>data_ptr = <a href="#547">scalar_unit</a>(Pointer);
                <span class="kw">if </span>!ty.is_unsafe_ptr() {
                    <a href="#600">data_ptr</a>.valid_range_mut().start = <span class="number">1</span>;
                }

                <span class="kw">let </span>pointee = <a href="#544">tcx</a>.<a href="normalize_erasing_regions.rs.html#40-42">normalize_erasing_regions</a>(<a href="#545">param_env</a>, <a href="#599">pointee</a>);
                <span class="kw">if </span>pointee.is_sized(tcx.at(DUMMY_SP), param_env) {
                    <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a class="self" href="#543">self</a>, <a href="#600">data_ptr</a>)));
                }

                <span class="kw">let </span>unsized_part = <a href="#544">tcx</a>.<a href="util.rs.html#215-219">struct_tail_erasing_lifetimes</a>(<a href="#605">pointee</a>, <a href="#545">param_env</a>);
                <span class="kw">let </span>metadata = <span class="kw">match </span><a href="#610">unsized_part</a>.<a href="sty.rs.html#1639">kind</a>() {
                    ty::Foreign(..) =&gt; {
                        <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a class="self" href="#543">self</a>, <a href="#600">data_ptr</a>)));
                    }
                    ty::Slice(<span class="kw">_</span>) | ty::Str =&gt; <a href="#547">scalar_unit</a>(Int(<a href="#546">dl</a>.ptr_sized_integer(), <span class="bool-val">false</span>)),
                    ty::Dynamic(..) =&gt; {
                        <span class="kw">let </span><span class="kw-2">mut </span>vtable = <a href="#547">scalar_unit</a>(Pointer);
                        <a href="#617">vtable</a>.valid_range_mut().start = <span class="number">1</span>;
                        <a href="#617">vtable</a>
                    }
                    <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#610">unsized_part</a>)),
                };

                <span class="comment">// Effectively a (ptr, meta) tuple.
                </span><a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a class="self" href="#543">self</a>.<a href="#296">scalar_pair</a>(<a href="#600">data_ptr</a>, <a href="#611">metadata</a>))
            }

            ty::Dynamic(<span class="kw">_</span>, <span class="kw">_</span>, ty::DynStar) =&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>data = <a href="#547">scalar_unit</a>(Int(<a href="#546">dl</a>.ptr_sized_integer(), <span class="bool-val">false</span>));
                <a href="#629">data</a>.valid_range_mut().start = <span class="number">0</span>;
                <span class="kw">let </span><span class="kw-2">mut </span>vtable = <a href="#547">scalar_unit</a>(Pointer);
                <a href="#631">vtable</a>.valid_range_mut().start = <span class="number">1</span>;
                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a class="self" href="#543">self</a>.<a href="#296">scalar_pair</a>(<a href="#629">data</a>, <a href="#631">vtable</a>))
            }

            <span class="comment">// Arrays and slices.
            </span>ty::Array(element, <span class="kw-2">mut </span>count) =&gt; {
                <span class="kw">if </span>count.has_projections() {
                    <a href="#637">count</a> = <a href="#544">tcx</a>.<a href="normalize_erasing_regions.rs.html#40-42">normalize_erasing_regions</a>(<a href="#545">param_env</a>, <a href="#637">count</a>);
                    <span class="kw">if </span>count.has_projections() {
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
                    }
                }

                <span class="kw">let </span>count = count.try_eval_usize(tcx, param_env).ok_or(LayoutError::Unknown(ty))<span class="question-mark">?</span>;
                <span class="kw">let </span>element = <span class="self">self</span>.layout_of(element)<span class="question-mark">?</span>;
                <span class="kw">let </span>size =
                    element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow(ty))<span class="question-mark">?</span>;

                <span class="kw">let </span>abi =
                    <span class="kw">if </span>count != <span class="number">0 </span>&amp;&amp; tcx.conservative_is_privately_uninhabited(param_env.and(ty)) {
                        Abi::Uninhabited
                    } <span class="kw">else </span>{
                        <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>}
                    };

                <span class="kw">let </span>largest_niche = <span class="kw">if </span>count != <span class="number">0 </span>{ <a href="#646">element</a>.largest_niche } <span class="kw">else </span>{ <span class="prelude-val">None </span>};

                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                    variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
                    fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Array</a> { stride: <a href="#646">element</a>.size, <a href="#645">count</a> },
                    <a href="#650">abi</a>,
                    <a href="#657">largest_niche</a>,
                    align: <a href="#646">element</a>.align,
                    <a href="#647">size</a>,
                })
            }
            ty::Slice(element) =&gt; {
                <span class="kw">let </span>element = <span class="self">self</span>.layout_of(element)<span class="question-mark">?</span>;
                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                    variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
                    fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Array</a> { stride: <a href="#669">element</a>.size, count: <span class="number">0 </span>},
                    abi: <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">false </span>},
                    largest_niche: <span class="prelude-val">None</span>,
                    align: <a href="#669">element</a>.align,
                    size: Size::ZERO,
                })
            }
            ty::Str =&gt; <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
                fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Array</a> { stride: Size::from_bytes(<span class="number">1</span>), count: <span class="number">0 </span>},
                abi: <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">false </span>},
                largest_niche: <span class="prelude-val">None</span>,
                align: <a href="#546">dl</a>.i8_align,
                size: Size::ZERO,
            }),

            <span class="comment">// Odd unit types.
            </span>ty::FnDef(..) =&gt; univariant(<span class="kw-2">&amp;</span>[], <span class="kw-2">&amp;</span>ReprOptions::default(), StructKind::AlwaysSized)<span class="question-mark">?</span>,
            ty::Dynamic(<span class="kw">_</span>, <span class="kw">_</span>, ty::Dyn) | ty::Foreign(..) =&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>unit = <span class="self">self</span>.univariant_uninterned(
                    ty,
                    <span class="kw-2">&amp;</span>[],
                    <span class="kw-2">&amp;</span>ReprOptions::default(),
                    StructKind::AlwaysSized,
                )<span class="question-mark">?</span>;
                <span class="kw">match </span><a href="#691">unit</a>.abi {
                    <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { <span class="kw-2">ref mut </span>sized } =&gt; <span class="kw-2">*</span><a href="#698">sized</a> = <span class="bool-val">false</span>,
                    <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
                }
                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="#691">unit</a>)
            }

            ty::Generator(def_id, substs, <span class="kw">_</span>) =&gt; <span class="self">self</span>.generator_layout(ty, def_id, substs)<span class="question-mark">?</span>,

            ty::Closure(<span class="kw">_</span>, <span class="kw-2">ref </span>substs) =&gt; {
                <span class="kw">let </span>tys = <a href="#706">substs</a>.<a href="subst.rs.html#259">as_closure</a>().<a href="sty.rs.html#279">upvar_tys</a>();
                univariant(
                    <span class="kw-2">&amp;</span>tys.map(|ty| <span class="self">self</span>.layout_of(ty)).collect::&lt;<span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>,
                    <span class="kw-2">&amp;</span>ReprOptions::default(),
                    StructKind::AlwaysSized,
                )<span class="question-mark">?
            </span>}

            ty::Tuple(tys) =&gt; {
                <span class="kw">let </span>kind =
                    <span class="kw">if </span>tys.len() == <span class="number">0 </span>{ <a href="#275">StructKind::AlwaysSized</a> } <span class="kw">else </span>{ <a href="#277">StructKind::MaybeUnsized</a> };

                univariant(
                    <span class="kw-2">&amp;</span>tys.iter().map(|k| <span class="self">self</span>.layout_of(k)).collect::&lt;<span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>,
                    <span class="kw-2">&amp;</span>ReprOptions::default(),
                    kind,
                )<span class="question-mark">?
            </span>}

            <span class="comment">// SIMD vector types.
            </span>ty::Adt(def, substs) <span class="kw">if </span><a href="#727">def</a>.<a href="adt.rs.html#191">repr</a>().<a href="mod.rs.html#2030">simd</a>() =&gt; {
                <span class="kw">if </span>!def.is_struct() {
                    <span class="comment">// Should have yielded E0517 by now.
                    </span><a href="#544">tcx</a>.sess.delay_span_bug(
                        <a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>,
                        <span class="string">&quot;#[repr(simd)] was applied to an ADT that is not a struct&quot;</span>,
                    );
                    <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
                }

                <span class="comment">// Supported SIMD vectors are homogeneous ADTs with at least one field:
                //
                // * #[repr(simd)] struct S(T, T, T, T);
                // * #[repr(simd)] struct S { x: T, y: T, z: T, w: T }
                // * #[repr(simd)] struct S([T; 4])
                //
                // where T is a primitive scalar (integer/float/pointer).

                // SIMD vectors with zero fields are not supported.
                // (should be caught by typeck)
                </span><span class="kw">if </span>def.non_enum_variant().fields.is_empty() {
                    <a href="#544">tcx</a>.sess.fatal(<span class="kw-2">&amp;</span><a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(<span class="string">&quot;monomorphising SIMD type `{}` of zero length&quot;</span>, ty));
                }

                <span class="comment">// Type of the first ADT field:
                </span><span class="kw">let </span>f0_ty = <a href="#727">def</a>.<a href="adt.rs.html#363">non_enum_variant</a>().fields[<span class="number">0</span>].<a href="mod.rs.html#2095">ty</a>(<a href="#544">tcx</a>, <a href="#727">substs</a>);

                <span class="comment">// Heterogeneous SIMD vectors are not supported:
                // (should be caught by typeck)
                </span><span class="kw">for </span>fi <span class="kw">in </span><span class="kw-2">&amp;</span>def.non_enum_variant().fields {
                    <span class="kw">if </span>fi.ty(tcx, substs) != f0_ty {
                        tcx.sess.fatal(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;monomorphising heterogeneous SIMD type `{}`&quot;</span>, ty));
                    }
                }

                <span class="comment">// The element type and number of elements of the SIMD vector
                // are obtained from:
                //
                // * the element type and length of the single array field, if
                // the first field is of array type, or
                //
                // * the homogeneous field type and the number of fields.
                </span><span class="kw">let </span>(e_ty, e_len, is_array) = <span class="kw">if let </span>ty::Array(e_ty, <span class="kw">_</span>) = <a href="#752">f0_ty</a>.<a href="sty.rs.html#1639">kind</a>() {
                    <span class="comment">// First ADT field is an array:

                    // SIMD vectors with multiple array fields are not supported:
                    // (should be caught by typeck)
                    </span><span class="kw">if </span>def.non_enum_variant().fields.len() != <span class="number">1 </span>{
                        <a href="#544">tcx</a>.sess.fatal(<span class="kw-2">&amp;</span><a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(
                            <span class="string">&quot;monomorphising SIMD type `{}` with more than one array field&quot;</span>,
                            ty
                        ));
                    }

                    <span class="comment">// Extract the number of elements from the layout of the array field:
                    </span><span class="kw">let </span><a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Array</a> { count, .. } = <span class="self">self</span>.layout_of(f0_ty)<span class="question-mark">?</span>.layout.fields() <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
                    };

                    (<span class="kw-2">*</span><a href="#769">e_ty</a>, <span class="kw-2">*</span><a href="#782">count</a>, <span class="bool-val">true</span>)
                } <span class="kw">else </span>{
                    <span class="comment">// First ADT field is not an array:
                    </span>(<a href="#752">f0_ty</a>, <a href="#727">def</a>.<a href="adt.rs.html#363">non_enum_variant</a>().fields.len() <span class="kw">as _</span>, <span class="bool-val">false</span>)
                };

                <span class="comment">// SIMD vectors of zero length are not supported.
                // Additionally, lengths are capped at 2^16 as a fixed maximum backends must
                // support.
                //
                // Can&#39;t be caught in typeck if the array length is generic.
                </span><span class="kw">if </span>e_len == <span class="number">0 </span>{
                    <a href="#544">tcx</a>.sess.fatal(<span class="kw-2">&amp;</span><a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(<span class="string">&quot;monomorphising SIMD type `{}` of zero length&quot;</span>, ty));
                } <span class="kw">else if </span>e_len &gt; MAX_SIMD_LANES {
                    <a href="#544">tcx</a>.sess.fatal(<span class="kw-2">&amp;</span><a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(
                        <span class="string">&quot;monomorphising SIMD type `{}` of length greater than {}&quot;</span>,
                        ty, MAX_SIMD_LANES,
                    ));
                }

                <span class="comment">// Compute the ABI of the element type:
                </span><span class="kw">let </span>e_ly = <span class="self">self</span>.layout_of(e_ty)<span class="question-mark">?</span>;
                <span class="kw">let </span>Abi::Scalar(e_abi) = <a href="#807">e_ly</a>.abi <span class="kw">else </span>{
                    <span class="comment">// This error isn&#39;t caught in typeck, e.g., if
                    // the element type of the vector is generic.
                    </span><a href="#544">tcx</a>.sess.fatal(<span class="kw-2">&amp;</span><a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(
                        <span class="string">&quot;monomorphising SIMD type `{}` with a non-primitive-scalar \
                        (integer/float/pointer) element type `{}`&quot;</span>,
                        ty, e_ty
                    ))
                };

                <span class="comment">// Compute the size and alignment of the vector:
                </span><span class="kw">let </span>size = e_ly.size.checked_mul(e_len, dl).ok_or(LayoutError::SizeOverflow(ty))<span class="question-mark">?</span>;
                <span class="kw">let </span>align = <a href="#546">dl</a>.vector_align(<a href="#819">size</a>);
                <span class="kw">let </span>size = <a href="#819">size</a>.align_to(<a href="#820">align</a>.abi);

                <span class="comment">// Compute the placement of the vector fields:
                </span><span class="kw">let </span>fields = <span class="kw">if </span>is_array {
                    <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { offsets: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[Size::ZERO], memory_index: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[<span class="number">0</span>] }
                } <span class="kw">else </span>{
                    <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Array</a> { stride: <a href="#807">e_ly</a>.size, count: <a href="#769">e_len</a> }
                };

                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                    variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: VariantIdx::new(<span class="number">0</span>) },
                    <a href="#824">fields</a>,
                    abi: <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Vector</a> { element: <a href="#808">e_abi</a>, count: <a href="#769">e_len</a> },
                    largest_niche: <a href="#807">e_ly</a>.largest_niche,
                    <a href="#821">size</a>,
                    <a href="#820">align</a>,
                })
            }

            <span class="comment">// ADTs.
            </span>ty::Adt(def, substs) =&gt; {
                <span class="comment">// Cache the field layouts.
                </span><span class="kw">let </span>variants = def
                    .variants()
                    .iter()
                    .map(|v| {
                        v.fields
                            .iter()
                            .map(|field| <span class="self">self</span>.layout_of(field.ty(tcx, substs)))
                            .collect::&lt;<span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()
                    })
                    .collect::&lt;<span class="prelude-ty">Result</span>&lt;IndexVec&lt;VariantIdx, <span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>;

                <span class="kw">if </span>def.is_union() {
                    <span class="kw">if </span>def.repr().pack.is_some() &amp;&amp; def.repr().align.is_some() {
                        <a class="self" href="#543">self</a>.tcx.sess.delay_span_bug(
                            <a href="#544">tcx</a>.<a href="query.rs.html#337">def_span</a>(<a href="#841">def</a>.<a href="adt.rs.html#171">did</a>()),
                            <span class="string">&quot;union cannot be packed and aligned&quot;</span>,
                        );
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
                    }

                    <span class="kw">let </span><span class="kw-2">mut </span>align =
                        <span class="kw">if </span>def.repr().pack.is_some() { <a href="#546">dl</a>.i8_align } <span class="kw">else </span>{ <a href="#546">dl</a>.aggregate_align };

                    <span class="kw">if let </span><span class="prelude-val">Some</span>(repr_align) = <a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().align {
                        <a href="#863">align</a> = <a href="#863">align</a>.max(AbiAndPrefAlign::new(<a href="#866">repr_align</a>));
                    }

                    <span class="kw">let </span>optimize = !<a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().<a href="mod.rs.html#2087">inhibit_union_abi_opt</a>();
                    <span class="kw">let </span><span class="kw-2">mut </span>size = Size::ZERO;
                    <span class="kw">let </span><span class="kw-2">mut </span>abi = <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>};
                    <span class="kw">let </span>index = VariantIdx::new(<span class="number">0</span>);
                    <span class="kw">for </span>field <span class="kw">in </span><span class="kw-2">&amp;</span>variants[index] {
                        <span class="macro">assert!</span>(!field.is_unsized());
                        align = align.max(field.align);

                        <span class="comment">// If all non-ZST fields have the same ABI, forward this ABI
                        </span><span class="kw">if </span>optimize &amp;&amp; !field.is_zst() {
                            <span class="comment">// Discard valid range information and allow undef
                            </span><span class="kw">let </span>field_abi = <span class="kw">match </span>field.abi {
                                Abi::Scalar(x) =&gt; Abi::Scalar(x.to_union()),
                                Abi::ScalarPair(x, y) =&gt; {
                                    Abi::ScalarPair(x.to_union(), y.to_union())
                                }
                                Abi::Vector { element: x, count } =&gt; {
                                    Abi::Vector { element: x.to_union(), count }
                                }
                                Abi::Uninhabited | Abi::Aggregate { .. } =&gt; {
                                    Abi::Aggregate { sized: <span class="bool-val">true </span>}
                                }
                            };

                            <span class="kw">if </span>size == Size::ZERO {
                                <span class="comment">// first non ZST: initialize &#39;abi&#39;
                                </span>abi = field_abi;
                            } <span class="kw">else if </span>abi != field_abi {
                                <span class="comment">// different fields have different ABI: reset to Aggregate
                                </span>abi = Abi::Aggregate { sized: <span class="bool-val">true </span>};
                            }
                        }

                        size = cmp::max(size, field.size);
                    }

                    <span class="kw">if let </span><span class="prelude-val">Some</span>(pack) = <a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().pack {
                        <a href="#863">align</a> = <a href="#863">align</a>.min(AbiAndPrefAlign::new(<a href="#906">pack</a>));
                    }

                    <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                        variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { <a href="#873">index</a> },
                        fields: FieldsShape::Union(
                            NonZeroUsize::new(variants[index].len())
                                .ok_or(LayoutError::Unknown(ty))<span class="question-mark">?</span>,
                        ),
                        <a href="#872">abi</a>,
                        largest_niche: <span class="prelude-val">None</span>,
                        <a href="#863">align</a>,
                        size: <a href="#871">size</a>.align_to(<a href="#863">align</a>.abi),
                    }));
                }

                <span class="comment">// A variant is absent if it&#39;s uninhabited and only has ZST fields.
                // Present uninhabited variants only require space for their fields,
                // but *not* an encoding of the discriminant (e.g., a tag value).
                // See issue #49298 for more details on the need to leave space
                // for non-ZST uninhabited data (mostly partial initialization).
                </span><span class="kw">let </span>absent = |fields: <span class="kw-2">&amp;</span>[TyAndLayout&lt;<span class="lifetime">&#39;_</span>&gt;]| {
                    <span class="kw">let </span>uninhabited = <a href="#928">fields</a>.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">any</a>(|f| <a href="#929">f</a>.abi.is_uninhabited());
                    <span class="kw">let </span>is_zst = <a href="#928">fields</a>.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">all</a>(|f| <a href="#930">f</a>.is_zst());
                    <a href="#929">uninhabited</a> &amp;&amp; <a href="#930">is_zst</a>
                };
                <span class="kw">let </span>(present_first, present_second) = {
                    <span class="kw">let </span><span class="kw-2">mut </span>present_variants = <a href="#843">variants</a>
                        .iter_enumerated()
                        .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">filter_map</a>(|(i, v)| <span class="kw">if </span>absent(v) { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some</span>(<a href="#936">i</a>) });
                    (<a href="#934">present_variants</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">next</a>(), <a href="#934">present_variants</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">next</a>())
                };
                <span class="kw">let </span>present_first = <span class="kw">match </span><a href="#933">present_first</a> {
                    <span class="prelude-val">Some</span>(present_first) =&gt; <a href="#940">present_first</a>,
                    <span class="comment">// Uninhabited because it has no variants, or only absent ones.
                    </span><span class="prelude-val">None </span><span class="kw">if </span><a href="#841">def</a>.<a href="adt.rs.html#275">is_enum</a>() =&gt; {
                        <span class="kw">return </span><span class="prelude-val">Ok</span>(tcx.layout_of(param_env.and(tcx.types.never))<span class="question-mark">?</span>.layout);
                    }
                    <span class="comment">// If it&#39;s a struct, still compute a layout so that we can still compute the
                    // field offsets.
                    </span><span class="prelude-val">None </span>=&gt; VariantIdx::new(<span class="number">0</span>),
                };

                <span class="kw">let </span>is_struct = !<a href="#841">def</a>.<a href="adt.rs.html#275">is_enum</a>() ||
                    <span class="comment">// Only one variant is present.
                    </span>(<a href="#933">present_second</a>.is_none() &amp;&amp;
                    <span class="comment">// Representation optimizations are allowed.
                    </span>!<a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().<a href="mod.rs.html#2063">inhibit_enum_layout_opt</a>());
                <span class="kw">if </span>is_struct {
                    <span class="comment">// Struct, or univariant enum equivalent to a struct.
                    // (Typechecking will reject discriminant-sizing attrs.)

                    </span><span class="kw">let </span>v = <a href="#939">present_first</a>;
                    <span class="kw">let </span>kind = <span class="kw">if </span>def.is_enum() || variants[v].is_empty() {
                        <a href="#275">StructKind::AlwaysSized</a>
                    } <span class="kw">else </span>{
                        <span class="kw">let </span>param_env = <a href="#544">tcx</a>.<a href="query.rs.html#337">param_env</a>(<a href="#841">def</a>.<a href="adt.rs.html#171">did</a>());
                        <span class="kw">let </span>last_field = <a href="#841">def</a>.<a href="adt.rs.html#181">variant</a>(<a href="#959">v</a>).fields.last().unwrap();
                        <span class="kw">let </span>always_sized =
                            <a href="#544">tcx</a>.<a href="query.rs.html#337">type_of</a>(<a href="#964">last_field</a>.did).<a href="util.rs.html#838">is_sized</a>(<a href="#544">tcx</a>.<a href="query.rs.html#98">at</a>(<a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>), <a href="#963">param_env</a>);
                        <span class="kw">if </span>!always_sized {
                            <a href="#277">StructKind::MaybeUnsized</a>
                        } <span class="kw">else </span>{
                            <a href="#275">StructKind::AlwaysSized</a>
                        }
                    };

                    <span class="kw">let </span><span class="kw-2">mut </span>st = <span class="self">self</span>.univariant_uninterned(ty, <span class="kw-2">&amp;</span>variants[v], <span class="kw-2">&amp;</span>def.repr(), kind)<span class="question-mark">?</span>;
                    <a href="#974">st</a>.variants = <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: <a href="#959">v</a> };

                    <span class="kw">if </span>def.is_unsafe_cell() {
                        <span class="kw">let </span>hide_niches = |scalar: <span class="kw-2">&amp;mut </span><span class="kw">_</span>| <span class="kw">match </span><a href="#978">scalar</a> {
                            <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> { value, valid_range } =&gt; {
                                <span class="kw-2">*</span><a href="#979">valid_range</a> = WrappingRange::full(<a href="#979">value</a>.size(<a href="#546">dl</a>))
                            }
                            <span class="comment">// Already doesn&#39;t have any niches
                            </span><a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Union</a> { .. } =&gt; {}
                        };
                        <span class="kw">match </span><span class="kw-2">&amp;mut </span><a href="#974">st</a>.abi {
                            Abi::Uninhabited =&gt; {}
                            Abi::Scalar(scalar) =&gt; <a href="#978">hide_niches</a>(<a href="#987">scalar</a>),
                            Abi::ScalarPair(a, b) =&gt; {
                                <a href="#978">hide_niches</a>(<a href="#988">a</a>);
                                <a href="#978">hide_niches</a>(<a href="#988">b</a>);
                            }
                            <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Vector</a> { element, count: <span class="kw">_ </span>} =&gt; <a href="#978">hide_niches</a>(<a href="#992">element</a>),
                            <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="kw">_ </span>} =&gt; {}
                        }
                        <a href="#974">st</a>.largest_niche = <span class="prelude-val">None</span>;
                        <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="#974">st</a>));
                    }

                    <span class="kw">let </span>(start, end) = <a class="self" href="#543">self</a>.tcx.<a href="context.rs.html#1195">layout_scalar_valid_range</a>(<a href="#841">def</a>.<a href="adt.rs.html#171">did</a>());
                    <span class="kw">match </span><a href="#974">st</a>.abi {
                        Abi::Scalar(<span class="kw-2">ref mut </span>scalar) | Abi::ScalarPair(<span class="kw-2">ref mut </span>scalar, <span class="kw">_</span>) =&gt; {
                            <span class="comment">// the asserts ensure that we are not using the
                            // `#[rustc_layout_scalar_valid_range(n)]`
                            // attribute to widen the range of anything as that would probably
                            // result in UB somewhere
                            // FIXME(eddyb) the asserts are probably not needed,
                            // as larger validity ranges would result in missed
                            // optimizations, *not* wrongly assuming the inner
                            // value is valid. e.g. unions enlarge validity ranges,
                            // because the values may be uninitialized.
                            </span><span class="kw">if let </span>Bound::Included(start) = <a href="#999">start</a> {
                                <span class="comment">// FIXME(eddyb) this might be incorrect - it doesn&#39;t
                                // account for wrap-around (end &lt; start) ranges.
                                </span><span class="kw">let </span>valid_range = <a href="#1001">scalar</a>.valid_range_mut();
                                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(valid_range.start &lt;= start);
                                <a href="#1014">valid_range</a>.start = <a href="#1011">start</a>;
                            }
                            <span class="kw">if let </span>Bound::Included(end) = <a href="#999">end</a> {
                                <span class="comment">// FIXME(eddyb) this might be incorrect - it doesn&#39;t
                                // account for wrap-around (end &lt; start) ranges.
                                </span><span class="kw">let </span>valid_range = <a href="#1001">scalar</a>.valid_range_mut();
                                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(valid_range.end &gt;= end);
                                <a href="#1021">valid_range</a>.end = <a href="#1018">end</a>;
                            }

                            <span class="comment">// Update `largest_niche` if we have introduced a larger niche.
                            </span><span class="kw">let </span>niche = Niche::from_scalar(<a href="#546">dl</a>, Size::ZERO, <span class="kw-2">*</span><a href="#1001">scalar</a>);
                            <span class="kw">if let </span><span class="prelude-val">Some</span>(niche) = <a href="#1027">niche</a> {
                                <span class="kw">match </span><a href="#974">st</a>.largest_niche {
                                    <span class="prelude-val">Some</span>(largest_niche) =&gt; {
                                        <span class="comment">// Replace the existing niche even if they&#39;re equal,
                                        // because this one is at a lower offset.
                                        </span><span class="kw">if </span>largest_niche.available(dl) &lt;= niche.available(dl) {
                                            <a href="#974">st</a>.largest_niche = <span class="prelude-val">Some</span>(<a href="#1028">niche</a>);
                                        }
                                    }
                                    <span class="prelude-val">None </span>=&gt; <a href="#974">st</a>.largest_niche = <span class="prelude-val">Some</span>(<a href="#1028">niche</a>),
                                }
                            }
                        }
                        <span class="kw">_ </span>=&gt; <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(
                            start == Bound::Unbounded &amp;&amp; end == Bound::Unbounded,
                            <span class="string">&quot;nonscalar layout for layout_scalar_valid_range type {:?}: {:#?}&quot;</span>,
                            def,
                            st,
                        ),
                    }

                    <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="#974">st</a>));
                }

                <span class="comment">// At this point, we have handled all unions and
                // structs. (We have also handled univariant enums
                // that allow representation optimization.)
                </span><a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(def.is_enum());

                <span class="comment">// Until we&#39;ve decided whether to use the tagged or
                // niche filling LayoutS, we don&#39;t want to intern the
                // variant layouts, so we can&#39;t store them in the
                // overall LayoutS. Store the overall LayoutS
                // and the variant LayoutSs here until then.
                </span><span class="kw">struct </span>TmpLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
                    layout: LayoutS&lt;<span class="lifetime">&#39;tcx</span>&gt;,
                    variants: IndexVec&lt;<a href="../../../rustc_target/abi/struct.VariantIdx.html">VariantIdx</a>, LayoutS&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
                }

                <span class="kw">let </span>calculate_niche_filling_layout =
                    || -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;TmpLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
                        <span class="comment">// The current code for niche-filling relies on variant indices
                        // instead of actual discriminants, so enums with
                        // explicit discriminants (RFC #2363) would misbehave.
                        </span><span class="kw">if </span>def.repr().inhibit_enum_layout_opt()
                            || def
                                .variants()
                                .iter_enumerated()
                                .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))
                        {
                            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>);
                        }

                        <span class="kw">if </span>variants.len() &lt; <span class="number">2 </span>{
                            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>);
                        }

                        <span class="kw">let </span><span class="kw-2">mut </span>align = <a href="#546">dl</a>.aggregate_align;
                        <span class="kw">let </span><span class="kw-2">mut </span>variant_layouts = variants
                            .iter_enumerated()
                            .map(|(j, v)| {
                                <span class="kw">let </span><span class="kw-2">mut </span>st = <span class="self">self</span>.univariant_uninterned(
                                    ty,
                                    v,
                                    <span class="kw-2">&amp;</span>def.repr(),
                                    StructKind::AlwaysSized,
                                )<span class="question-mark">?</span>;
                                st.variants = Variants::Single { index: j };

                                align = align.max(st.align);

                                <span class="prelude-val">Ok</span>(st)
                            })
                            .collect::&lt;<span class="prelude-ty">Result</span>&lt;IndexVec&lt;VariantIdx, <span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>;

                        <span class="kw">let </span>largest_variant_index = <span class="kw">match </span><a href="#1086">variant_layouts</a>
                            .iter_enumerated()
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">max_by_key</a>(|(_i, layout)| <a href="#1105">layout</a>.size.bytes())
                            .map(|(i, _layout)| <a href="#1106">i</a>)
                        {
                            <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>),
                            <span class="prelude-val">Some</span>(i) =&gt; <a href="#1109">i</a>,
                        };

                        <span class="kw">let </span>all_indices = VariantIdx::new(<span class="number">0</span>)..=VariantIdx::new(<a href="#843">variants</a>.len() - <span class="number">1</span>);
                        <span class="kw">let </span>needs_disc = |index: <a href="../../../rustc_target/abi/struct.VariantIdx.html">VariantIdx</a>| {
                            <a href="#1113">index</a> != <a href="#1103">largest_variant_index</a> &amp;&amp; !<a href="#928">absent</a>(<span class="kw-2">&amp;</span><a href="#843">variants</a>[<a href="#1113">index</a>])
                        };
                        <span class="kw">let </span>niche_variants = <a href="#1112">all_indices</a>.<a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">clone</a>().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">find</a>(|v| <a href="#1113">needs_disc</a>(<span class="kw-2">*</span><a href="#1116">v</a>)).unwrap()
                            ..=<a href="#1112">all_indices</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">rev</a>().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">find</a>(|v| <a href="#1113">needs_disc</a>(<span class="kw-2">*</span><a href="#1117">v</a>)).unwrap();

                        <span class="kw">let </span>count = <a href="#1116">niche_variants</a>.<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">size_hint</a>().<span class="number">1</span>.unwrap() <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a>;

                        <span class="comment">// Find the field with the largest niche
                        </span><span class="kw">let </span>(field_index, niche, (niche_start, niche_scalar)) = <span class="kw">match </span><a href="#843">variants</a>
                            [<a href="#1103">largest_variant_index</a>]
                            .iter()
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">enumerate</a>()
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">filter_map</a>(|(j, field)| <span class="prelude-val">Some</span>((<a href="#1126">j</a>, field.largest_niche<span class="question-mark">?</span>)))
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">max_by_key</a>(|(<span class="kw">_</span>, niche)| <a href="#1127">niche</a>.available(<a href="#546">dl</a>))
                            .and_then(|(j, niche)| <span class="prelude-val">Some</span>((<a href="#1128">j</a>, <a href="#1128">niche</a>, niche.reserve(<span class="self">self</span>, count)<span class="question-mark">?</span>)))
                        {
                            <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>),
                            <span class="prelude-val">Some</span>(x) =&gt; <a href="#1131">x</a>,
                        };

                        <span class="kw">let </span>niche_offset = <a href="#1122">niche</a>.offset
                            + <a href="#1086">variant_layouts</a>[<a href="#1103">largest_variant_index</a>].fields.offset(<a href="#1122">field_index</a>);
                        <span class="kw">let </span>niche_size = <a href="#1122">niche</a>.value.size(<a href="#546">dl</a>);
                        <span class="kw">let </span>size = <a href="#1086">variant_layouts</a>[<a href="#1103">largest_variant_index</a>].size.align_to(<a href="#1085">align</a>.abi);

                        <span class="kw">let </span>all_variants_fit =
                            <a href="#1086">variant_layouts</a>.iter_enumerated_mut().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">all</a>(|(i, layout)| {
                                <span class="kw">if </span>i == largest_variant_index {
                                    <span class="kw">return </span><span class="bool-val">true</span>;
                                }

                                <a href="#1140">layout</a>.largest_niche = <span class="prelude-val">None</span>;

                                <span class="kw">if </span>layout.size &lt;= niche_offset {
                                    <span class="comment">// This variant will fit before the niche.
                                    </span><span class="kw">return </span><span class="bool-val">true</span>;
                                }

                                <span class="comment">// Determine if it&#39;ll fit after the niche.
                                </span><span class="kw">let </span>this_align = <a href="#1140">layout</a>.align.abi;
                                <span class="kw">let </span>this_offset = (<a href="#1134">niche_offset</a> + <a href="#1136">niche_size</a>).align_to(<a href="#1153">this_align</a>);

                                <span class="kw">if </span>this_offset + layout.size &gt; size {
                                    <span class="kw">return </span><span class="bool-val">false</span>;
                                }

                                <span class="comment">// It&#39;ll fit, but we need to make some adjustments.
                                </span><span class="kw">match </span><a href="#1140">layout</a>.fields {
                                    <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { <span class="kw-2">ref mut </span>offsets, .. } =&gt; {
                                        <span class="kw">for </span>(j, offset) <span class="kw">in </span>offsets.iter_mut().enumerate() {
                                            <span class="kw">if </span>!variants[i][j].is_zst() {
                                                <span class="kw-2">*</span>offset += this_offset;
                                            }
                                        }
                                    }
                                    <span class="kw">_ </span>=&gt; {
                                        <a class="macro" href="https://doc.rust-lang.org/nightly/std/macro.panic.html">panic!</a>(<span class="string">&quot;Layout of fields should be Arbitrary for variants&quot;</span>)
                                    }
                                }

                                <span class="comment">// It can&#39;t be a Scalar or ScalarPair because the offset isn&#39;t 0.
                                </span><span class="kw">if </span>!layout.abi.is_uninhabited() {
                                    <a href="#1140">layout</a>.abi = <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>};
                                }
                                <a href="#1140">layout</a>.size += <a href="#1154">this_offset</a>;

                                <span class="bool-val">true
                            </span>});

                        <span class="kw">if </span>!all_variants_fit {
                            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>);
                        }

                        <span class="kw">let </span>largest_niche = Niche::from_scalar(<a href="#546">dl</a>, <a href="#1134">niche_offset</a>, <a href="#1122">niche_scalar</a>);

                        <span class="kw">let </span>others_zst = <a href="#1086">variant_layouts</a>.iter_enumerated().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">all</a>(|(i, layout)| {
                            <a href="#1189">i</a> == <a href="#1103">largest_variant_index</a> || <a href="#1189">layout</a>.size == Size::ZERO
                        });
                        <span class="kw">let </span>same_size = <a href="#1137">size</a> == <a href="#1086">variant_layouts</a>[<a href="#1103">largest_variant_index</a>].size;
                        <span class="kw">let </span>same_align = <a href="#1085">align</a> == <a href="#1086">variant_layouts</a>[<a href="#1103">largest_variant_index</a>].align;

                        <span class="kw">let </span>abi = <span class="kw">if </span>variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {
                            Abi::Uninhabited
                        } <span class="kw">else if </span>same_size &amp;&amp; same_align &amp;&amp; others_zst {
                            <span class="kw">match </span><a href="#1086">variant_layouts</a>[<a href="#1103">largest_variant_index</a>].abi {
                                <span class="comment">// When the total alignment and size match, we can use the
                                // same ABI as the scalar variant with the reserved niche.
                                </span>Abi::Scalar(<span class="kw">_</span>) =&gt; Abi::Scalar(<a href="#1122">niche_scalar</a>),
                                Abi::ScalarPair(first, second) =&gt; {
                                    <span class="comment">// Only the niche is guaranteed to be initialised,
                                    // so use union layouts for the other primitive.
                                    </span><span class="kw">if </span>niche_offset == Size::ZERO {
                                        Abi::ScalarPair(<a href="#1122">niche_scalar</a>, <a href="#1202">second</a>.to_union())
                                    } <span class="kw">else </span>{
                                        Abi::ScalarPair(<a href="#1202">first</a>.to_union(), <a href="#1122">niche_scalar</a>)
                                    }
                                }
                                <span class="kw">_ </span>=&gt; <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>},
                            }
                        } <span class="kw">else </span>{
                            <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>}
                        };

                        <span class="kw">let </span>layout = <a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                            variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> {
                                tag: <a href="#1122">niche_scalar</a>,
                                tag_encoding: <a href="../../../rustc_target/abi/enum.TagEncoding.html">TagEncoding::Niche</a> {
                                    untagged_variant: <a href="#1103">largest_variant_index</a>,
                                    <a href="#1116">niche_variants</a>,
                                    <a href="#1122">niche_start</a>,
                                },
                                tag_field: <span class="number">0</span>,
                                variants: IndexVec::new(),
                            },
                            fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> {
                                offsets: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[niche_offset],
                                memory_index: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[<span class="number">0</span>],
                            },
                            <a href="#1195">abi</a>,
                            <a href="#1187">largest_niche</a>,
                            <a href="#1137">size</a>,
                            <a href="#1085">align</a>,
                        };

                        <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<a href="#1062">TmpLayout</a> { <a href="#1217">layout</a>, variants: <a href="#1086">variant_layouts</a> }))
                    };

                <span class="kw">let </span>niche_filling_layout = calculate_niche_filling_layout()<span class="question-mark">?</span>;

                <span class="kw">let </span>(<span class="kw-2">mut </span>min, <span class="kw-2">mut </span>max) = (i128::MAX, i128::MIN);
                <span class="kw">let </span>discr_type = <a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().<a href="mod.rs.html#2056">discr_type</a>();
                <span class="kw">let </span>bits = Integer::from_attr(<a class="self" href="#543">self</a>, <a href="#1244">discr_type</a>).size().bits();
                <span class="kw">for </span>(i, discr) <span class="kw">in </span>def.discriminants(tcx) {
                    <span class="kw">if </span>variants[i].iter().any(|f| f.abi.is_uninhabited()) {
                        <span class="kw">continue</span>;
                    }
                    <span class="kw">let </span><span class="kw-2">mut </span>x = discr.val <span class="kw">as </span>i128;
                    <span class="kw">if </span>discr_type.is_signed() {
                        <span class="comment">// sign extend the raw representation to be an i128
                        </span>x = (x &lt;&lt; (<span class="number">128 </span>- bits)) &gt;&gt; (<span class="number">128 </span>- bits);
                    }
                    <span class="kw">if </span>x &lt; min {
                        min = x;
                    }
                    <span class="kw">if </span>x &gt; max {
                        max = x;
                    }
                }
                <span class="comment">// We might have no inhabited variants, so pretend there&#39;s at least one.
                </span><span class="kw">if </span>(min, max) == (i128::MAX, i128::MIN) {
                    <a href="#1243">min</a> = <span class="number">0</span>;
                    <a href="#1243">max</a> = <span class="number">0</span>;
                }
                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(min &lt;= max, <span class="string">&quot;discriminant range is {}...{}&quot;</span>, min, max);
                <span class="kw">let </span>(min_ity, signed) = Integer::repr_discr(<a href="#544">tcx</a>, <a href="#543">ty</a>, <span class="kw-2">&amp;</span><a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>(), <a href="#1243">min</a>, <a href="#1243">max</a>);

                <span class="kw">let </span><span class="kw-2">mut </span>align = <a href="#546">dl</a>.aggregate_align;
                <span class="kw">let </span><span class="kw-2">mut </span>size = Size::ZERO;

                <span class="comment">// We&#39;re interested in the smallest alignment, so start large.
                </span><span class="kw">let </span><span class="kw-2">mut </span>start_align = Align::from_bytes(<span class="number">256</span>).unwrap();
                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(Integer::for_align(dl, start_align), <span class="prelude-val">None</span>);

                <span class="comment">// repr(C) on an enum tells us to make a (tag, union) layout,
                // so we need to grow the prefix alignment to be at least
                // the alignment of the union. (This value is used both for
                // determining the alignment of the overall enum, and the
                // determining the alignment of the payload after the tag.)
                </span><span class="kw">let </span><span class="kw-2">mut </span>prefix_align = <a href="#1268">min_ity</a>.align(<a href="#546">dl</a>).abi;
                <span class="kw">if </span>def.repr().c() {
                    <span class="kw">for </span>fields <span class="kw">in </span><span class="kw-2">&amp;</span>variants {
                        <span class="kw">for </span>field <span class="kw">in </span>fields {
                            prefix_align = prefix_align.max(field.align.abi);
                        }
                    }
                }

                <span class="comment">// Create the set of structs that represent each variant.
                </span><span class="kw">let </span><span class="kw-2">mut </span>layout_variants = variants
                    .iter_enumerated()
                    .map(|(i, field_layouts)| {
                        <span class="kw">let </span><span class="kw-2">mut </span>st = <span class="self">self</span>.univariant_uninterned(
                            ty,
                            <span class="kw-2">&amp;</span>field_layouts,
                            <span class="kw-2">&amp;</span>def.repr(),
                            StructKind::Prefixed(min_ity.size(), prefix_align),
                        )<span class="question-mark">?</span>;
                        st.variants = Variants::Single { index: i };
                        <span class="comment">// Find the first field we can&#39;t move later
                        // to make room for a larger discriminant.
                        </span><span class="kw">for </span>field <span class="kw">in
                            </span>st.fields.index_by_increasing_offset().map(|j| field_layouts[j])
                        {
                            <span class="kw">if </span>!field.is_zst() || field.align.abi.bytes() != <span class="number">1 </span>{
                                start_align = start_align.min(field.align.abi);
                                <span class="kw">break</span>;
                            }
                        }
                        size = cmp::max(size, st.size);
                        align = align.max(st.align);
                        <span class="prelude-val">Ok</span>(st)
                    })
                    .collect::&lt;<span class="prelude-ty">Result</span>&lt;IndexVec&lt;VariantIdx, <span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>;

                <span class="comment">// Align the maximum variant size to the largest alignment.
                </span><a href="#1271">size</a> = <a href="#1271">size</a>.align_to(<a href="#1270">align</a>.abi);

                <span class="kw">if </span>size.bytes() &gt;= dl.obj_size_bound() {
                    <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#206">LayoutError::SizeOverflow</a>(<a href="#543">ty</a>));
                }

                <span class="kw">let </span>typeck_ity = Integer::from_attr(<a href="#546">dl</a>, <a href="#841">def</a>.<a href="adt.rs.html#191">repr</a>().<a href="mod.rs.html#2056">discr_type</a>());
                <span class="kw">if </span>typeck_ity &lt; min_ity {
                    <span class="comment">// It is a bug if Layout decided on a greater discriminant size than typeck for
                    // some reason at this point (based on values discriminant can take on). Mostly
                    // because this discriminant will be loaded, and then stored into variable of
                    // type calculated by typeck. Consider such case (a bug): typeck decided on
                    // byte-sized discriminant, but layout thinks we need a 16-bit to store all
                    // discriminant values. That would be a bug, because then, in codegen, in order
                    // to store this 16-bit discriminant into 8-bit sized temporary some of the
                    // space necessary to represent would have to be discarded (or layout is wrong
                    // on thinking it needs 16 bits)
                    </span><a class="macro" href="../macros.rs.html#2-9">bug!</a>(
                        <span class="string">&quot;layout decided on a larger discriminant type ({:?}) than typeck ({:?})&quot;</span>,
                        min_ity,
                        typeck_ity
                    );
                    <span class="comment">// However, it is fine to make discr type however large (as an optimisation)
                    // after this point – we’ll just truncate the value we load in codegen.
                </span>}

                <span class="comment">// Check to see if we should use a different type for the
                // discriminant. We can safely use a type with the same size
                // as the alignment of the first field of each variant.
                // We increase the size of the discriminant to avoid LLVM copying
                // padding when it doesn&#39;t need to. This normally causes unaligned
                // load/stores and excessive memcpy/memset operations. By using a
                // bigger integer size, LLVM can be sure about its contents and
                // won&#39;t be so conservative.

                // Use the initial field alignment
                </span><span class="kw">let </span><span class="kw-2">mut </span>ity = <span class="kw">if </span>def.repr().c() || def.repr().int.is_some() {
                    <a href="#1268">min_ity</a>
                } <span class="kw">else </span>{
                    Integer::for_align(<a href="#546">dl</a>, <a href="#1274">start_align</a>).unwrap_or(<a href="#1268">min_ity</a>)
                };

                <span class="comment">// If the alignment is not larger than the chosen discriminant size,
                // don&#39;t use the alignment as the final size.
                </span><span class="kw">if </span>ity &lt;= min_ity {
                    <a href="#1355">ity</a> = <a href="#1268">min_ity</a>;
                } <span class="kw">else </span>{
                    <span class="comment">// Patch up the variants&#39; first few fields.
                    </span><span class="kw">let </span>old_ity_size = <a href="#1268">min_ity</a>.size();
                    <span class="kw">let </span>new_ity_size = <a href="#1355">ity</a>.size();
                    <span class="kw">for </span>variant <span class="kw">in </span><span class="kw-2">&amp;mut </span>layout_variants {
                        <span class="kw">match </span>variant.fields {
                            FieldsShape::Arbitrary { <span class="kw-2">ref mut </span>offsets, .. } =&gt; {
                                <span class="kw">for </span>i <span class="kw">in </span>offsets {
                                    <span class="kw">if </span><span class="kw-2">*</span>i &lt;= old_ity_size {
                                        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>i, old_ity_size);
                                        <span class="kw-2">*</span>i = new_ity_size;
                                    }
                                }
                                <span class="comment">// We might be making the struct larger.
                                </span><span class="kw">if </span>variant.size &lt;= old_ity_size {
                                    variant.size = new_ity_size;
                                }
                            }
                            <span class="kw">_ </span>=&gt; <span class="macro">bug!</span>(),
                        }
                    }
                }

                <span class="kw">let </span>tag_mask = <a href="#1355">ity</a>.size().unsigned_int_max();
                <span class="kw">let </span>tag = <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> {
                    value: Int(<a href="#1355">ity</a>, <a href="#1268">signed</a>),
                    valid_range: <a href="../../../rustc_target/abi/struct.WrappingRange.html">WrappingRange</a> {
                        start: (<a href="#1243">min</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a> &amp; <a href="#1388">tag_mask</a>),
                        end: (<a href="#1243">max</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a> &amp; <a href="#1388">tag_mask</a>),
                    },
                };
                <span class="kw">let </span><span class="kw-2">mut </span>abi = <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>};

                <span class="kw">if </span>layout_variants.iter().all(|v| v.abi.is_uninhabited()) {
                    <a href="#1396">abi</a> = Abi::Uninhabited;
                } <span class="kw">else if </span>tag.size(dl) == size {
                    <span class="comment">// Make sure we only use scalar layout when the enum is entirely its
                    // own tag (i.e. it has no padding nor any non-ZST variant fields).
                    </span><a href="#1396">abi</a> = Abi::Scalar(<a href="#1389">tag</a>);
                } <span class="kw">else </span>{
                    <span class="comment">// Try to use a ScalarPair for all tagged enums.
                    </span><span class="kw">let </span><span class="kw-2">mut </span>common_prim = <span class="prelude-val">None</span>;
                    <span class="kw">let </span><span class="kw-2">mut </span>common_prim_initialized_in_all_variants = <span class="bool-val">true</span>;
                    <span class="kw">for </span>(field_layouts, layout_variant) <span class="kw">in </span>iter::zip(<span class="kw-2">&amp;</span>variants, <span class="kw-2">&amp;</span>layout_variants) {
                        <span class="kw">let </span>FieldsShape::Arbitrary { <span class="kw-2">ref </span>offsets, .. } = layout_variant.fields <span class="kw">else </span>{
                            <span class="macro">bug!</span>();
                        };
                        <span class="kw">let </span><span class="kw-2">mut </span>fields =
                            iter::zip(field_layouts, offsets).filter(|p| !p.<span class="number">0</span>.is_zst());
                        <span class="kw">let </span>(field, offset) = <span class="kw">match </span>(fields.next(), fields.next()) {
                            (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) =&gt; {
                                common_prim_initialized_in_all_variants = <span class="bool-val">false</span>;
                                <span class="kw">continue</span>;
                            }
                            (<span class="prelude-val">Some</span>(pair), <span class="prelude-val">None</span>) =&gt; pair,
                            <span class="kw">_ </span>=&gt; {
                                common_prim = <span class="prelude-val">None</span>;
                                <span class="kw">break</span>;
                            }
                        };
                        <span class="kw">let </span>prim = <span class="kw">match </span>field.abi {
                            Abi::Scalar(scalar) =&gt; {
                                common_prim_initialized_in_all_variants &amp;=
                                    <span class="macro">matches!</span>(scalar, Scalar::Initialized { .. });
                                scalar.primitive()
                            }
                            <span class="kw">_ </span>=&gt; {
                                common_prim = <span class="prelude-val">None</span>;
                                <span class="kw">break</span>;
                            }
                        };
                        <span class="kw">if let </span><span class="prelude-val">Some</span>(pair) = common_prim {
                            <span class="comment">// This is pretty conservative. We could go fancier
                            // by conflating things like i32 and u32, or even
                            // realising that (u8, u8) could just cohabit with
                            // u16 or even u32.
                            </span><span class="kw">if </span>pair != (prim, offset) {
                                common_prim = <span class="prelude-val">None</span>;
                                <span class="kw">break</span>;
                            }
                        } <span class="kw">else </span>{
                            common_prim = <span class="prelude-val">Some</span>((prim, offset));
                        }
                    }
                    <span class="kw">if let </span><span class="prelude-val">Some</span>((prim, offset)) = <a href="#1406">common_prim</a> {
                        <span class="kw">let </span>prim_scalar = <span class="kw">if </span>common_prim_initialized_in_all_variants {
                            <a href="#547">scalar_unit</a>(<a href="#1449">prim</a>)
                        } <span class="kw">else </span>{
                            <span class="comment">// Common prim might be uninit.
                            </span><a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Union</a> { value: <a href="#1449">prim</a> }
                        };
                        <span class="kw">let </span>pair = <a class="self" href="#543">self</a>.<a href="#296">scalar_pair</a>(<a href="#1389">tag</a>, <a href="#1450">prim_scalar</a>);
                        <span class="kw">let </span>pair_offsets = <span class="kw">match </span><a href="#1456">pair</a>.fields {
                            <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { <span class="kw-2">ref </span>offsets, <span class="kw-2">ref </span>memory_index } =&gt; {
                                <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(memory_index, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>]);
                                <a href="#1458">offsets</a>
                            }
                            <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
                        };
                        <span class="kw">if </span>pair_offsets[<span class="number">0</span>] == Size::ZERO
                            &amp;&amp; pair_offsets[<span class="number">1</span>] == <span class="kw-2">*</span>offset
                            &amp;&amp; align == pair.align
                            &amp;&amp; size == pair.size
                        {
                            <span class="comment">// We can use `ScalarPair` only when it matches our
                            // already computed layout (including `#[repr(C)]`).
                            </span><a href="#1396">abi</a> = <a href="#1456">pair</a>.abi;
                        }
                    }
                }

                <span class="comment">// If we pick a &quot;clever&quot; (by-value) ABI, we might have to adjust the ABI of the
                // variants to ensure they are consistent. This is because a downcast is
                // semantically a NOP, and thus should not affect layout.
                </span><span class="kw">if </span><a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.matches.html">matches!</a>(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {
                    <span class="kw">for </span>variant <span class="kw">in </span><span class="kw-2">&amp;mut </span>layout_variants {
                        <span class="comment">// We only do this for variants with fields; the others are not accessed anyway.
                        // Also do not overwrite any already existing &quot;clever&quot; ABIs.
                        </span><span class="kw">if </span>variant.fields.count() &gt; <span class="number">0
                            </span>&amp;&amp; <span class="macro">matches!</span>(variant.abi, Abi::Aggregate { .. })
                        {
                            variant.abi = abi;
                            <span class="comment">// Also need to bump up the size and alignment, so that the entire value fits in here.
                            </span>variant.size = cmp::max(variant.size, size);
                            variant.align.abi = cmp::max(variant.align.abi, align.abi);
                        }
                    }
                }

                <span class="kw">let </span>largest_niche = Niche::from_scalar(<a href="#546">dl</a>, Size::ZERO, <a href="#1389">tag</a>);

                <span class="kw">let </span>tagged_layout = <a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                    variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> {
                        <a href="#1389">tag</a>,
                        tag_encoding: TagEncoding::Direct,
                        tag_field: <span class="number">0</span>,
                        variants: IndexVec::new(),
                    },
                    fields: <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> {
                        offsets: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[Size::ZERO],
                        memory_index: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[<span class="number">0</span>],
                    },
                    <a href="#1494">largest_niche</a>,
                    <a href="#1396">abi</a>,
                    <a href="#1270">align</a>,
                    <a href="#1271">size</a>,
                };

                <span class="kw">let </span>tagged_layout = <a href="#1062">TmpLayout</a> { layout: <a href="#1496">tagged_layout</a>, variants: <a href="#1292">layout_variants</a> };

                <span class="kw">let </span><span class="kw-2">mut </span>best_layout = <span class="kw">match </span>(<a href="#1513">tagged_layout</a>, <a href="#1241">niche_filling_layout</a>) {
                    (tl, <span class="prelude-val">Some</span>(nl)) =&gt; {
                        <span class="comment">// Pick the smaller layout; otherwise,
                        // pick the layout with the larger niche; otherwise,
                        // pick tagged as it has simpler codegen.
                        </span><span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html">Ordering</a>::<span class="kw-2">*</span>;
                        <span class="kw">let </span>niche_size = |tmp_l: <span class="kw-2">&amp;</span>TmpLayout&lt;<span class="lifetime">&#39;_</span>&gt;| {
                            <a href="#1521">tmp_l</a>.layout.largest_niche.map_or(<span class="number">0</span>, |n| <a href="#1522">n</a>.available(<a href="#546">dl</a>))
                        };
                        <span class="kw">match </span>(
                            <a href="#1516">tl</a>.layout.size.<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html">cmp</a>(<span class="kw-2">&amp;</span><a href="#1516">nl</a>.layout.size),
                            <a href="#1521">niche_size</a>(<span class="kw-2">&amp;</span><a href="#1516">tl</a>).<a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html">cmp</a>(<span class="kw-2">&amp;</span><a href="#1521">niche_size</a>(<span class="kw-2">&amp;</span><a href="#1516">nl</a>)),
                        ) {
                            (Greater, <span class="kw">_</span>) =&gt; <a href="#1516">nl</a>,
                            (Equal, Less) =&gt; <a href="#1516">nl</a>,
                            <span class="kw">_ </span>=&gt; <a href="#1516">tl</a>,
                        }
                    }
                    (tl, <span class="prelude-val">None</span>) =&gt; <a href="#1533">tl</a>,
                };

                <span class="comment">// Now we can intern the variant layouts and store them in the enum layout.
                </span><a href="#1515">best_layout</a>.layout.variants = <span class="kw">match </span><a href="#1515">best_layout</a>.layout.variants {
                    <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> { tag, tag_encoding, tag_field, .. } =&gt; <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> {
                        <a href="#1538">tag</a>,
                        <a href="#1538">tag_encoding</a>,
                        <a href="#1538">tag_field</a>,
                        variants: <a href="#1515">best_layout</a>
                            .variants
                            .into_iter()
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|layout| <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="#1545">layout</a>))
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>(),
                    },
                    <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
                };

                <a href="#544">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="#1515">best_layout</a>.layout)
            }

            <span class="comment">// Types with no meaningful known layout.
            </span>ty::Projection(<span class="kw">_</span>) | ty::Opaque(..) =&gt; {
                <span class="comment">// NOTE(eddyb) `layout_of` query should&#39;ve normalized these away,
                // if that was possible, so there&#39;s no reason to try again here.
                </span><span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
            }

            ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(<span class="kw">_</span>) =&gt; {
                <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;Layout::compute: unexpected type `{}`&quot;</span>, ty)
            }

            ty::Bound(..) | ty::Param(<span class="kw">_</span>) | ty::Error(<span class="kw">_</span>) =&gt; {
                <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#543">ty</a>));
            }
        })
    }
}

<span class="doccomment">/// Overlap eligibility and variant assignment for each GeneratorSavedLocal.
</span><span class="attribute">#[derive(Clone, Debug, PartialEq)]
</span><span class="kw">enum </span>SavedLocalEligibility {
    Unassigned,
    Assigned(<a href="../../../rustc_target/abi/struct.VariantIdx.html">VariantIdx</a>),
    <span class="comment">// FIXME: Use newtype_index so we aren&#39;t wasting bytes
    </span>Ineligible(<span class="prelude-ty">Option</span>&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;),
}

<span class="comment">// When laying out generators, we divide our saved local fields into two
// categories: overlap-eligible and overlap-ineligible.
//
// Those fields which are ineligible for overlap go in a &quot;prefix&quot; at the
// beginning of the layout, and always have space reserved for them.
//
// Overlap-eligible fields are only assigned to one variant, so we lay
// those fields out for each variant and put them right after the
// prefix.
//
// Finally, in the layout details, we point to the fields from the
// variants they are assigned to. It is possible for some fields to be
// included in multiple variants. No field ever &quot;moves around&quot; in the
// layout; its offset is always the same.
//
// Also included in the layout are the upvars and the discriminant.
// These are included as fields on the &quot;outer&quot; layout; they are not part
// of any variant.
</span><span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="doccomment">/// Compute the eligibility and assignment of each local.
    </span><span class="kw">fn </span>generator_saved_local_eligibility(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        info: <span class="kw-2">&amp;</span>GeneratorLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; (BitSet&lt;<a href="../mir/query.rs.html#132-137">GeneratorSavedLocal</a>&gt;, IndexVec&lt;<a href="../mir/query.rs.html#132-137">GeneratorSavedLocal</a>, <a href="#1574">SavedLocalEligibility</a>&gt;) {
        <span class="kw">use </span><a href="#1574">SavedLocalEligibility</a>::<span class="kw-2">*</span>;

        <span class="kw">let </span><span class="kw-2">mut </span>assignments: IndexVec&lt;<a href="../mir/query.rs.html#132-137">GeneratorSavedLocal</a>, <a href="#1574">SavedLocalEligibility</a>&gt; =
            IndexVec::from_elem_n(<a href="#1575">Unassigned</a>, <a href="#1603">info</a>.field_tys.len());

        <span class="comment">// The saved locals not eligible for overlap. These will get
        // &quot;promoted&quot; to the prefix of our generator.
        </span><span class="kw">let </span><span class="kw-2">mut </span>ineligible_locals = BitSet::new_empty(<a href="#1603">info</a>.field_tys.len());

        <span class="comment">// Figure out which of our saved locals are fields in only
        // one variant. The rest are deemed ineligible for overlap.
        </span><span class="kw">for </span>(variant_index, fields) <span class="kw">in </span>info.variant_fields.iter_enumerated() {
            <span class="kw">for </span>local <span class="kw">in </span>fields {
                <span class="kw">match </span>assignments[<span class="kw-2">*</span>local] {
                    Unassigned =&gt; {
                        assignments[<span class="kw-2">*</span>local] = Assigned(variant_index);
                    }
                    Assigned(idx) =&gt; {
                        <span class="comment">// We&#39;ve already seen this local at another suspension
                        // point, so it is no longer a candidate.
                        </span><span class="macro">trace!</span>(
                            <span class="string">&quot;removing local {:?} in &gt;1 variant ({:?}, {:?})&quot;</span>,
                            local,
                            variant_index,
                            idx
                        );
                        ineligible_locals.insert(<span class="kw-2">*</span>local);
                        assignments[<span class="kw-2">*</span>local] = Ineligible(<span class="prelude-val">None</span>);
                    }
                    Ineligible(<span class="kw">_</span>) =&gt; {}
                }
            }
        }

        <span class="comment">// Next, check every pair of eligible locals to see if they
        // conflict.
        </span><span class="kw">for </span>local_a <span class="kw">in </span>info.storage_conflicts.rows() {
            <span class="kw">let </span>conflicts_a = info.storage_conflicts.count(local_a);
            <span class="kw">if </span>ineligible_locals.contains(local_a) {
                <span class="kw">continue</span>;
            }

            <span class="kw">for </span>local_b <span class="kw">in </span>info.storage_conflicts.iter(local_a) {
                <span class="comment">// local_a and local_b are storage live at the same time, therefore they
                // cannot overlap in the generator layout. The only way to guarantee
                // this is if they are in the same variant, or one is ineligible
                // (which means it is stored in every variant).
                </span><span class="kw">if </span>ineligible_locals.contains(local_b)
                    || assignments[local_a] == assignments[local_b]
                {
                    <span class="kw">continue</span>;
                }

                <span class="comment">// If they conflict, we will choose one to make ineligible.
                // This is not always optimal; it&#39;s just a greedy heuristic that
                // seems to produce good results most of the time.
                </span><span class="kw">let </span>conflicts_b = info.storage_conflicts.count(local_b);
                <span class="kw">let </span>(remove, other) =
                    <span class="kw">if </span>conflicts_a &gt; conflicts_b { (local_a, local_b) } <span class="kw">else </span>{ (local_b, local_a) };
                ineligible_locals.insert(remove);
                assignments[remove] = Ineligible(<span class="prelude-val">None</span>);
                <span class="macro">trace!</span>(<span class="string">&quot;removing local {:?} due to conflict with {:?}&quot;</span>, remove, other);
            }
        }

        <span class="comment">// Count the number of variants in use. If only one of them, then it is
        // impossible to overlap any locals in our layout. In this case it&#39;s
        // always better to make the remaining locals ineligible, so we can
        // lay them out with the other locals in the prefix and eliminate
        // unnecessary padding bytes.
        </span>{
            <span class="kw">let </span><span class="kw-2">mut </span>used_variants = BitSet::new_empty(<a href="#1603">info</a>.variant_fields.len());
            <span class="kw">for </span>assignment <span class="kw">in </span><span class="kw-2">&amp;</span>assignments {
                <span class="kw">if let </span>Assigned(idx) = assignment {
                    used_variants.insert(<span class="kw-2">*</span>idx);
                }
            }
            <span class="kw">if </span>used_variants.count() &lt; <span class="number">2 </span>{
                <span class="kw">for </span>assignment <span class="kw">in </span>assignments.iter_mut() {
                    <span class="kw-2">*</span>assignment = Ineligible(<span class="prelude-val">None</span>);
                }
                <a href="#1612">ineligible_locals</a>.insert_all();
            }
        }

        <span class="comment">// Write down the order of our locals that will be promoted to the prefix.
        </span>{
            <span class="kw">for </span>(idx, local) <span class="kw">in </span>ineligible_locals.iter().enumerate() {
                assignments[local] = Ineligible(<span class="prelude-val">Some</span>(idx <span class="kw">as </span>u32));
            }
        }
        <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;generator saved local assignments: {:?}&quot;</span>, assignments);

        (<a href="#1612">ineligible_locals</a>, <a href="#1607">assignments</a>)
    }

    <span class="doccomment">/// Compute the full generator layout.
    </span><span class="kw">fn </span>generator_layout(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        def_id: <a href="../../../rustc_span/def_id/struct.DefId.html">hir::def_id::DefId</a>,
        substs: SubstsRef&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;Layout&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <span class="kw">use </span><a href="#1574">SavedLocalEligibility</a>::<span class="kw-2">*</span>;
        <span class="kw">let </span>tcx = <a class="self" href="#1703">self</a>.tcx;
        <span class="kw">let </span>subst_field = |ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;| <a href="sty.rs.html#920">EarlyBinder</a>(<a href="#1710">ty</a>).<a href="subst.rs.html#505">subst</a>(<a href="#1709">tcx</a>, <a href="#1706">substs</a>);

        <span class="kw">let </span><span class="prelude-val">Some</span>(info) = <a href="#1709">tcx</a>.<a href="mod.rs.html#2396">generator_layout</a>(<a href="#1705">def_id</a>) <span class="kw">else </span>{
            <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#205">LayoutError::Unknown</a>(<a href="#1704">ty</a>));
        };
        <span class="kw">let </span>(ineligible_locals, assignments) = <a class="self" href="#1703">self</a>.<a href="#1601-1604">generator_saved_local_eligibility</a>(<span class="kw-2">&amp;</span><a href="#1712">info</a>);

        <span class="comment">// Build a prefix layout, including &quot;promoting&quot; all ineligible
        // locals as part of the prefix. We compute the layout of all of
        // these fields at once to get optimal packing.
        </span><span class="kw">let </span>tag_index = <a href="#1706">substs</a>.<a href="subst.rs.html#267">as_generator</a>().<a href="sty.rs.html#561">prefix_tys</a>().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">count</a>();

        <span class="comment">// `info.variant_fields` already accounts for the reserved variants, so no need to add them.
        </span><span class="kw">let </span>max_discr = (<a href="#1712">info</a>.variant_fields.len() - <span class="number">1</span>) <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a>;
        <span class="kw">let </span>discr_int = Integer::fit_unsigned(<a href="#1723">max_discr</a>);
        <span class="kw">let </span>discr_int_ty = <a href="#1724">discr_int</a>.<a href="#40">to_ty</a>(<a href="#1709">tcx</a>, <span class="bool-val">false</span>);
        <span class="kw">let </span>tag = <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> {
            value: Primitive::Int(<a href="#1724">discr_int</a>, <span class="bool-val">false</span>),
            valid_range: <a href="../../../rustc_target/abi/struct.WrappingRange.html">WrappingRange</a> { start: <span class="number">0</span>, end: <a href="#1723">max_discr</a> },
        };
        <span class="kw">let </span>tag_layout = <a class="self" href="#1703">self</a>.tcx.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a class="self" href="#1703">self</a>, <a href="#1726">tag</a>));
        <span class="kw">let </span>tag_layout = <a href="#2279">TyAndLayout</a> { ty: <a href="#1725">discr_int_ty</a>, layout: <a href="#1730">tag_layout</a> };

        <span class="kw">let </span>promoted_layouts = <a href="#1715">ineligible_locals</a>
            .iter()
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|local| <a href="#1710">subst_field</a>(<a href="#1712">info</a>.field_tys[<a href="#1735">local</a>]))
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|ty| <a href="#1709">tcx</a>.<a href="context.rs.html#2471">mk_maybe_uninit</a>(<a href="#1736">ty</a>))
            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|ty| <a class="self" href="#1703">self</a>.<a href="#2315">layout_of</a>(<a href="#1737">ty</a>));
        <span class="kw">let </span>prefix_layouts = substs
            .as_generator()
            .prefix_tys()
            .map(|ty| <span class="self">self</span>.layout_of(ty))
            .chain(iter::once(<span class="prelude-val">Ok</span>(tag_layout)))
            .chain(promoted_layouts)
            .collect::&lt;<span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>;
        <span class="kw">let </span>prefix = <span class="self">self</span>.univariant_uninterned(
            ty,
            <span class="kw-2">&amp;</span>prefix_layouts,
            <span class="kw-2">&amp;</span>ReprOptions::default(),
            StructKind::AlwaysSized,
        )<span class="question-mark">?</span>;

        <span class="kw">let </span>(prefix_size, prefix_align) = (<a href="#1745">prefix</a>.size, <a href="#1745">prefix</a>.align);

        <span class="comment">// Split the prefix layout into the &quot;outer&quot; fields (upvars and
        // discriminant) and the &quot;promoted&quot; fields. Promoted fields will
        // get included in each variant that requested them in
        // GeneratorLayout.
        </span><a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;prefix = {:#?}&quot;</span>, prefix);
        <span class="kw">let </span>(outer_fields, promoted_offsets, promoted_memory_index) = <span class="kw">match </span><a href="#1745">prefix</a>.fields {
            <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { <span class="kw-2">mut </span>offsets, memory_index } =&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>inverse_memory_index = <a href="#287">invert_mapping</a>(<span class="kw-2">&amp;</span><a href="#1760">memory_index</a>);

                <span class="comment">// &quot;a&quot; (`0..b_start`) and &quot;b&quot; (`b_start..`) correspond to
                // &quot;outer&quot; and &quot;promoted&quot; fields respectively.
                </span><span class="kw">let </span>b_start = (<a href="#1720">tag_index</a> + <span class="number">1</span>) <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>;
                <span class="kw">let </span>offsets_b = <a href="#1760">offsets</a>.split_off(<a href="#1765">b_start</a> <span class="kw">as </span><a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>);
                <span class="kw">let </span>offsets_a = <a href="#1760">offsets</a>;

                <span class="comment">// Disentangle the &quot;a&quot; and &quot;b&quot; components of `inverse_memory_index`
                // by preserving the order but keeping only one disjoint &quot;half&quot; each.
                // FIXME(eddyb) build a better abstraction for permutations, if possible.
                </span><span class="kw">let </span>inverse_memory_index_b: Vec&lt;<span class="kw">_</span>&gt; =
                    <a href="#1761">inverse_memory_index</a>.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">filter_map</a>(|<span class="kw-2">&amp;</span>i| <a href="#1773">i</a>.checked_sub(<a href="#1765">b_start</a>)).<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();
                <a href="#1761">inverse_memory_index</a>.retain(|<span class="kw-2">&amp;</span>i| <a href="#1774">i</a> &lt; <a href="#1765">b_start</a>);
                <span class="kw">let </span>inverse_memory_index_a = <a href="#1761">inverse_memory_index</a>;

                <span class="comment">// Since `inverse_memory_index_{a,b}` each only refer to their
                // respective fields, they can be safely inverted
                </span><span class="kw">let </span>memory_index_a = <a href="#287">invert_mapping</a>(<span class="kw-2">&amp;</span><a href="#1775">inverse_memory_index_a</a>);
                <span class="kw">let </span>memory_index_b = <a href="#287">invert_mapping</a>(<span class="kw-2">&amp;</span><a href="#1772">inverse_memory_index_b</a>);

                <span class="kw">let </span>outer_fields =
                    <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { offsets: <a href="#1767">offsets_a</a>, memory_index: <a href="#1779">memory_index_a</a> };
                (<a href="#1782">outer_fields</a>, <a href="#1766">offsets_b</a>, <a href="#1780">memory_index_b</a>)
            }
            <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
        };

        <span class="kw">let </span><span class="kw-2">mut </span>size = <a href="#1745">prefix</a>.size;
        <span class="kw">let </span><span class="kw-2">mut </span>align = <a href="#1745">prefix</a>.align;
        <span class="kw">let </span>variants = info
            .variant_fields
            .iter_enumerated()
            .map(|(index, variant_fields)| {
                <span class="comment">// Only include overlap-eligible fields when we compute our variant layout.
                </span><span class="kw">let </span>variant_only_tys = variant_fields
                    .iter()
                    .filter(|local| <span class="kw">match </span>assignments[<span class="kw-2">**</span>local] {
                        Unassigned =&gt; <span class="macro">bug!</span>(),
                        Assigned(v) <span class="kw">if </span>v == index =&gt; <span class="bool-val">true</span>,
                        Assigned(<span class="kw">_</span>) =&gt; <span class="macro">bug!</span>(<span class="string">&quot;assignment does not match variant&quot;</span>),
                        Ineligible(<span class="kw">_</span>) =&gt; <span class="bool-val">false</span>,
                    })
                    .map(|local| subst_field(info.field_tys[<span class="kw-2">*</span>local]));

                <span class="kw">let </span><span class="kw-2">mut </span>variant = <span class="self">self</span>.univariant_uninterned(
                    ty,
                    <span class="kw-2">&amp;</span>variant_only_tys
                        .map(|ty| <span class="self">self</span>.layout_of(ty))
                        .collect::&lt;<span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>,
                    <span class="kw-2">&amp;</span>ReprOptions::default(),
                    StructKind::Prefixed(prefix_size, prefix_align.abi),
                )<span class="question-mark">?</span>;
                variant.variants = Variants::Single { index };

                <span class="kw">let </span>FieldsShape::Arbitrary { offsets, memory_index } = variant.fields <span class="kw">else </span>{
                    <span class="macro">bug!</span>();
                };

                <span class="comment">// Now, stitch the promoted and variant-only fields back together in
                // the order they are mentioned by our GeneratorLayout.
                // Because we only use some subset (that can differ between variants)
                // of the promoted fields, we can&#39;t just pick those elements of the
                // `promoted_memory_index` (as we&#39;d end up with gaps).
                // So instead, we build an &quot;inverse memory_index&quot;, as if all of the
                // promoted fields were being used, but leave the elements not in the
                // subset as `INVALID_FIELD_IDX`, which we can filter out later to
                // obtain a valid (bijective) mapping.
                </span><span class="kw">const </span>INVALID_FIELD_IDX: u32 = !<span class="number">0</span>;
                <span class="kw">let </span><span class="kw-2">mut </span>combined_inverse_memory_index =
                    <span class="macro">vec!</span>[INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()];
                <span class="kw">let </span><span class="kw-2">mut </span>offsets_and_memory_index = iter::zip(offsets, memory_index);
                <span class="kw">let </span>combined_offsets = variant_fields
                    .iter()
                    .enumerate()
                    .map(|(i, local)| {
                        <span class="kw">let </span>(offset, memory_index) = <span class="kw">match </span>assignments[<span class="kw-2">*</span>local] {
                            Unassigned =&gt; <span class="macro">bug!</span>(),
                            Assigned(<span class="kw">_</span>) =&gt; {
                                <span class="kw">let </span>(offset, memory_index) =
                                    offsets_and_memory_index.next().unwrap();
                                (offset, promoted_memory_index.len() <span class="kw">as </span>u32 + memory_index)
                            }
                            Ineligible(field_idx) =&gt; {
                                <span class="kw">let </span>field_idx = field_idx.unwrap() <span class="kw">as </span>usize;
                                (promoted_offsets[field_idx], promoted_memory_index[field_idx])
                            }
                        };
                        combined_inverse_memory_index[memory_index <span class="kw">as </span>usize] = i <span class="kw">as </span>u32;
                        offset
                    })
                    .collect();

                <span class="comment">// Remove the unused slots and invert the mapping to obtain the
                // combined `memory_index` (also see previous comment).
                </span>combined_inverse_memory_index.retain(|<span class="kw-2">&amp;</span>i| i != INVALID_FIELD_IDX);
                <span class="kw">let </span>combined_memory_index = invert_mapping(<span class="kw-2">&amp;</span>combined_inverse_memory_index);

                variant.fields = FieldsShape::Arbitrary {
                    offsets: combined_offsets,
                    memory_index: combined_memory_index,
                };

                size = size.max(variant.size);
                align = align.max(variant.align);
                <span class="prelude-val">Ok</span>(tcx.intern_layout(variant))
            })
            .collect::&lt;<span class="prelude-ty">Result</span>&lt;IndexVec&lt;VariantIdx, <span class="kw">_</span>&gt;, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>;

        <a href="#1789">size</a> = <a href="#1789">size</a>.align_to(<a href="#1790">align</a>.abi);

        <span class="kw">let </span>abi =
            <span class="kw">if </span>prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) {
                Abi::Uninhabited
            } <span class="kw">else </span>{
                <a href="../../../rustc_target/abi/enum.Abi.html">Abi::Aggregate</a> { sized: <span class="bool-val">true </span>}
            };

        <span class="kw">let </span>layout = <a href="#1709">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
            variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> {
                <a href="#1726">tag</a>,
                tag_encoding: TagEncoding::Direct,
                tag_field: <a href="#1720">tag_index</a>,
                <a href="#1791">variants</a>,
            },
            fields: <a href="#1759">outer_fields</a>,
            <a href="#1872">abi</a>,
            largest_niche: <a href="#1745">prefix</a>.largest_niche,
            <a href="#1789">size</a>,
            <a href="#1790">align</a>,
        });
        <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;generator layout ({:?}): {:#?}&quot;</span>, ty, layout);
        <span class="prelude-val">Ok</span>(<a href="#1879">layout</a>)
    }

    <span class="doccomment">/// This is invoked by the `layout_of` query to record the final
    /// layout of each type.
    </span><span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>record_layout_for_printing(<span class="kw-2">&amp;</span><span class="self">self</span>, layout: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) {
        <span class="comment">// If we are running with `-Zprint-type-sizes`, maybe record layouts
        // for dumping later.
        </span><span class="kw">if </span><span class="self">self</span>.tcx.sess.opts.unstable_opts.print_type_sizes {
            <a class="self" href="#1899">self</a>.<a href="#1907">record_layout_for_printing_outlined</a>(<a href="#1899">layout</a>)
        }
    }

    <span class="kw">fn </span>record_layout_for_printing_outlined(<span class="kw-2">&amp;</span><span class="self">self</span>, layout: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) {
        <span class="comment">// Ignore layouts that are done with non-empty environments or
        // non-monomorphic layouts, as the user only wants to see the stuff
        // resulting from the final codegen session.
        </span><span class="kw">if </span>layout.ty.has_param_types_or_consts() || !<span class="self">self</span>.param_env.caller_bounds().is_empty() {
            <span class="kw">return</span>;
        }

        <span class="comment">// (delay format until we actually need it)
        </span><span class="kw">let </span>record = |kind, packed, opt_discr_size, variants| {
            <span class="kw">let </span>type_desc = <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.format.html">format!</a>(<span class="string">&quot;{:?}&quot;</span>, layout.ty);
            <a class="self" href="#1907">self</a>.tcx.sess.code_stats.record_type_size(
                <a href="#1916">kind</a>,
                <a href="#1917">type_desc</a>,
                <a href="#1907">layout</a>.align.abi,
                <a href="#1907">layout</a>.size,
                <a href="#1916">packed</a>,
                <a href="#1916">opt_discr_size</a>,
                <a href="#1916">variants</a>,
            );
        };

        <span class="kw">let </span>adt_def = <span class="kw">match </span><span class="kw-2">*</span><a href="#1907">layout</a>.ty.<a href="sty.rs.html#1639">kind</a>() {
            ty::Adt(<span class="kw-2">ref </span>adt_def, <span class="kw">_</span>) =&gt; {
                <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;print-type-size t: `{:?}` process adt&quot;</span>, layout.ty);
                <a href="#1930">adt_def</a>
            }

            ty::Closure(..) =&gt; {
                <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;print-type-size t: `{:?}` record closure&quot;</span>, layout.ty);
                <a href="#1916">record</a>(DataTypeKind::Closure, <span class="bool-val">false</span>, <span class="prelude-val">None</span>, <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[]);
                <span class="kw">return</span>;
            }

            <span class="kw">_ </span>=&gt; {
                <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(<span class="string">&quot;print-type-size t: `{:?}` skip non-nominal&quot;</span>, layout.ty);
                <span class="kw">return</span>;
            }
        };

        <span class="kw">let </span>adt_kind = <a href="#1929">adt_def</a>.<a href="adt.rs.html#287">adt_kind</a>();
        <span class="kw">let </span>adt_packed = <a href="#1929">adt_def</a>.<a href="adt.rs.html#191">repr</a>().pack.is_some();

        <span class="kw">let </span>build_variant_info = |n: <span class="prelude-ty">Option</span>&lt;<a href="../../../rustc_span/symbol/struct.Symbol.html">Symbol</a>&gt;, flds: <span class="kw-2">&amp;</span>[<a href="../../../rustc_span/symbol/struct.Symbol.html">Symbol</a>], layout: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;| {
            <span class="kw">let </span><span class="kw-2">mut </span>min_size = Size::ZERO;
            <span class="kw">let </span>field_info: Vec&lt;<span class="kw">_</span>&gt; = <a href="#1950">flds</a>
                .iter()
                .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">enumerate</a>()
                .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|(i, <span class="kw-2">&amp;</span>name)| {
                    <span class="kw">let </span>field_layout = <a href="#1950">layout</a>.field(<a class="self" href="#1907">self</a>, <a href="#1955">i</a>);
                    <span class="kw">let </span>offset = <a href="#1950">layout</a>.fields.offset(<a href="#1955">i</a>);
                    <span class="kw">let </span>field_end = <a href="#1957">offset</a> + <a href="#1956">field_layout</a>.size;
                    <span class="kw">if </span>min_size &lt; field_end {
                        <a href="#1951">min_size</a> = <a href="#1958">field_end</a>;
                    }
                    <a href="../../../rustc_session/code_stats/struct.FieldInfo.html">FieldInfo</a> {
                        <a href="#1955">name</a>,
                        offset: <a href="#1957">offset</a>.bytes(),
                        size: <a href="#1956">field_layout</a>.size.bytes(),
                        align: <a href="#1956">field_layout</a>.align.abi.bytes(),
                    }
                })
                .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();

            <a href="../../../rustc_session/code_stats/struct.VariantInfo.html">VariantInfo</a> {
                name: <a href="#1950">n</a>,
                kind: <span class="kw">if </span>layout.is_unsized() { SizeKind::Min } <span class="kw">else </span>{ SizeKind::Exact },
                align: <a href="#1950">layout</a>.align.abi.bytes(),
                size: <span class="kw">if </span>min_size.bytes() == <span class="number">0 </span>{ <a href="#1950">layout</a>.size.bytes() } <span class="kw">else </span>{ <a href="#1951">min_size</a>.bytes() },
                fields: <a href="#1952">field_info</a>,
            }
        };

        <span class="kw">match </span><a href="#1907">layout</a>.variants {
            <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index } =&gt; {
                <span class="kw">if </span>!adt_def.variants().is_empty() &amp;&amp; layout.fields != FieldsShape::Primitive {
                    <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(
                        <span class="string">&quot;print-type-size `{:#?}` variant {}&quot;</span>,
                        layout,
                        adt_def.variant(index).name
                    );
                    <span class="kw">let </span>variant_def = <span class="kw-2">&amp;</span><a href="#1929">adt_def</a>.<a href="adt.rs.html#181">variant</a>(<a href="#1981">index</a>);
                    <span class="kw">let </span>fields: Vec&lt;<span class="kw">_</span>&gt; = <a href="#1988">variant_def</a>.fields.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|f| <a href="#1989">f</a>.name).<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();
                    <a href="#1916">record</a>(
                        <a href="#1947">adt_kind</a>.<a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">into</a>(),
                        <a href="#1948">adt_packed</a>,
                        <span class="prelude-val">None</span>,
                        <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[build_variant_info(<span class="prelude-val">Some</span>(variant_def.name), <span class="kw-2">&amp;</span>fields, layout)],
                    );
                } <span class="kw">else </span>{
                    <span class="comment">// (This case arises for *empty* enums; so give it
                    // zero variants.)
                    </span><a href="#1916">record</a>(<a href="#1947">adt_kind</a>.<a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">into</a>(), <a href="#1948">adt_packed</a>, <span class="prelude-val">None</span>, <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[]);
                }
            }

            <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> { tag, <span class="kw-2">ref </span>tag_encoding, .. } =&gt; {
                <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(
                    <span class="string">&quot;print-type-size `{:#?}` adt general variants def {}&quot;</span>,
                    layout.ty,
                    adt_def.variants().len()
                );
                <span class="kw">let </span>variant_infos: Vec&lt;<span class="kw">_</span>&gt; = <a href="#1929">adt_def</a>
                    .<a href="adt.rs.html#176">variants</a>()
                    .iter_enumerated()
                    .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|(i, variant_def)| {
                        <span class="kw">let </span>fields: Vec&lt;<span class="kw">_</span>&gt; = <a href="#2012">variant_def</a>.fields.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|f| <a href="#2013">f</a>.name).<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();
                        <a href="#1950">build_variant_info</a>(
                            <span class="prelude-val">Some</span>(<a href="#2012">variant_def</a>.name),
                            <span class="kw-2">&amp;</span><a href="#2013">fields</a>,
                            <a href="#1907">layout</a>.for_variant(<a class="self" href="#1907">self</a>, <a href="#2012">i</a>),
                        )
                    })
                    .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">collect</a>();
                <a href="#1916">record</a>(
                    <a href="#1947">adt_kind</a>.<a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">into</a>(),
                    <a href="#1948">adt_packed</a>,
                    <span class="kw">match </span><a href="#2003">tag_encoding</a> {
                        TagEncoding::Direct =&gt; <span class="prelude-val">Some</span>(<a href="#2003">tag</a>.size(<a class="self" href="#1907">self</a>)),
                        <span class="kw">_ </span>=&gt; <span class="prelude-val">None</span>,
                    },
                    <a href="#2009">variant_infos</a>,
                );
            }
        }
    }
}

<span class="doccomment">/// Type size &quot;skeleton&quot;, i.e., the only information determining a type&#39;s size.
/// While this is conservative, (aside from constant sizes, only pointers,
/// newtypes thereof and null pointer optimized enums are allowed), it is
/// enough to statically check common use cases of transmute.
</span><span class="attribute">#[derive(Copy, Clone, Debug)]
</span><span class="kw">pub enum </span>SizeSkeleton&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// Any statically computable Layout.
    </span>Known(<a href="../../../rustc_target/abi/struct.Size.html">Size</a>),

    <span class="doccomment">/// A potentially-fat pointer.
    </span>Pointer {
        <span class="doccomment">/// If true, this pointer is never null.
        </span>non_zero: <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
        <span class="doccomment">/// The type which determines the unsized metadata, if any,
        /// of this pointer. Either a type parameter or a projection
        /// depending on one, with regions erased.
        </span>tail: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    },
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; SizeSkeleton&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">pub fn </span>compute(
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        param_env: ty::ParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;SizeSkeleton&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.debug_assert.html">debug_assert!</a>(!ty.has_infer_types_or_consts());

        <span class="comment">// First try computing a static layout.
        </span><span class="kw">let </span>err = <span class="kw">match </span><a href="#2058">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a href="#2059">param_env</a>.<a href="mod.rs.html#1660">and</a>(<a href="#2057">ty</a>)) {
            <span class="prelude-val">Ok</span>(layout) =&gt; {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#2042">SizeSkeleton::Known</a>(<a href="#2065">layout</a>.size));
            }
            <span class="prelude-val">Err</span>(err) =&gt; <a href="#2068">err</a>,
        };

        <span class="kw">match </span><span class="kw-2">*</span><a href="#2057">ty</a>.<a href="sty.rs.html#1639">kind</a>() {
            ty::Ref(<span class="kw">_</span>, pointee, <span class="kw">_</span>) | ty::RawPtr(<a href="sty.rs.html#43">ty::TypeAndMut</a> { ty: pointee, .. }) =&gt; {
                <span class="kw">let </span>non_zero = !<a href="#2057">ty</a>.<a href="sty.rs.html#1803">is_unsafe_ptr</a>();
                <span class="kw">let </span>tail = <a href="#2058">tcx</a>.<a href="util.rs.html#215-219">struct_tail_erasing_lifetimes</a>(<a href="#2072">pointee</a>, <a href="#2059">param_env</a>);
                <span class="kw">match </span><a href="#2074">tail</a>.<a href="sty.rs.html#1639">kind</a>() {
                    ty::Param(<span class="kw">_</span>) | ty::Projection(<span class="kw">_</span>) =&gt; {
                        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.debug_assert.html">debug_assert!</a>(tail.has_param_types_or_consts());
                        <span class="prelude-val">Ok</span>(<a href="#2045">SizeSkeleton::Pointer</a> { <a href="#2073">non_zero</a>, tail: <a href="#2058">tcx</a>.<a href="erase_regions.rs.html#20-22">erase_regions</a>(<a href="#2074">tail</a>) })
                    }
                    <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(
                        <span class="string">&quot;SizeSkeleton::compute({}): layout errored ({}), yet \
                              tail `{}` is not a type parameter or a projection&quot;</span>,
                        ty,
                        err,
                        tail
                    ),
                }
            }

            ty::Adt(def, substs) =&gt; {
                <span class="comment">// Only newtypes and enums w/ nullable pointer optimization.
                </span><span class="kw">if </span>def.is_union() || def.variants().is_empty() || def.variants().len() &gt; <span class="number">2 </span>{
                    <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#2064">err</a>);
                }

                <span class="comment">// Get a zero-sized variant or a pointer newtype.
                </span><span class="kw">let </span>zero_or_ptr_variant = |i| {
                    <span class="kw">let </span>i = VariantIdx::new(<a href="#2097">i</a>);
                    <span class="kw">let </span>fields =
                        <a href="#2090">def</a>.<a href="adt.rs.html#181">variant</a>(<a href="#2098">i</a>).fields.iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">map</a>(|field| {
                            SizeSkeleton::compute(<a href="#2100">field</a>.<a href="mod.rs.html#2095">ty</a>(<a href="#2058">tcx</a>, <a href="#2090">substs</a>), <a href="#2058">tcx</a>, <a href="#2059">param_env</a>)
                        });
                    <span class="kw">let </span><span class="kw-2">mut </span>ptr = <span class="prelude-val">None</span>;
                    <span class="kw">for </span>field <span class="kw">in </span>fields {
                        <span class="kw">let </span>field = field<span class="question-mark">?</span>;
                        <span class="kw">match </span>field {
                            SizeSkeleton::Known(size) =&gt; {
                                <span class="kw">if </span>size.bytes() &gt; <span class="number">0 </span>{
                                    <span class="kw">return </span><span class="prelude-val">Err</span>(err);
                                }
                            }
                            SizeSkeleton::Pointer { .. } =&gt; {
                                <span class="kw">if </span>ptr.is_some() {
                                    <span class="kw">return </span><span class="prelude-val">Err</span>(err);
                                }
                                ptr = <span class="prelude-val">Some</span>(field);
                            }
                        }
                    }
                    <span class="prelude-val">Ok</span>(<a href="#2103">ptr</a>)
                };

                <span class="kw">let </span>v0 = zero_or_ptr_variant(<span class="number">0</span>)<span class="question-mark">?</span>;
                <span class="comment">// Newtype.
                </span><span class="kw">if </span>def.variants().len() == <span class="number">1 </span>{
                    <span class="kw">if let </span><span class="prelude-val">Some</span>(<a href="#2045">SizeSkeleton::Pointer</a> { non_zero, tail }) = <a href="#2123">v0</a> {
                        <span class="kw">return </span><span class="prelude-val">Ok</span>(<a href="#2045">SizeSkeleton::Pointer</a> {
                            non_zero: <a href="#2126">non_zero</a>
                                || <span class="kw">match </span><a href="#2058">tcx</a>.<a href="context.rs.html#1195">layout_scalar_valid_range</a>(<a href="#2090">def</a>.<a href="adt.rs.html#171">did</a>()) {
                                    (Bound::Included(start), Bound::Unbounded) =&gt; <a href="#2130">start</a> &gt; <span class="number">0</span>,
                                    (Bound::Included(start), Bound::Included(end)) =&gt; {
                                        <span class="number">0 </span>&lt; <a href="#2131">start</a> &amp;&amp; <a href="#2131">start</a> &lt; <a href="#2131">end</a>
                                    }
                                    <span class="kw">_ </span>=&gt; <span class="bool-val">false</span>,
                                },
                            <a href="#2126">tail</a>,
                        });
                    } <span class="kw">else </span>{
                        <span class="kw">return </span><span class="prelude-val">Err</span>(<a href="#2064">err</a>);
                    }
                }

                <span class="kw">let </span>v1 = zero_or_ptr_variant(<span class="number">1</span>)<span class="question-mark">?</span>;
                <span class="comment">// Nullable pointer enum optimization.
                </span><span class="kw">match </span>(<a href="#2123">v0</a>, <a href="#2143">v1</a>) {
                    (<span class="prelude-val">Some</span>(<a href="#2045">SizeSkeleton::Pointer</a> { non_zero: <span class="bool-val">true</span>, tail }), <span class="prelude-val">None</span>)
                    | (<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<a href="#2045">SizeSkeleton::Pointer</a> { non_zero: <span class="bool-val">true</span>, tail })) =&gt; {
                        <span class="prelude-val">Ok</span>(<a href="#2045">SizeSkeleton::Pointer</a> { non_zero: <span class="bool-val">false</span>, <a href="#2146">tail</a> })
                    }
                    <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(<a href="#2064">err</a>),
                }
            }

            ty::Projection(<span class="kw">_</span>) | ty::Opaque(..) =&gt; {
                <span class="kw">let </span>normalized = <a href="#2058">tcx</a>.<a href="normalize_erasing_regions.rs.html#40-42">normalize_erasing_regions</a>(<a href="#2059">param_env</a>, <a href="#2057">ty</a>);
                <span class="kw">if </span>ty == normalized {
                    <span class="prelude-val">Err</span>(<a href="#2064">err</a>)
                } <span class="kw">else </span>{
                    SizeSkeleton::compute(<a href="#2155">normalized</a>, <a href="#2058">tcx</a>, <a href="#2059">param_env</a>)
                }
            }

            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(<a href="#2064">err</a>),
        }
    }

    <span class="kw">pub fn </span>same_size(<span class="self">self</span>, other: SizeSkeleton&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
        <span class="kw">match </span>(<a class="self" href="#2167">self</a>, <a href="#2167">other</a>) {
            (<a href="#2042">SizeSkeleton::Known</a>(a), <a href="#2042">SizeSkeleton::Known</a>(b)) =&gt; <a href="#2169">a</a> == <a href="#2169">b</a>,
            (<a href="#2045">SizeSkeleton::Pointer</a> { tail: a, .. }, <a href="#2045">SizeSkeleton::Pointer</a> { tail: b, .. }) =&gt; {
                <a href="#2170">a</a> == <a href="#2170">b</a>
            }
            <span class="kw">_ </span>=&gt; <span class="bool-val">false</span>,
        }
    }
}

<span class="kw">pub trait </span>HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a> {
    <span class="kw">fn </span>tcx(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;;
}

<span class="kw">pub trait </span>HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>param_env(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; ty::ParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;;
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a> <span class="kw">for </span>TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>data_layout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/abi/struct.TargetDataLayout.html">TargetDataLayout</a> {
        <span class="kw-2">&amp;</span><a class="self" href="#2188">self</a>.data_layout
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="../../../rustc_target/spec/trait.HasTargetSpec.html">HasTargetSpec</a> <span class="kw">for </span>TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>target_spec(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/spec/struct.Target.html">Target</a> {
        <span class="kw-2">&amp;</span><a class="self" href="#2194">self</a>.sess.target
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>tcx(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw-2">*</span><span class="self"><a href="#2201">self</a>
    </span>}
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a> <span class="kw">for </span>ty::query::TyCtxtAt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>data_layout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/abi/struct.TargetDataLayout.html">TargetDataLayout</a> {
        <span class="kw-2">&amp;</span><a class="self" href="#2208">self</a>.data_layout
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="../../../rustc_target/spec/trait.HasTargetSpec.html">HasTargetSpec</a> <span class="kw">for </span>ty::query::TyCtxtAt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>target_spec(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/spec/struct.Target.html">Target</a> {
        <span class="kw-2">&amp;</span><a class="self" href="#2214">self</a>.sess.target
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>ty::query::TyCtxtAt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>tcx(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw-2">**</span><span class="self"><a href="#2221">self</a>
    </span>}
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, C&gt; HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, C&gt; {
    <span class="kw">fn </span>param_env(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; ty::ParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <a class="self" href="#2227">self</a>.param_env
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, T: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a>&gt; <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a> <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, T&gt; {
    <span class="kw">fn </span>data_layout(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/abi/struct.TargetDataLayout.html">TargetDataLayout</a> {
        <a class="self" href="#2233">self</a>.tcx.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>()
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, T: <a href="../../../rustc_target/spec/trait.HasTargetSpec.html">HasTargetSpec</a>&gt; <a href="../../../rustc_target/spec/trait.HasTargetSpec.html">HasTargetSpec</a> <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, T&gt; {
    <span class="kw">fn </span>target_spec(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><a href="../../../rustc_target/spec/struct.Target.html">Target</a> {
        <a class="self" href="#2239">self</a>.tcx.<a href="../../../rustc_target/spec/trait.HasTargetSpec.html">target_spec</a>()
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, T: HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, T&gt; {
    <span class="kw">fn </span>tcx(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <a class="self" href="#2245">self</a>.tcx.<a href="#2179">tcx</a>()
    }
}

<span class="kw">pub trait </span>MaybeResult&lt;T&gt; {
    <span class="kw">type </span>Error;

    <span class="kw">fn </span>from(x: <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt;) -&gt; <span class="self">Self</span>;
    <span class="kw">fn </span>to_result(<span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt;;
}

<span class="kw">impl</span>&lt;T&gt; MaybeResult&lt;T&gt; <span class="kw">for </span>T {
    <span class="kw">type </span>Error = !;

    <span class="kw">fn </span>from(<span class="prelude-val">Ok</span>(x): <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt;) -&gt; <span class="self">Self </span>{
        <a href="#2260">x</a>
    }
    <span class="kw">fn </span>to_result(<span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt; {
        <span class="prelude-val">Ok</span>(<a class="self" href="#2263">self</a>)
    }
}

<span class="kw">impl</span>&lt;T, E&gt; MaybeResult&lt;T&gt; <span class="kw">for </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
    <span class="kw">type </span>Error = E;

    <span class="kw">fn </span>from(x: <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt;) -&gt; <span class="self">Self </span>{
        <a href="#2271">x</a>
    }
    <span class="kw">fn </span>to_result(<span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;T, <span class="self">Self</span>::Error&gt; {
        <span class="self"><a href="#2274">self</a>
    </span>}
}

<span class="kw">pub type </span>TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; = rustc_target::abi::TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;;

<span class="doccomment">/// Trait for contexts that want to be able to compute layouts of types.
/// This automatically gives access to `LayoutOf`, through a blanket `impl`.
</span><span class="kw">pub trait </span>LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt;: <a href="../../../rustc_target/abi/trait.HasDataLayout.html">HasDataLayout</a> + HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; + HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// The `TyAndLayout`-wrapping type (or `TyAndLayout` itself), which will be
    /// returned from `layout_of` (see also `handle_layout_err`).
    </span><span class="kw">type </span>LayoutOfResult: MaybeResult&lt;TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;;

    <span class="doccomment">/// `Span` to use for `tcx.at(span)`, from `layout_of`.
    </span><span class="comment">// FIXME(eddyb) perhaps make this mandatory to get contexts to track it better?
    </span><span class="attribute">#[inline]
    </span><span class="kw">fn </span>layout_tcx_at_span(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a> {
        <a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>
    }

    <span class="doccomment">/// Helper used for `layout_of`, to adapt `tcx.layout_of(...)` into a
    /// `Self::LayoutOfResult` (which does not need to be a `Result&lt;...&gt;`).
    ///
    /// Most `impl`s, which propagate `LayoutError`s, should simply return `err`,
    /// but this hook allows e.g. codegen to return only `TyAndLayout` from its
    /// `cx.layout_of(...)`, without any `Result&lt;...&gt;` around it to deal with
    /// (and any `LayoutError`s are turned into fatal errors or ICEs).
    </span><span class="kw">fn </span>handle_layout_err(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        err: LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        span: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>,
        ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; &lt;<span class="self">Self</span>::LayoutOfResult <span class="kw">as </span>MaybeResult&lt;TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;&gt;::Error;
}

<span class="doccomment">/// Blanket extension trait for contexts that can compute layouts of types.
</span><span class="kw">pub trait </span>LayoutOf&lt;<span class="lifetime">&#39;tcx</span>&gt;: LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// Computes the layout of a type. Note that this implicitly
    /// executes in &quot;reveal all&quot; mode, and will normalize the input type.
    </span><span class="attribute">#[inline]
    </span><span class="kw">fn </span>layout_of(<span class="kw-2">&amp;</span><span class="self">self</span>, ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <span class="self">Self</span>::LayoutOfResult {
        <a class="self" href="#2315">self</a>.<a href="#2324">spanned_layout_of</a>(<a href="#2315">ty</a>, <a href="../../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>)
    }

    <span class="doccomment">/// Computes the layout of a type, at `span`. Note that this implicitly
    /// executes in &quot;reveal all&quot; mode, and will normalize the input type.
    </span><span class="comment">// FIXME(eddyb) avoid passing information like this, and instead add more
    // `TyCtxt::at`-like APIs to be able to do e.g. `cx.at(span).layout_of(ty)`.
    </span><span class="attribute">#[inline]
    </span><span class="kw">fn </span>spanned_layout_of(<span class="kw-2">&amp;</span><span class="self">self</span>, ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;, span: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>) -&gt; <span class="self">Self</span>::LayoutOfResult {
        <span class="kw">let </span>span = <span class="kw">if </span>!span.is_dummy() { <a href="#2324">span</a> } <span class="kw">else </span>{ <a class="self" href="#2324">self</a>.<a href="#2291">layout_tcx_at_span</a>() };
        <span class="kw">let </span>tcx = <a class="self" href="#2324">self</a>.<a href="#2179">tcx</a>().<a href="query.rs.html#98">at</a>(<a href="#2325">span</a>);

        <a href="#2253">MaybeResult::from</a>(
            <a href="#2326">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a class="self" href="#2324">self</a>.<a href="#2183">param_env</a>().<a href="mod.rs.html#1660">and</a>(<a href="#2324">ty</a>))
                .map_err(|err| <a class="self" href="#2324">self</a>.<a href="#2302-2307">handle_layout_err</a>(<a href="#2330">err</a>, <a href="#2325">span</a>, <a href="#2324">ty</a>)),
        )
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, C: LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; LayoutOf&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>C {}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">type </span>LayoutOfResult = <span class="prelude-ty">Result</span>&lt;TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;;

    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>handle_layout_err(<span class="kw-2">&amp;</span><span class="self">self</span>, err: LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;, <span class="kw">_</span>: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>, <span class="kw">_</span>: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <a href="#2341">err</a>
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, ty::query::TyCtxtAt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">type </span>LayoutOfResult = <span class="prelude-ty">Result</span>&lt;TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;, LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;;

    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>layout_tcx_at_span(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a> {
        <a class="self" href="#2350">self</a>.tcx.span
    }

    <span class="attribute">#[inline]
    </span><span class="kw">fn </span>handle_layout_err(<span class="kw-2">&amp;</span><span class="self">self</span>, err: LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;, <span class="kw">_</span>: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>, <span class="kw">_</span>: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <a href="#2355">err</a>
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, C&gt; TyAbiInterface&lt;<span class="lifetime">&#39;tcx</span>, C&gt; <span class="kw">for </span>Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;
<span class="kw">where
    </span>C: HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; + HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;,
{
    <span class="kw">fn </span>ty_and_layout_for_variant(
        this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        cx: <span class="kw-2">&amp;</span>C,
        variant_index: <a href="../../../rustc_target/abi/struct.VariantIdx.html">VariantIdx</a>,
    ) -&gt; TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">let </span>layout = <span class="kw">match </span><a href="#2365">this</a>.variants {
            <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index }
                <span class="comment">// If all variants but one are uninhabited, the variant layout is the enum layout.
                </span><span class="kw">if </span><a href="#2370">index</a> == <a href="#2367">variant_index</a> &amp;&amp;
                <span class="comment">// Don&#39;t confuse variants of uninhabited enums with the enum itself.
                // For more details see https://github.com/rust-lang/rust/issues/69763.
                </span><a href="#2365">this</a>.fields != FieldsShape::Primitive =&gt;
            {
                <a href="#2365">this</a>.layout
            }

            <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index } =&gt; {
                <span class="kw">let </span>tcx = <a href="#2366">cx</a>.<a href="#2179">tcx</a>();
                <span class="kw">let </span>param_env = <a href="#2366">cx</a>.<a href="#2183">param_env</a>();

                <span class="comment">// Deny calling for_variant more than once for non-Single enums.
                </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(original_layout) = <a href="#2381">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a href="#2382">param_env</a>.<a href="mod.rs.html#1660">and</a>(<a href="#2365">this</a>.ty)) {
                    <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(original_layout.variants, Variants::Single { index });
                }

                <span class="kw">let </span>fields = <span class="kw">match </span><a href="#2365">this</a>.ty.<a href="sty.rs.html#1639">kind</a>() {
                    ty::Adt(def, <span class="kw">_</span>) <span class="kw">if </span><a href="#2390">def</a>.<a href="adt.rs.html#176">variants</a>().is_empty() =&gt;
                        <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;for_variant called on zero-variant enum&quot;</span>),
                    ty::Adt(def, <span class="kw">_</span>) =&gt; <a href="#2392">def</a>.<a href="adt.rs.html#181">variant</a>(<a href="#2367">variant_index</a>).fields.len(),
                    <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(),
                };
                <a href="#2381">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(<a href="../../../rustc_target/abi/struct.LayoutS.html">LayoutS</a> {
                    variants: <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index: <a href="#2367">variant_index</a> },
                    fields: <span class="kw">match </span>NonZeroUsize::new(<a href="#2389">fields</a>) {
                        <span class="prelude-val">Some</span>(fields) =&gt; FieldsShape::Union(<a href="#2398">fields</a>),
                        <span class="prelude-val">None </span>=&gt; <a href="../../../rustc_target/abi/enum.FieldsShape.html">FieldsShape::Arbitrary</a> { offsets: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[], memory_index: <a class="macro" href="https://doc.rust-lang.org/nightly/alloc/macro.vec.html">vec!</a>[] },
                    },
                    abi: Abi::Uninhabited,
                    largest_niche: <span class="prelude-val">None</span>,
                    align: <a href="#2381">tcx</a>.data_layout.i8_align,
                    size: Size::ZERO,
                })
            }

            <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> { <span class="kw-2">ref </span>variants, .. } =&gt; <a href="#2408">variants</a>[<a href="#2367">variant_index</a>],
        };

        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(<span class="kw-2">*</span>layout.variants(), Variants::Single { index: variant_index });

        <a href="#2279">TyAndLayout</a> { ty: <a href="#2365">this</a>.ty, <a href="#2369">layout</a> }
    }

    <span class="kw">fn </span>ty_and_layout_field(this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;, cx: <span class="kw-2">&amp;</span>C, i: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">enum </span>TyMaybeWithLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
            Ty(Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;),
            TyAndLayout(TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;),
        }

        <span class="kw">fn </span>field_ty_or_layout&lt;<span class="lifetime">&#39;tcx</span>&gt;(
            this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
            cx: <span class="kw-2">&amp;</span>(<span class="kw">impl </span>HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; + HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;),
            i: <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
        ) -&gt; TyMaybeWithLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
            <span class="kw">let </span>tcx = <a href="#2424">cx</a>.<a href="#2179">tcx</a>();
            <span class="kw">let </span>tag_layout = |tag: <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar</a>| -&gt; TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
                <a href="#2279">TyAndLayout</a> {
                    layout: <a href="#2427">tcx</a>.<a href="context.rs.html#2245-2251">intern_layout</a>(LayoutS::scalar(<a href="#2424">cx</a>, <a href="#2428">tag</a>)),
                    ty: <a href="#2428">tag</a>.primitive().<a href="#157">to_ty</a>(<a href="#2427">tcx</a>),
                }
            };

            <span class="kw">match </span><span class="kw-2">*</span><a href="#2423">this</a>.ty.<a href="sty.rs.html#1639">kind</a>() {
                ty::Bool
                | ty::Char
                | ty::Int(<span class="kw">_</span>)
                | ty::Uint(<span class="kw">_</span>)
                | ty::Float(<span class="kw">_</span>)
                | ty::FnPtr(<span class="kw">_</span>)
                | ty::Never
                | ty::FnDef(..)
                | ty::GeneratorWitness(..)
                | ty::Foreign(..)
                | ty::Dynamic(<span class="kw">_</span>, <span class="kw">_</span>, ty::Dyn) =&gt; {
                    <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;TyAndLayout::field({:?}): not applicable&quot;</span>, this)
                }

                <span class="comment">// Potentially-fat pointers.
                </span>ty::Ref(<span class="kw">_</span>, pointee, <span class="kw">_</span>) | ty::RawPtr(<a href="sty.rs.html#43">ty::TypeAndMut</a> { ty: pointee, .. }) =&gt; {
                    <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert.html">assert!</a>(i &lt; this.fields.count());

                    <span class="comment">// Reuse the fat `*T` type as its own thin pointer data field.
                    // This provides information about, e.g., DST struct pointees
                    // (which may have no non-DST form), and will work as long
                    // as the `Abi` or `FieldsShape` is checked by users.
                    </span><span class="kw">if </span>i == <span class="number">0 </span>{
                        <span class="kw">let </span>nil = <a href="#2427">tcx</a>.<a href="context.rs.html#2526">mk_unit</a>();
                        <span class="kw">let </span>unit_ptr_ty = <span class="kw">if </span>this.ty.is_unsafe_ptr() {
                            <a href="#2427">tcx</a>.<a href="context.rs.html#2497">mk_mut_ptr</a>(<a href="#2459">nil</a>)
                        } <span class="kw">else </span>{
                            <a href="#2427">tcx</a>.<a href="context.rs.html#2487">mk_mut_ref</a>(<a href="#2427">tcx</a>.lifetimes.re_static, <a href="#2459">nil</a>)
                        };

                        <span class="comment">// NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing
                        // the `Result` should always work because the type is
                        // always either `*mut ()` or `&amp;&#39;static mut ()`.
                        </span><span class="kw">return </span><a href="#2419">TyMaybeWithLayout::TyAndLayout</a>(<a href="#2279">TyAndLayout</a> {
                            ty: <a href="#2423">this</a>.ty,
                            ..<a href="#2427">tcx</a>.<a href="query.rs.html#337">layout_of</a>(ty::ParamEnv::reveal_all().<a href="mod.rs.html#1660">and</a>(<a href="#2460">unit_ptr_ty</a>)).unwrap()
                        });
                    }

                    <span class="kw">match </span><a href="#2427">tcx</a>.<a href="util.rs.html#215-219">struct_tail_erasing_lifetimes</a>(<a href="#2451">pointee</a>, <a href="#2424">cx</a>.<a href="#2183">param_env</a>()).<a href="sty.rs.html#1639">kind</a>() {
                        ty::Slice(<span class="kw">_</span>) | ty::Str =&gt; <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2427">tcx</a>.types.usize),
                        ty::Dynamic(<span class="kw">_</span>, <span class="kw">_</span>, ty::Dyn) =&gt; {
                            <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2427">tcx</a>.<a href="context.rs.html#2492">mk_imm_ref</a>(
                                <a href="#2427">tcx</a>.lifetimes.re_static,
                                <a href="#2427">tcx</a>.<a href="context.rs.html#2507">mk_array</a>(<a href="#2427">tcx</a>.types.usize, <span class="number">3</span>),
                            ))
                            <span class="comment">/* FIXME: use actual fn pointers
                            Warning: naively computing the number of entries in the
                            vtable by counting the methods on the trait + methods on
                            all parent traits does not work, because some methods can
                            be not object safe and thus excluded from the vtable.
                            Increase this counter if you tried to implement this but
                            failed to do it without duplicating a lot of code from
                            other places in the compiler: 2
                            tcx.mk_tup(&amp;[
                                tcx.mk_array(tcx.types.usize, 3),
                                tcx.mk_array(Option&lt;fn()&gt;),
                            ])
                            */
                        </span>}
                        <span class="kw">_ </span>=&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;TyAndLayout::field({:?}): not applicable&quot;</span>, this),
                    }
                }

                <span class="comment">// Arrays and slices.
                </span>ty::Array(element, <span class="kw">_</span>) | ty::Slice(element) =&gt; <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2501">element</a>),
                ty::Str =&gt; <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2427">tcx</a>.types.u8),

                <span class="comment">// Tuples, generators and closures.
                </span>ty::Closure(<span class="kw">_</span>, <span class="kw-2">ref </span>substs) =&gt; <a href="#2422-2426">field_ty_or_layout</a>(
                    <a href="#2279">TyAndLayout</a> { ty: <a href="#2505">substs</a>.<a href="subst.rs.html#259">as_closure</a>().<a href="sty.rs.html#292">tupled_upvars_ty</a>(), ..<a href="#2423">this</a> },
                    <a href="#2424">cx</a>,
                    <a href="#2425">i</a>,
                ),

                ty::Generator(def_id, <span class="kw-2">ref </span>substs, <span class="kw">_</span>) =&gt; <span class="kw">match </span><a href="#2423">this</a>.variants {
                    <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index } =&gt; <a href="#2418">TyMaybeWithLayout::Ty</a>(
                        <a href="#2511">substs</a>
                            .<a href="subst.rs.html#267">as_generator</a>()
                            .<a href="sty.rs.html#545-549">state_tys</a>(<a href="#2511">def_id</a>, <a href="#2427">tcx</a>)
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">nth</a>(<a href="#2512">index</a>.as_usize())
                            .unwrap()
                            .<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">nth</a>(<a href="#2425">i</a>)
                            .unwrap(),
                    ),
                    <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> { tag, tag_field, .. } =&gt; {
                        <span class="kw">if </span>i == tag_field {
                            <span class="kw">return </span><a href="#2419">TyMaybeWithLayout::TyAndLayout</a>(<a href="#2428">tag_layout</a>(<a href="#2521">tag</a>));
                        }
                        <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2511">substs</a>.<a href="subst.rs.html#267">as_generator</a>().<a href="sty.rs.html#561">prefix_tys</a>().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">nth</a>(<a href="#2425">i</a>).unwrap())
                    }
                },

                ty::Tuple(tys) =&gt; <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2529">tys</a>[<a href="#2425">i</a>]),

                <span class="comment">// ADTs.
                </span>ty::Adt(def, substs) =&gt; {
                    <span class="kw">match </span><a href="#2423">this</a>.variants {
                        <a href="../../../rustc_target/abi/enum.Variants.html">Variants::Single</a> { index } =&gt; {
                            <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2532">def</a>.<a href="adt.rs.html#181">variant</a>(<a href="#2534">index</a>).fields[<a href="#2425">i</a>].<a href="mod.rs.html#2095">ty</a>(<a href="#2427">tcx</a>, <a href="#2532">substs</a>))
                        }

                        <span class="comment">// Discriminant field for enums (where applicable).
                        </span><a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> { tag, .. } =&gt; {
                            <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.assert_eq.html">assert_eq!</a>(i, <span class="number">0</span>);
                            <span class="kw">return </span><a href="#2419">TyMaybeWithLayout::TyAndLayout</a>(<a href="#2428">tag_layout</a>(<a href="#2539">tag</a>));
                        }
                    }
                }

                ty::Dynamic(<span class="kw">_</span>, <span class="kw">_</span>, ty::DynStar) =&gt; {
                    <span class="kw">if </span>i == <span class="number">0 </span>{
                        <a href="#2418">TyMaybeWithLayout::Ty</a>(<a href="#2427">tcx</a>.types.usize)
                    } <span class="kw">else if </span>i == <span class="number">1 </span>{
                        <span class="comment">// FIXME(dyn-star) same FIXME as above applies here too
                        </span><a href="#2418">TyMaybeWithLayout::Ty</a>(
                            <a href="#2427">tcx</a>.<a href="context.rs.html#2492">mk_imm_ref</a>(
                                <a href="#2427">tcx</a>.lifetimes.re_static,
                                <a href="#2427">tcx</a>.<a href="context.rs.html#2507">mk_array</a>(<a href="#2427">tcx</a>.types.usize, <span class="number">3</span>),
                            ),
                        )
                    } <span class="kw">else </span>{
                        <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;no field {i} on dyn*&quot;</span>)
                    }
                }

                ty::Projection(<span class="kw">_</span>)
                | ty::Bound(..)
                | ty::Placeholder(..)
                | ty::Opaque(..)
                | ty::Param(<span class="kw">_</span>)
                | ty::Infer(<span class="kw">_</span>)
                | ty::Error(<span class="kw">_</span>) =&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;TyAndLayout::field: unexpected type `{}`&quot;</span>, this.ty),
            }
        }

        <span class="kw">match </span><a href="#2422-2426">field_ty_or_layout</a>(<a href="#2416">this</a>, <a href="#2416">cx</a>, <a href="#2416">i</a>) {
            <a href="#2418">TyMaybeWithLayout::Ty</a>(field_ty) =&gt; {
                <a href="#2416">cx</a>.<a href="#2179">tcx</a>().<a href="query.rs.html#337">layout_of</a>(<a href="#2416">cx</a>.<a href="#2183">param_env</a>().<a href="mod.rs.html#1660">and</a>(<a href="#2573">field_ty</a>)).unwrap_or_else(|e| {
                    <a class="macro" href="../macros.rs.html#2-9">bug!</a>(
                        <span class="string">&quot;failed to get layout for `{}`: {},\n\
                         despite it being a field (#{}) of an existing layout: {:#?}&quot;</span>,
                        field_ty,
                        e,
                        i,
                        this
                    )
                })
            }
            <a href="#2419">TyMaybeWithLayout::TyAndLayout</a>(field_layout) =&gt; <a href="#2585">field_layout</a>,
        }
    }

    <span class="kw">fn </span>ty_and_layout_pointee_info_at(
        this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        cx: <span class="kw-2">&amp;</span>C,
        offset: <a href="../../../rustc_target/abi/struct.Size.html">Size</a>,
    ) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="../../../rustc_target/abi/struct.PointeeInfo.html">PointeeInfo</a>&gt; {
        <span class="kw">let </span>tcx = <a href="#2591">cx</a>.<a href="#2179">tcx</a>();
        <span class="kw">let </span>param_env = <a href="#2591">cx</a>.<a href="#2183">param_env</a>();

        <span class="kw">let </span>addr_space_of_ty = |ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;| {
            <span class="kw">if </span>ty.is_fn() { <a href="#2591">cx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>().instruction_address_space } <span class="kw">else </span>{ AddressSpace::DATA }
        };

        <span class="kw">let </span>pointee_info = <span class="kw">match </span><span class="kw-2">*</span><a href="#2590">this</a>.ty.<a href="sty.rs.html#1639">kind</a>() {
            ty::RawPtr(mt) <span class="kw">if </span><a href="#2592">offset</a>.bytes() == <span class="number">0 </span>=&gt; {
                <a href="#2594">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a href="#2595">param_env</a>.<a href="mod.rs.html#1660">and</a>(<a href="#2602">mt</a>.ty)).ok().map(|layout| <a href="../../../rustc_target/abi/struct.PointeeInfo.html">PointeeInfo</a> {
                    size: <a href="#2603">layout</a>.size,
                    align: <a href="#2603">layout</a>.align.abi,
                    safe: <span class="prelude-val">None</span>,
                    address_space: <a href="#2597">addr_space_of_ty</a>(<a href="#2602">mt</a>.ty),
                })
            }
            ty::FnPtr(fn_sig) <span class="kw">if </span><a href="#2592">offset</a>.bytes() == <span class="number">0 </span>=&gt; {
                <a href="#2594">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a href="#2595">param_env</a>.<a href="mod.rs.html#1660">and</a>(<a href="#2594">tcx</a>.<a href="context.rs.html#2541">mk_fn_ptr</a>(<a href="#2610">fn_sig</a>))).ok().map(|layout| <a href="../../../rustc_target/abi/struct.PointeeInfo.html">PointeeInfo</a> {
                    size: <a href="#2611">layout</a>.size,
                    align: <a href="#2611">layout</a>.align.abi,
                    safe: <span class="prelude-val">None</span>,
                    address_space: <a href="#2591">cx</a>.<a href="../../../rustc_target/abi/trait.HasDataLayout.html">data_layout</a>().instruction_address_space,
                })
            }
            ty::Ref(<span class="kw">_</span>, ty, mt) <span class="kw">if </span><a href="#2592">offset</a>.bytes() == <span class="number">0 </span>=&gt; {
                <span class="kw">let </span>address_space = <a href="#2597">addr_space_of_ty</a>(<a href="#2618">ty</a>);
                <span class="kw">let </span>kind = <span class="kw">if </span>tcx.sess.opts.optimize == OptLevel::No {
                    <span class="comment">// Use conservative pointer kind if not optimizing. This saves us the
                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias
                    // attributes in LLVM have compile-time cost even in unoptimized builds).
                    </span>PointerKind::SharedMutable
                } <span class="kw">else </span>{
                    <span class="kw">match </span><a href="#2618">mt</a> {
                        hir::Mutability::Not =&gt; {
                            <span class="kw">if </span>ty.is_freeze(tcx.at(DUMMY_SP), cx.param_env()) {
                                PointerKind::Frozen
                            } <span class="kw">else </span>{
                                PointerKind::SharedMutable
                            }
                        }
                        hir::Mutability::Mut =&gt; {
                            <span class="comment">// References to self-referential structures should not be considered
                            // noalias, as another pointer to the structure can be obtained, that
                            // is not based-on the original reference. We consider all !Unpin
                            // types to be potentially self-referential here.
                            </span><span class="kw">if </span>ty.is_unpin(tcx.at(DUMMY_SP), cx.param_env()) {
                                PointerKind::UniqueBorrowed
                            } <span class="kw">else </span>{
                                PointerKind::UniqueBorrowedPinned
                            }
                        }
                    }
                };

                <a href="#2594">tcx</a>.<a href="query.rs.html#337">layout_of</a>(<a href="#2595">param_env</a>.<a href="mod.rs.html#1660">and</a>(<a href="#2618">ty</a>)).ok().map(|layout| <a href="../../../rustc_target/abi/struct.PointeeInfo.html">PointeeInfo</a> {
                    size: <a href="#2648">layout</a>.size,
                    align: <a href="#2648">layout</a>.align.abi,
                    safe: <span class="prelude-val">Some</span>(<a href="#2620">kind</a>),
                    <a href="#2619">address_space</a>,
                })
            }

            <span class="kw">_ </span>=&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>data_variant = <span class="kw">match </span><a href="#2590">this</a>.variants {
                    <span class="comment">// Within the discriminant field, only the niche itself is
                    // always initialized, so we only check for a pointer at its
                    // offset.
                    //
                    // If the niche is a pointer, it&#39;s either valid (according
                    // to its type), or null (which the niche field&#39;s scalar
                    // validity range encodes).  This allows using
                    // `dereferenceable_or_null` for e.g., `Option&lt;&amp;T&gt;`, and
                    // this will continue to work as long as we don&#39;t start
                    // using more niches than just null (e.g., the first page of
                    // the address space, or unaligned pointers).
                    </span><a href="../../../rustc_target/abi/enum.Variants.html">Variants::Multiple</a> {
                        tag_encoding: <a href="../../../rustc_target/abi/enum.TagEncoding.html">TagEncoding::Niche</a> { untagged_variant, .. },
                        tag_field,
                        ..
                    } <span class="kw">if </span><a href="#2590">this</a>.fields.offset(<a href="#2671">tag_field</a>) == <a href="#2592">offset</a> =&gt; {
                        <span class="prelude-val">Some</span>(<a href="#2590">this</a>.for_variant(<a href="#2591">cx</a>, <a href="#2670">untagged_variant</a>))
                    }
                    <span class="kw">_ </span>=&gt; <span class="prelude-val">Some</span>(<a href="#2590">this</a>),
                };

                <span class="kw">if let </span><span class="prelude-val">Some</span>(variant) = <a href="#2657">data_variant</a> {
                    <span class="comment">// We&#39;re not interested in any unions.
                    </span><span class="kw">if let </span>FieldsShape::Union(<span class="kw">_</span>) = <a href="#2679">variant</a>.fields {
                        <a href="#2657">data_variant</a> = <span class="prelude-val">None</span>;
                    }
                }

                <span class="kw">let </span><span class="kw-2">mut </span>result = <span class="prelude-val">None</span>;

                <span class="kw">if let </span><span class="prelude-val">Some</span>(variant) = <a href="#2657">data_variant</a> {
                    <span class="kw">let </span>ptr_end = <a href="#2592">offset</a> + Pointer.size(<a href="#2591">cx</a>);
                    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..variant.fields.count() {
                        <span class="kw">let </span>field_start = variant.fields.offset(i);
                        <span class="kw">if </span>field_start &lt;= offset {
                            <span class="kw">let </span>field = variant.field(cx, i);
                            result = field.to_result().ok().and_then(|field| {
                                <span class="kw">if </span>ptr_end &lt;= field_start + field.size {
                                    <span class="comment">// We found the right field, look inside it.
                                    </span><span class="kw">let </span>field_info =
                                        field.pointee_info_at(cx, offset - field_start);
                                    field_info
                                } <span class="kw">else </span>{
                                    <span class="prelude-val">None
                                </span>}
                            });
                            <span class="kw">if </span>result.is_some() {
                                <span class="kw">break</span>;
                            }
                        }
                    }
                }

                <span class="comment">// FIXME(eddyb) This should be for `ptr::Unique&lt;T&gt;`, not `Box&lt;T&gt;`.
                </span><span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref mut </span>pointee) = <a href="#2686">result</a> {
                    <span class="kw">if let </span>ty::Adt(def, <span class="kw">_</span>) = <a href="#2590">this</a>.ty.<a href="sty.rs.html#1639">kind</a>() {
                        <span class="kw">if </span>def.is_box() &amp;&amp; offset.bytes() == <span class="number">0 </span>{
                            <a href="#2712">pointee</a>.safe = <span class="prelude-val">Some</span>(PointerKind::UniqueOwned);
                        }
                    }
                }

                <a href="#2686">result</a>
            }
        };

        <a class="macro" href="https://docs.rs/tracing/0.1.35/tracing/macro.debug.html">debug!</a>(
            <span class="string">&quot;pointee_info_at (offset={:?}, type kind: {:?}) =&gt; {:?}&quot;</span>,
            offset,
            this.ty.kind(),
            pointee_info
        );

        <a href="#2601">pointee_info</a>
    }

    <span class="kw">fn </span>is_adt(this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.matches.html">matches!</a>(this.ty.kind(), ty::Adt(..))
    }

    <span class="kw">fn </span>is_never(this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
        <a href="#2738">this</a>.ty.<a href="sty.rs.html#1639">kind</a>() == <span class="kw-2">&amp;</span>ty::Never
    }

    <span class="kw">fn </span>is_tuple(this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.matches.html">matches!</a>(this.ty.kind(), ty::Tuple(..))
    }

    <span class="kw">fn </span>is_unit(this: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.matches.html">matches!</a>(this.ty.kind(), ty::Tuple(list) <span class="kw">if </span>list.len() == <span class="number">0</span>)
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; ty::Instance&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="comment">// NOTE(eddyb) this is private to avoid using it from outside of
    // `fn_abi_of_instance` - any other uses are either too high-level
    // for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),
    // or should go through `FnAbi` instead, to avoid losing any
    // adjustments `fn_abi_of_instance` might be performing.
    </span><span class="attribute">#[tracing::instrument(level = <span class="string">&quot;debug&quot;</span>, skip(tcx, param_env))]
    </span><span class="kw">fn </span>fn_sig_for_fn_abi(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        param_env: ty::ParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; ty::PolyFnSig&lt;<span class="lifetime">&#39;tcx</span>&gt; {
        <span class="kw">let </span>ty = <span class="self">self</span>.ty(tcx, param_env);
        <span class="kw">match </span><span class="kw-2">*</span>ty.kind() {
            ty::FnDef(..) =&gt; {
                <span class="comment">// HACK(davidtwco,eddyb): This is a workaround for polymorphization considering
                // parameters unused if they show up in the signature, but not in the `mir::Body`
                // (i.e. due to being inside a projection that got normalized, see
                // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping
                // track of a polymorphization `ParamEnv` to allow normalizing later.
                </span><span class="kw">let </span><span class="kw-2">mut </span>sig = <span class="kw">match </span><span class="kw-2">*</span>ty.kind() {
                    ty::FnDef(def_id, substs) =&gt; tcx
                        .normalize_erasing_regions(tcx.param_env(def_id), tcx.bound_fn_sig(def_id))
                        .subst(tcx, substs),
                    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
                };

                <span class="kw">if let </span>ty::InstanceDef::VTableShim(..) = <span class="self">self</span>.def {
                    <span class="comment">// Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.
                    </span>sig = sig.map_bound(|<span class="kw-2">mut </span>sig| {
                        <span class="kw">let </span><span class="kw-2">mut </span>inputs_and_output = sig.inputs_and_output.to_vec();
                        inputs_and_output[<span class="number">0</span>] = tcx.mk_mut_ptr(inputs_and_output[<span class="number">0</span>]);
                        sig.inputs_and_output = tcx.intern_type_list(<span class="kw-2">&amp;</span>inputs_and_output);
                        sig
                    });
                }
                sig
            }
            ty::Closure(def_id, substs) =&gt; {
                <span class="kw">let </span>sig = substs.as_closure().sig();

                <span class="kw">let </span>bound_vars = tcx.mk_bound_variable_kinds(
                    sig.bound_vars()
                        .iter()
                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),
                );
                <span class="kw">let </span>br = ty::BoundRegion {
                    var: ty::BoundVar::from_usize(bound_vars.len() - <span class="number">1</span>),
                    kind: ty::BoundRegionKind::BrEnv,
                };
                <span class="kw">let </span>env_region = ty::ReLateBound(ty::INNERMOST, br);
                <span class="kw">let </span>env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();

                <span class="kw">let </span>sig = sig.skip_binder();
                ty::Binder::bind_with_vars(
                    tcx.mk_fn_sig(
                        iter::once(env_ty).chain(sig.inputs().iter().cloned()),
                        sig.output(),
                        sig.c_variadic,
                        sig.unsafety,
                        sig.abi,
                    ),
                    bound_vars,
                )
            }
            ty::Generator(<span class="kw">_</span>, substs, <span class="kw">_</span>) =&gt; {
                <span class="kw">let </span>sig = substs.as_generator().poly_sig();

                <span class="kw">let </span>bound_vars = tcx.mk_bound_variable_kinds(
                    sig.bound_vars()
                        .iter()
                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),
                );
                <span class="kw">let </span>br = ty::BoundRegion {
                    var: ty::BoundVar::from_usize(bound_vars.len() - <span class="number">1</span>),
                    kind: ty::BoundRegionKind::BrEnv,
                };
                <span class="kw">let </span>env_region = ty::ReLateBound(ty::INNERMOST, br);
                <span class="kw">let </span>env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);

                <span class="kw">let </span>pin_did = tcx.require_lang_item(LangItem::Pin, <span class="prelude-val">None</span>);
                <span class="kw">let </span>pin_adt_ref = tcx.adt_def(pin_did);
                <span class="kw">let </span>pin_substs = tcx.intern_substs(<span class="kw-2">&amp;</span>[env_ty.into()]);
                <span class="kw">let </span>env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);

                <span class="kw">let </span>sig = sig.skip_binder();
                <span class="kw">let </span>state_did = tcx.require_lang_item(LangItem::GeneratorState, <span class="prelude-val">None</span>);
                <span class="kw">let </span>state_adt_ref = tcx.adt_def(state_did);
                <span class="kw">let </span>state_substs = tcx.intern_substs(<span class="kw-2">&amp;</span>[sig.yield_ty.into(), sig.return_ty.into()]);
                <span class="kw">let </span>ret_ty = tcx.mk_adt(state_adt_ref, state_substs);
                ty::Binder::bind_with_vars(
                    tcx.mk_fn_sig(
                        [env_ty, sig.resume_ty].iter(),
                        <span class="kw-2">&amp;</span>ret_ty,
                        <span class="bool-val">false</span>,
                        hir::Unsafety::Normal,
                        rustc_target::spec::abi::Abi::Rust,
                    ),
                    bound_vars,
                )
            }
            <span class="kw">_ </span>=&gt; <span class="macro">bug!</span>(<span class="string">&quot;unexpected type {:?} in Instance::fn_sig&quot;</span>, ty),
        }
    }
}

<span class="doccomment">/// Calculates whether a function&#39;s ABI can unwind or not.
///
/// This takes two primary parameters:
///
/// * `codegen_fn_attr_flags` - these are flags calculated as part of the
///   codegen attrs for a defined function. For function pointers this set of
///   flags is the empty set. This is only applicable for Rust-defined
///   functions, and generally isn&#39;t needed except for small optimizations where
///   we try to say a function which otherwise might look like it could unwind
///   doesn&#39;t actually unwind (such as for intrinsics and such).
///
/// * `abi` - this is the ABI that the function is defined with. This is the
///   primary factor for determining whether a function can unwind or not.
///
/// Note that in this case unwinding is not necessarily panicking in Rust. Rust
/// panics are implemented with unwinds on most platform (when
/// `-Cpanic=unwind`), but this also accounts for `-Cpanic=abort` build modes.
/// Notably unwinding is disallowed for more non-Rust ABIs unless it&#39;s
/// specifically in the name (e.g. `&quot;C-unwind&quot;`). Unwinding within each ABI is
/// defined for each ABI individually, but it always corresponds to some form of
/// stack-based unwinding (the exact mechanism of which varies
/// platform-by-platform).
///
/// Rust functions are classified whether or not they can unwind based on the
/// active &quot;panic strategy&quot;. In other words Rust functions are considered to
/// unwind in `-Cpanic=unwind` mode and cannot unwind in `-Cpanic=abort` mode.
/// Note that Rust supports intermingling panic=abort and panic=unwind code, but
/// only if the final panic mode is panic=abort. In this scenario any code
/// previously compiled assuming that a function can unwind is still correct, it
/// just never happens to actually unwind at runtime.
///
/// This function&#39;s answer to whether or not a function can unwind is quite
/// impactful throughout the compiler. This affects things like:
///
/// * Calling a function which can&#39;t unwind means codegen simply ignores any
///   associated unwinding cleanup.
/// * Calling a function which can unwind from a function which can&#39;t unwind
///   causes the `abort_unwinding_calls` MIR pass to insert a landing pad that
///   aborts the process.
/// * This affects whether functions have the LLVM `nounwind` attribute, which
///   affects various optimizations and codegen.
///
/// FIXME: this is actually buggy with respect to Rust functions. Rust functions
/// compiled with `-Cpanic=unwind` and referenced from another crate compiled
/// with `-Cpanic=abort` will look like they can&#39;t unwind when in fact they
/// might (from a foreign exception or similar).
</span><span class="attribute">#[inline]
#[tracing::instrument(level = <span class="string">&quot;debug&quot;</span>, skip(tcx))]
</span><span class="kw">pub fn </span>fn_can_unwind&lt;<span class="lifetime">&#39;tcx</span>&gt;(tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;, fn_def_id: <span class="prelude-ty">Option</span>&lt;<a href="../../../rustc_span/def_id/struct.DefId.html">DefId</a>&gt;, abi: <a href="../../../rustc_target/spec/abi/enum.Abi.html">SpecAbi</a>) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(did) = fn_def_id {
        <span class="comment">// Special attribute for functions which can&#39;t unwind.
        </span><span class="kw">if </span>tcx.codegen_fn_attrs(did).flags.contains(CodegenFnAttrFlags::NEVER_UNWIND) {
            <span class="kw">return </span><span class="bool-val">false</span>;
        }

        <span class="comment">// With `-C panic=abort`, all non-FFI functions are required to not unwind.
        //
        // Note that this is true regardless ABI specified on the function -- a `extern &quot;C-unwind&quot;`
        // function defined in Rust is also required to abort.
        </span><span class="kw">if </span>tcx.sess.panic_strategy() == PanicStrategy::Abort &amp;&amp; !tcx.is_foreign_item(did) {
            <span class="kw">return </span><span class="bool-val">false</span>;
        }

        <span class="comment">// With -Z panic-in-drop=abort, drop_in_place never unwinds.
        //
        // This is not part of `codegen_fn_attrs` as it can differ between crates
        // and therefore cannot be computed in core.
        </span><span class="kw">if </span>tcx.sess.opts.unstable_opts.panic_in_drop == PanicStrategy::Abort {
            <span class="kw">if </span><span class="prelude-val">Some</span>(did) == tcx.lang_items().drop_in_place_fn() {
                <span class="kw">return </span><span class="bool-val">false</span>;
            }
        }
    }

    <span class="comment">// Otherwise if this isn&#39;t special then unwinding is generally determined by
    // the ABI of the itself. ABIs like `C` have variants which also
    // specifically allow unwinding (`C-unwind`), but not all platform-specific
    // ABIs have such an option. Otherwise the only other thing here is Rust
    // itself, and those ABIs are determined by the panic strategy configured
    // for this compilation.
    //
    // Unfortunately at this time there&#39;s also another caveat. Rust [RFC
    // 2945][rfc] has been accepted and is in the process of being implemented
    // and stabilized. In this interim state we need to deal with historical
    // rustc behavior as well as plan for future rustc behavior.
    //
    // Historically functions declared with `extern &quot;C&quot;` were marked at the
    // codegen layer as `nounwind`. This happened regardless of `panic=unwind`
    // or not. This is UB for functions in `panic=unwind` mode that then
    // actually panic and unwind. Note that this behavior is true for both
    // externally declared functions as well as Rust-defined function.
    //
    // To fix this UB rustc would like to change in the future to catch unwinds
    // from function calls that may unwind within a Rust-defined `extern &quot;C&quot;`
    // function and forcibly abort the process, thereby respecting the
    // `nounwind` attribute emitted for `extern &quot;C&quot;`. This behavior change isn&#39;t
    // ready to roll out, so determining whether or not the `C` family of ABIs
    // unwinds is conditional not only on their definition but also whether the
    // `#![feature(c_unwind)]` feature gate is active.
    //
    // Note that this means that unlike historical compilers rustc now, by
    // default, unconditionally thinks that the `C` ABI may unwind. This will
    // prevent some optimization opportunities, however, so we try to scope this
    // change and only assume that `C` unwinds with `panic=unwind` (as opposed
    // to `panic=abort`).
    //
    // Eventually the check against `c_unwind` here will ideally get removed and
    // this&#39;ll be a little cleaner as it&#39;ll be a straightforward check of the
    // ABI.
    //
    // [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md
    </span><span class="kw">use </span>SpecAbi::<span class="kw-2">*</span>;
    <span class="kw">match </span>abi {
        C { unwind }
        | System { unwind }
        | Cdecl { unwind }
        | Stdcall { unwind }
        | Fastcall { unwind }
        | Vectorcall { unwind }
        | Thiscall { unwind }
        | Aapcs { unwind }
        | Win64 { unwind }
        | SysV64 { unwind } =&gt; {
            unwind
                || (!tcx.features().c_unwind &amp;&amp; tcx.sess.panic_strategy() == PanicStrategy::Unwind)
        }
        PtxKernel
        | Msp430Interrupt
        | X86Interrupt
        | AmdGpuKernel
        | EfiApi
        | AvrInterrupt
        | AvrNonBlockingInterrupt
        | CCmseNonSecureCall
        | Wasm
        | RustIntrinsic
        | PlatformIntrinsic
        | Unadjusted =&gt; <span class="bool-val">false</span>,
        Rust | RustCall | RustCold =&gt; tcx.sess.panic_strategy() == PanicStrategy::Unwind,
    }
}

<span class="attribute">#[inline]
</span><span class="kw">pub fn </span>conv_from_spec_abi(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, abi: <a href="../../../rustc_target/spec/abi/enum.Abi.html">SpecAbi</a>) -&gt; <a href="../../../rustc_target/abi/call/enum.Conv.html">Conv</a> {
    <span class="kw">use </span><a href="../../../rustc_target/spec/abi/enum.Abi.html">rustc_target::spec::abi::Abi</a>::<span class="kw-2">*</span>;
    <span class="kw">match </span><a href="#3000">tcx</a>.sess.target.adjust_abi(<a href="#3000">abi</a>) {
        RustIntrinsic | PlatformIntrinsic | Rust | RustCall =&gt; Conv::Rust,
        RustCold =&gt; Conv::RustCold,

        <span class="comment">// It&#39;s the ABI&#39;s job to select this, not ours.
        </span><a href="../../../rustc_target/spec/abi/enum.Abi.html">System</a> { .. } =&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;system abi should be selected elsewhere&quot;</span>),
        EfiApi =&gt; <a class="macro" href="../macros.rs.html#2-9">bug!</a>(<span class="string">&quot;eficall abi should be selected elsewhere&quot;</span>),

        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Stdcall</a> { .. } =&gt; Conv::X86Stdcall,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Fastcall</a> { .. } =&gt; Conv::X86Fastcall,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Vectorcall</a> { .. } =&gt; Conv::X86VectorCall,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Thiscall</a> { .. } =&gt; Conv::X86ThisCall,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">C</a> { .. } =&gt; Conv::C,
        Unadjusted =&gt; Conv::C,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Win64</a> { .. } =&gt; Conv::X86_64Win64,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">SysV64</a> { .. } =&gt; Conv::X86_64SysV,
        <a href="../../../rustc_target/spec/abi/enum.Abi.html">Aapcs</a> { .. } =&gt; Conv::ArmAapcs,
        CCmseNonSecureCall =&gt; Conv::CCmseNonSecureCall,
        PtxKernel =&gt; Conv::PtxKernel,
        Msp430Interrupt =&gt; Conv::Msp430Intr,
        X86Interrupt =&gt; Conv::X86Intr,
        AmdGpuKernel =&gt; Conv::AmdGpuKernel,
        AvrInterrupt =&gt; Conv::AvrInterrupt,
        AvrNonBlockingInterrupt =&gt; Conv::AvrNonBlockingInterrupt,
        Wasm =&gt; Conv::C,

        <span class="comment">// These API constants ought to be more specific...
        </span><a href="../../../rustc_target/spec/abi/enum.Abi.html">Cdecl</a> { .. } =&gt; Conv::C,
    }
}

<span class="doccomment">/// Error produced by attempting to compute or adjust a `FnAbi`.
</span><span class="attribute">#[derive(Copy, Clone, Debug, HashStable)]
</span><span class="kw">pub enum </span>FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// Error produced by a `layout_of` call, while computing `FnAbi` initially.
    </span>Layout(LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;),

    <span class="doccomment">/// Error produced by attempting to adjust a `FnAbi`, for a &quot;foreign&quot; ABI.
    </span>AdjustForForeignAbi(<a href="../../../rustc_target/abi/call/enum.AdjustForForeignAbiError.html">call::AdjustForForeignAbiError</a>),
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; From&lt;LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; <span class="kw">for </span>FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>from(err: LayoutError&lt;<span class="lifetime">&#39;tcx</span>&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::Layout(<a href="#3044">err</a>)
    }
}

<span class="kw">impl </span>From&lt;<a href="../../../rustc_target/abi/call/enum.AdjustForForeignAbiError.html">call::AdjustForForeignAbiError</a>&gt; <span class="kw">for </span>FnAbiError&lt;<span class="lifetime">&#39;_</span>&gt; {
    <span class="kw">fn </span>from(err: <a href="../../../rustc_target/abi/call/enum.AdjustForForeignAbiError.html">call::AdjustForForeignAbiError</a>) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::AdjustForForeignAbi(<a href="#3050">err</a>)
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">fmt::Display</a> <span class="kw">for </span>FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; <a href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html">fmt::Result</a> {
        <span class="kw">match </span><span class="self"><a href="#3056">self</a> </span>{
            <span class="self">Self</span>::Layout(err) =&gt; <a href="#3058">err</a>.<a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">fmt</a>(<a href="#3056">f</a>),
            <span class="self">Self</span>::AdjustForForeignAbi(err) =&gt; <a href="#3059">err</a>.<a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">fmt</a>(<a href="#3056">f</a>),
        }
    }
}

<span class="comment">// FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not
// just for error handling.
</span><span class="attribute">#[derive(Debug)]
</span><span class="kw">pub enum </span>FnAbiRequest&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    OfFnPtr { sig: ty::PolyFnSig&lt;<span class="lifetime">&#39;tcx</span>&gt;, extra_args: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; },
    OfInstance { instance: ty::Instance&lt;<span class="lifetime">&#39;tcx</span>&gt;, extra_args: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; },
}

<span class="doccomment">/// Trait for contexts that want to be able to compute `FnAbi`s.
/// This automatically gives access to `FnAbiOf`, through a blanket `impl`.
</span><span class="kw">pub trait </span>FnAbiOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt;: LayoutOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// The `&amp;FnAbi`-wrapping type (or `&amp;FnAbi` itself), which will be
    /// returned from `fn_abi_of_*` (see also `handle_fn_abi_err`).
    </span><span class="kw">type </span>FnAbiOfResult: MaybeResult&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;&gt;;

    <span class="doccomment">/// Helper used for `fn_abi_of_*`, to adapt `tcx.fn_abi_of_*(...)` into a
    /// `Self::FnAbiOfResult` (which does not need to be a `Result&lt;...&gt;`).
    ///
    /// Most `impl`s, which propagate `FnAbiError`s, should simply return `err`,
    /// but this hook allows e.g. codegen to return only `&amp;FnAbi` from its
    /// `cx.fn_abi_of_*(...)`, without any `Result&lt;...&gt;` around it to deal with
    /// (and any `FnAbiError`s are turned into fatal errors or ICEs).
    </span><span class="kw">fn </span>handle_fn_abi_err(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        err: FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        span: <a href="../../../rustc_span/span_encoding/struct.Span.html">Span</a>,
        fn_abi_request: FnAbiRequest&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    ) -&gt; &lt;<span class="self">Self</span>::FnAbiOfResult <span class="kw">as </span>MaybeResult&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;&gt;&gt;::Error;
}

<span class="doccomment">/// Blanket extension trait for contexts that can compute `FnAbi`s.
</span><span class="kw">pub trait </span>FnAbiOf&lt;<span class="lifetime">&#39;tcx</span>&gt;: FnAbiOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="doccomment">/// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.
    ///
    /// NB: this doesn&#39;t handle virtual calls - those should use `fn_abi_of_instance`
    /// instead, where the instance is an `InstanceDef::Virtual`.
    </span><span class="attribute">#[inline]
    </span><span class="kw">fn </span>fn_abi_of_fn_ptr(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        sig: ty::PolyFnSig&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        extra_args: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
    ) -&gt; <span class="self">Self</span>::FnAbiOfResult {
        <span class="comment">// FIXME(eddyb) get a better `span` here.
        </span><span class="kw">let </span>span = <a class="self" href="#3102">self</a>.<a href="#2291">layout_tcx_at_span</a>();
        <span class="kw">let </span>tcx = <a class="self" href="#3102">self</a>.<a href="#2179">tcx</a>().<a href="query.rs.html#98">at</a>(<a href="#3107">span</a>);

        <a href="#2253">MaybeResult::from</a>(<a href="#3108">tcx</a>.<a href="query.rs.html#337">fn_abi_of_fn_ptr</a>(<a class="self" href="#3102">self</a>.<a href="#2183">param_env</a>().<a href="mod.rs.html#1660">and</a>((<a href="#3103">sig</a>, <a href="#3104">extra_args</a>))).map_err(
            |err| <a class="self" href="#3102">self</a>.<a href="#3086-3091">handle_fn_abi_err</a>(<a href="#3111">err</a>, <a href="#3107">span</a>, <a href="#3068">FnAbiRequest::OfFnPtr</a> { <a href="#3103">sig</a>, <a href="#3104">extra_args</a> }),
        ))
    }

    <span class="doccomment">/// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for
    /// direct calls to an `fn`.
    ///
    /// NB: that includes virtual calls, which are represented by &quot;direct calls&quot;
    /// to an `InstanceDef::Virtual` instance (of `&lt;dyn Trait as Trait&gt;::fn`).
    </span><span class="attribute">#[inline]
    #[tracing::instrument(level = <span class="string">&quot;debug&quot;</span>, skip(<span class="self">self</span>))]
    </span><span class="kw">fn </span>fn_abi_of_instance(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        instance: ty::Instance&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        extra_args: <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
    ) -&gt; <span class="self">Self</span>::FnAbiOfResult {
        <span class="comment">// FIXME(eddyb) get a better `span` here.
        </span><span class="kw">let </span>span = <span class="self">self</span>.layout_tcx_at_span();
        <span class="kw">let </span>tcx = <span class="self">self</span>.tcx().at(span);

        MaybeResult::from(
            tcx.fn_abi_of_instance(<span class="self">self</span>.param_env().and((instance, extra_args))).map_err(|err| {
                <span class="comment">// HACK(eddyb) at least for definitions of/calls to `Instance`s,
                // we can get some kind of span even if one wasn&#39;t provided.
                // However, we don&#39;t do this early in order to avoid calling
                // `def_span` unconditionally (which may have a perf penalty).
                </span><span class="kw">let </span>span = <span class="kw">if </span>!span.is_dummy() { span } <span class="kw">else </span>{ tcx.def_span(instance.def_id()) };
                <span class="self">self</span>.handle_fn_abi_err(err, span, FnAbiRequest::OfInstance { instance, extra_args })
            }),
        )
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>, C: FnAbiOfHelpers&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; FnAbiOf&lt;<span class="lifetime">&#39;tcx</span>&gt; <span class="kw">for </span>C {}

<span class="kw">fn </span>fn_abi_of_fn_ptr&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    query: ty::ParamEnvAnd&lt;<span class="lifetime">&#39;tcx</span>, (ty::PolyFnSig&lt;<span class="lifetime">&#39;tcx</span>&gt;, <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;)&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;, FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">let </span>(param_env, (sig, extra_args)) = <a href="#3148">query</a>.<a href="mod.rs.html#1701">into_parts</a>();

    <a href="#267">LayoutCx</a> { <a href="#3147">tcx</a>, <a href="#3150">param_env</a> }.<a href="#3268-3271">fn_abi_new_uncached</a>(<a href="#3150">sig</a>, <a href="#3150">extra_args</a>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="bool-val">false</span>)
}

<span class="kw">fn </span>fn_abi_of_instance&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    query: ty::ParamEnvAnd&lt;<span class="lifetime">&#39;tcx</span>, (ty::Instance&lt;<span class="lifetime">&#39;tcx</span>&gt;, <span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>ty::List&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;)&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;, FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="kw">let </span>(param_env, (instance, extra_args)) = <a href="#3157">query</a>.<a href="mod.rs.html#1701">into_parts</a>();

    <span class="kw">let </span>sig = <a href="#3159">instance</a>.<a href="#2757">fn_sig_for_fn_abi</a>(<a href="#3156">tcx</a>, <a href="#3159">param_env</a>);

    <span class="kw">let </span>caller_location = <span class="kw">if </span>instance.def.requires_caller_location(tcx) {
        <span class="prelude-val">Some</span>(<a href="#3156">tcx</a>.<a href="context.rs.html#1685">caller_location_ty</a>())
    } <span class="kw">else </span>{
        <span class="prelude-val">None
    </span>};

    <a href="#267">LayoutCx</a> { <a href="#3156">tcx</a>, <a href="#3159">param_env</a> }.<a href="#3268-3271">fn_abi_new_uncached</a>(
        <a href="#3161">sig</a>,
        <a href="#3159">extra_args</a>,
        <a href="#3163">caller_location</a>,
        <span class="prelude-val">Some</span>(<a href="#3159">instance</a>.<a href="instance.rs.html#332">def_id</a>()),
        <a class="macro" href="https://doc.rust-lang.org/nightly/core/macro.matches.html">matches!</a>(instance.def, ty::InstanceDef::Virtual(..)),
    )
}

<span class="comment">// Handle safe Rust thin and fat pointers.
</span><span class="kw">pub fn </span>adjust_for_rust_scalar&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    cx: LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
    attrs: <span class="kw-2">&amp;mut </span><a href="../../../rustc_target/abi/call/struct.ArgAttributes.html">ArgAttributes</a>,
    scalar: <a href="../../../rustc_target/abi/enum.Scalar.html">Scalar</a>,
    layout: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    offset: <a href="../../../rustc_target/abi/struct.Size.html">Size</a>,
    is_return: <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) {
    <span class="comment">// Booleans are always a noundef i1 that needs to be zero-extended.
    </span><span class="kw">if </span>scalar.is_bool() {
        <a href="#3181">attrs</a>.ext(ArgExtension::Zext);
        <a href="#3181">attrs</a>.set(ArgAttribute::NoUndef);
        <span class="kw">return</span>;
    }

    <span class="comment">// Scalars which have invalid values cannot be undef.
    </span><span class="kw">if </span>!scalar.is_always_valid(<span class="kw-2">&amp;</span>cx) {
        <a href="#3181">attrs</a>.set(ArgAttribute::NoUndef);
    }

    <span class="comment">// Only pointer types handled below.
    </span><span class="kw">let </span><a href="../../../rustc_target/abi/enum.Scalar.html">Scalar::Initialized</a> { value: Pointer, valid_range} = <a href="#3182">scalar</a> <span class="kw">else </span>{ <span class="kw">return </span>};

    <span class="kw">if </span>!valid_range.contains(<span class="number">0</span>) {
        <a href="#3181">attrs</a>.set(ArgAttribute::NonNull);
    }

    <span class="kw">if let </span><span class="prelude-val">Some</span>(pointee) = <a href="#3183">layout</a>.pointee_info_at(<span class="kw-2">&amp;</span><a href="#3180">cx</a>, <a href="#3184">offset</a>) {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(kind) = <a href="#3206">pointee</a>.safe {
            <a href="#3181">attrs</a>.pointee_align = <span class="prelude-val">Some</span>(<a href="#3206">pointee</a>.align);

            <span class="comment">// `Box` (`UniqueBorrowed`) are not necessarily dereferenceable
            // for the entire duration of the function as they can be deallocated
            // at any time. Same for shared mutable references. If LLVM had a
            // way to say &quot;dereferenceable on entry&quot; we could use it here.
            </span><a href="#3181">attrs</a>.pointee_size = <span class="kw">match </span><a href="#3207">kind</a> {
                PointerKind::UniqueBorrowed
                | PointerKind::UniqueBorrowedPinned
                | PointerKind::Frozen =&gt; <a href="#3206">pointee</a>.size,
                PointerKind::SharedMutable | PointerKind::UniqueOwned =&gt; Size::ZERO,
            };

            <span class="comment">// `Box`, `&amp;T`, and `&amp;mut T` cannot be undef.
            // Note that this only applies to the value of the pointer itself;
            // this attribute doesn&#39;t make it UB for the pointed-to data to be undef.
            </span><a href="#3181">attrs</a>.set(ArgAttribute::NoUndef);

            <span class="comment">// The aliasing rules for `Box&lt;T&gt;` are still not decided, but currently we emit
            // `noalias` for it. This can be turned off using an unstable flag.
            // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326
            </span><span class="kw">let </span>noalias_for_box = <a href="#3180">cx</a>.tcx.sess.opts.unstable_opts.box_noalias.unwrap_or(<span class="bool-val">true</span>);

            <span class="comment">// `&amp;mut` pointer parameters never alias other parameters,
            // or mutable global data
            //
            // `&amp;T` where `T` contains no `UnsafeCell&lt;U&gt;` is immutable,
            // and can be marked as both `readonly` and `noalias`, as
            // LLVM&#39;s definition of `noalias` is based solely on memory
            // dependencies rather than pointer equality
            //
            // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute
            // for UniqueBorrowed arguments, so that the codegen backend can decide whether
            // or not to actually emit the attribute. It can also be controlled with the
            // `-Zmutable-noalias` debugging option.
            </span><span class="kw">let </span>no_alias = <span class="kw">match </span><a href="#3207">kind</a> {
                PointerKind::SharedMutable
                | PointerKind::UniqueBorrowed
                | PointerKind::UniqueBorrowedPinned =&gt; <span class="bool-val">false</span>,
                PointerKind::UniqueOwned =&gt; <a href="#3229">noalias_for_box</a>,
                PointerKind::Frozen =&gt; !<a href="#3185">is_return</a>,
            };
            <span class="kw">if </span>no_alias {
                <a href="#3181">attrs</a>.set(ArgAttribute::NoAlias);
            }

            <span class="kw">if </span>kind == PointerKind::Frozen &amp;&amp; !is_return {
                <a href="#3181">attrs</a>.set(ArgAttribute::ReadOnly);
            }

            <span class="kw">if </span>kind == PointerKind::UniqueBorrowed &amp;&amp; !is_return {
                <a href="#3181">attrs</a>.set(ArgAttribute::NoAliasMutRef);
            }
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;tcx</span>&gt; LayoutCx&lt;<span class="lifetime">&#39;tcx</span>, TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
    <span class="comment">// FIXME(eddyb) perhaps group the signature/type-containing (or all of them?)
    // arguments of this method, into a separate `struct`.
    </span><span class="attribute">#[tracing::instrument(
        level = <span class="string">&quot;debug&quot;</span>,
        skip(<span class="self">self</span>, caller_location, fn_def_id, force_thin_self_ptr)
    )]
    </span><span class="kw">fn </span>fn_abi_new_uncached(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        sig: ty::PolyFnSig&lt;<span class="lifetime">&#39;tcx</span>&gt;,
        extra_args: <span class="kw-2">&amp;</span>[Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;],
        caller_location: <span class="prelude-ty">Option</span>&lt;Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
        fn_def_id: <span class="prelude-ty">Option</span>&lt;<a href="../../../rustc_span/def_id/struct.DefId.html">DefId</a>&gt;,
        <span class="comment">// FIXME(eddyb) replace this with something typed, like an `enum`.
        </span>force_thin_self_ptr: <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;tcx </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;, FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <span class="kw">let </span>sig = <span class="self">self</span>.tcx.normalize_erasing_late_bound_regions(<span class="self">self</span>.param_env, sig);

        <span class="kw">let </span>conv = conv_from_spec_abi(<span class="self">self</span>.tcx(), sig.abi);

        <span class="kw">let </span><span class="kw-2">mut </span>inputs = sig.inputs();
        <span class="kw">let </span>extra_args = <span class="kw">if </span>sig.abi == RustCall {
            <span class="macro">assert!</span>(!sig.c_variadic &amp;&amp; extra_args.is_empty());

            <span class="kw">if let </span><span class="prelude-val">Some</span>(input) = sig.inputs().last() {
                <span class="kw">if let </span>ty::Tuple(tupled_arguments) = input.kind() {
                    inputs = <span class="kw-2">&amp;</span>sig.inputs()[<span class="number">0</span>..sig.inputs().len() - <span class="number">1</span>];
                    tupled_arguments
                } <span class="kw">else </span>{
                    <span class="macro">bug!</span>(
                        <span class="string">&quot;argument to function with \&quot;rust-call\&quot; ABI \
                            is not a tuple&quot;
                    </span>);
                }
            } <span class="kw">else </span>{
                <span class="macro">bug!</span>(
                    <span class="string">&quot;argument to function with \&quot;rust-call\&quot; ABI \
                        is not a tuple&quot;
                </span>);
            }
        } <span class="kw">else </span>{
            <span class="macro">assert!</span>(sig.c_variadic || extra_args.is_empty());
            extra_args
        };

        <span class="kw">let </span>target = <span class="kw-2">&amp;</span><span class="self">self</span>.tcx.sess.target;
        <span class="kw">let </span>target_env_gnu_like = <span class="macro">matches!</span>(<span class="kw-2">&amp;</span>target.env[..], <span class="string">&quot;gnu&quot; </span>| <span class="string">&quot;musl&quot; </span>| <span class="string">&quot;uclibc&quot;</span>);
        <span class="kw">let </span>win_x64_gnu = target.os == <span class="string">&quot;windows&quot; </span>&amp;&amp; target.arch == <span class="string">&quot;x86_64&quot; </span>&amp;&amp; target.env == <span class="string">&quot;gnu&quot;</span>;
        <span class="kw">let </span>linux_s390x_gnu_like =
            target.os == <span class="string">&quot;linux&quot; </span>&amp;&amp; target.arch == <span class="string">&quot;s390x&quot; </span>&amp;&amp; target_env_gnu_like;
        <span class="kw">let </span>linux_sparc64_gnu_like =
            target.os == <span class="string">&quot;linux&quot; </span>&amp;&amp; target.arch == <span class="string">&quot;sparc64&quot; </span>&amp;&amp; target_env_gnu_like;
        <span class="kw">let </span>linux_powerpc_gnu_like =
            target.os == <span class="string">&quot;linux&quot; </span>&amp;&amp; target.arch == <span class="string">&quot;powerpc&quot; </span>&amp;&amp; target_env_gnu_like;
        <span class="kw">use </span>SpecAbi::<span class="kw-2">*</span>;
        <span class="kw">let </span>rust_abi = <span class="macro">matches!</span>(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);

        <span class="kw">let </span>arg_of = |ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;, arg_idx: <span class="prelude-ty">Option</span>&lt;usize&gt;| -&gt; <span class="prelude-ty">Result</span>&lt;<span class="kw">_</span>, FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
            <span class="kw">let </span>span = <span class="macro">tracing::debug_span!</span>(<span class="string">&quot;arg_of&quot;</span>);
            <span class="kw">let </span>_entered = span.enter();
            <span class="kw">let </span>is_return = arg_idx.is_none();

            <span class="kw">let </span>layout = <span class="self">self</span>.layout_of(ty)<span class="question-mark">?</span>;
            <span class="kw">let </span>layout = <span class="kw">if </span>force_thin_self_ptr &amp;&amp; arg_idx == <span class="prelude-val">Some</span>(<span class="number">0</span>) {
                <span class="comment">// Don&#39;t pass the vtable, it&#39;s not an argument of the virtual fn.
                // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`
                // or `&amp;/&amp;mut dyn Trait` because this is special-cased elsewhere in codegen
                </span>make_thin_self_ptr(<span class="self">self</span>, layout)
            } <span class="kw">else </span>{
                layout
            };

            <span class="kw">let </span><span class="kw-2">mut </span>arg = ArgAbi::new(<span class="self">self</span>, layout, |layout, scalar, offset| {
                <span class="kw">let </span><span class="kw-2">mut </span>attrs = ArgAttributes::new();
                adjust_for_rust_scalar(<span class="kw-2">*</span><span class="self">self</span>, <span class="kw-2">&amp;mut </span>attrs, scalar, <span class="kw-2">*</span>layout, offset, is_return);
                attrs
            });

            <span class="kw">if </span>arg.layout.is_zst() {
                <span class="comment">// For some forsaken reason, x86_64-pc-windows-gnu
                // doesn&#39;t ignore zero-sized struct arguments.
                // The same is true for {s390x,sparc64,powerpc}-unknown-linux-{gnu,musl,uclibc}.
                </span><span class="kw">if </span>is_return
                    || rust_abi
                    || (!win_x64_gnu
                        &amp;&amp; !linux_s390x_gnu_like
                        &amp;&amp; !linux_sparc64_gnu_like
                        &amp;&amp; !linux_powerpc_gnu_like)
                {
                    arg.mode = PassMode::Ignore;
                }
            }

            <span class="prelude-val">Ok</span>(arg)
        };

        <span class="kw">let </span><span class="kw-2">mut </span>fn_abi = FnAbi {
            ret: arg_of(sig.output(), <span class="prelude-val">None</span>)<span class="question-mark">?</span>,
            args: inputs
                .iter()
                .copied()
                .chain(extra_args.iter().copied())
                .chain(caller_location)
                .enumerate()
                .map(|(i, ty)| arg_of(ty, <span class="prelude-val">Some</span>(i)))
                .collect::&lt;<span class="prelude-ty">Result</span>&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt;&gt;()<span class="question-mark">?</span>,
            c_variadic: sig.c_variadic,
            fixed_count: inputs.len() <span class="kw">as </span>u32,
            conv,
            can_unwind: fn_can_unwind(<span class="self">self</span>.tcx(), fn_def_id, sig.abi),
        };
        <span class="self">self</span>.fn_abi_adjust_for_abi(<span class="kw-2">&amp;mut </span>fn_abi, sig.abi)<span class="question-mark">?</span>;
        <span class="macro">debug!</span>(<span class="string">&quot;fn_abi_new_uncached = {:?}&quot;</span>, fn_abi);
        <span class="prelude-val">Ok</span>(<span class="self">self</span>.tcx.arena.alloc(fn_abi))
    }

    <span class="attribute">#[tracing::instrument(level = <span class="string">&quot;trace&quot;</span>, skip(<span class="self">self</span>))]
    </span><span class="kw">fn </span>fn_abi_adjust_for_abi(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        fn_abi: <span class="kw-2">&amp;mut </span>FnAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;,
        abi: <a href="../../../rustc_target/spec/abi/enum.Abi.html">SpecAbi</a>,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), FnAbiError&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt; {
        <span class="kw">if </span>abi == SpecAbi::Unadjusted {
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="kw">if </span>abi == SpecAbi::Rust
            || abi == SpecAbi::RustCall
            || abi == SpecAbi::RustIntrinsic
            || abi == SpecAbi::PlatformIntrinsic
        {
            <span class="kw">let </span>fixup = |arg: <span class="kw-2">&amp;mut </span>ArgAbi&lt;<span class="lifetime">&#39;tcx</span>, Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;&gt;| {
                <span class="kw">if </span>arg.is_ignore() {
                    <span class="kw">return</span>;
                }

                <span class="kw">match </span>arg.layout.abi {
                    Abi::Aggregate { .. } =&gt; {}

                    <span class="comment">// This is a fun case! The gist of what this is doing is
                    // that we want callers and callees to always agree on the
                    // ABI of how they pass SIMD arguments. If we were to *not*
                    // make these arguments indirect then they&#39;d be immediates
                    // in LLVM, which means that they&#39;d used whatever the
                    // appropriate ABI is for the callee and the caller. That
                    // means, for example, if the caller doesn&#39;t have AVX
                    // enabled but the callee does, then passing an AVX argument
                    // across this boundary would cause corrupt data to show up.
                    //
                    // This problem is fixed by unconditionally passing SIMD
                    // arguments through memory between callers and callees
                    // which should get them all to agree on ABI regardless of
                    // target feature sets. Some more information about this
                    // issue can be found in #44367.
                    //
                    // Note that the platform intrinsic ABI is exempt here as
                    // that&#39;s how we connect up to LLVM and it&#39;s unstable
                    // anyway, we control all calls to it in libstd.
                    </span>Abi::Vector { .. }
                        <span class="kw">if </span>abi != SpecAbi::PlatformIntrinsic
                            &amp;&amp; <span class="self">self</span>.tcx.sess.target.simd_types_indirect =&gt;
                    {
                        arg.make_indirect();
                        <span class="kw">return</span>;
                    }

                    <span class="kw">_ </span>=&gt; <span class="kw">return</span>,
                }

                <span class="kw">let </span>size = arg.layout.size;
                <span class="kw">if </span>arg.layout.is_unsized() || size &gt; Pointer.size(<span class="self">self</span>) {
                    arg.make_indirect();
                } <span class="kw">else </span>{
                    <span class="comment">// We want to pass small aggregates as immediates, but using
                    // a LLVM aggregate type for this leads to bad optimizations,
                    // so we pick an appropriately sized integer type instead.
                    </span>arg.cast_to(Reg { kind: RegKind::Integer, size });
                }
            };
            fixup(<span class="kw-2">&amp;mut </span>fn_abi.ret);
            <span class="kw">for </span>arg <span class="kw">in </span>fn_abi.args.iter_mut() {
                fixup(arg);
            }
        } <span class="kw">else </span>{
            fn_abi.adjust_for_foreign_abi(<span class="self">self</span>, abi)<span class="question-mark">?</span>;
        }

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="attribute">#[tracing::instrument(level = <span class="string">&quot;debug&quot;</span>, skip(cx))]
</span><span class="kw">fn </span>make_thin_self_ptr&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    cx: <span class="kw-2">&amp;</span>(<span class="kw">impl </span>HasTyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt; + HasParamEnv&lt;<span class="lifetime">&#39;tcx</span>&gt;),
    layout: TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt;,
) -&gt; TyAndLayout&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="kw">let </span>tcx = cx.tcx();
    <span class="kw">let </span>fat_pointer_ty = <span class="kw">if </span>layout.is_unsized() {
        <span class="comment">// unsized `self` is passed as a pointer to `self`
        // FIXME (mikeyhew) change this to use &amp;own if it is ever added to the language
        </span>tcx.mk_mut_ptr(layout.ty)
    } <span class="kw">else </span>{
        <span class="kw">match </span>layout.abi {
            Abi::ScalarPair(..) | Abi::Scalar(..) =&gt; (),
            <span class="kw">_ </span>=&gt; <span class="macro">bug!</span>(<span class="string">&quot;receiver type has unsupported layout: {:?}&quot;</span>, layout),
        }

        <span class="comment">// In the case of Rc&lt;Self&gt;, we need to explicitly pass a *mut RcBox&lt;Self&gt;
        // with a Scalar (not ScalarPair) ABI. This is a hack that is understood
        // elsewhere in the compiler as a method on a `dyn Trait`.
        // To get the type `*mut RcBox&lt;Self&gt;`, we just keep unwrapping newtypes until we
        // get a built-in pointer type
        </span><span class="kw">let </span><span class="kw-2">mut </span>fat_pointer_layout = layout;
        <span class="lifetime">&#39;descend_newtypes</span>: <span class="kw">while </span>!fat_pointer_layout.ty.is_unsafe_ptr()
            &amp;&amp; !fat_pointer_layout.ty.is_region_ptr()
        {
            <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..fat_pointer_layout.fields.count() {
                <span class="kw">let </span>field_layout = fat_pointer_layout.field(cx, i);

                <span class="kw">if </span>!field_layout.is_zst() {
                    fat_pointer_layout = field_layout;
                    <span class="kw">continue </span><span class="lifetime">&#39;descend_newtypes</span>;
                }
            }

            <span class="macro">bug!</span>(<span class="string">&quot;receiver has no non-zero-sized fields {:?}&quot;</span>, fat_pointer_layout);
        }

        fat_pointer_layout.ty
    };

    <span class="comment">// we now have a type like `*mut RcBox&lt;dyn Trait&gt;`
    // change its layout to that of `*mut ()`, a thin pointer, but keep the same type
    // this is understood as a special case elsewhere in the compiler
    </span><span class="kw">let </span>unit_ptr_ty = tcx.mk_mut_ptr(tcx.mk_unit());

    TyAndLayout {
        ty: fat_pointer_ty,

        <span class="comment">// NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing the `Result`
        // should always work because the type is always `*mut ()`.
        </span>..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rustc_middle" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0-dev" ></div></body></html>