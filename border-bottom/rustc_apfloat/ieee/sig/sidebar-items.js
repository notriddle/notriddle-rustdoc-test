window.SIDEBAR_ITEMS = {"fn":[["add","`a += b + c` where `c` is zero or one. Returns the carry flag."],["add_or_sub","`a += b` or `a -= b`. Does not preserve `b`."],["clear_bit","Clear the given bit."],["cmp","Comparison (unsigned) of two significands."],["decrement","Decrement in-place, return the borrow flag."],["div","`quotient = dividend / divisor`. Returns the lost fraction. Does not preserve `dividend` or `divisor`."],["each_chunk","For every consecutive chunk of `bits` bits from `limbs`, going from most significant to the least significant bits, call `f` to transform those bits and store the result back."],["extract","Copies the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB, to `dst`, such that the bit SRC_LSB becomes the least significant bit of `dst`. All high bits above `src_bits` in `dst` are zero-filled."],["from_limbs","We want the most significant PRECISION bits of `src`. There may not be that many; extract what we can."],["get_bit","Extracts the given bit."],["increment","Increment in-place, return the carry flag."],["is_all_zeros",""],["mul","`dst = a * b` (for normal `a` and `b`). Returns the lost fraction."],["olsb","One, not zero, based LSB. That is, returns 0 for a zeroed significand."],["omsb","One, not zero, based MSB. That is, returns 0 for a zeroed significand."],["set_bit","Sets the given bit."],["shift_left","Shifts `dst` left `bits` bits, subtract `bits` from its exponent."],["shift_right","Shifts `dst` right `bits` bits noting lost fraction."],["sub","`a -= b + c` where `c` is zero or one. Returns the borrow flag."],["widening_mul","`[low, high] = a * b`."]]};