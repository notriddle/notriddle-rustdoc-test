window.SIDEBAR_ITEMS = {"enum":[["ConstantKind",""],["DocFragmentKind",""],["ExternalLocation","Indicates where an external crate can be found."],["FnRetTy",""],["GenericArg",""],["GenericArgs",""],["GenericBound",""],["GenericParamDefKind",""],["ImplKind",""],["ImportKind",""],["ItemId",""],["ItemKind",""],["PrimitiveType","A primitive (aka, builtin) type."],["SelfTy",""],["SubstParam","The type, lifetime, or constant that a private type alias’s parameter should be replaced with when expanding a use of that type alias."],["Term",""],["Type","Rustdoc’s representation of types, mostly based on the [`hir::Ty`]."],["TypeBindingKind",""],["Variant",""],["Visibility",""],["WherePredicate",""]],"fn":[["add_doc_fragment","The goal of this function is to apply the `DocFragment` transformation that is required when transforming into the final Markdown, which is applying the computed indent to each line in each doc fragment (a `DocFragment` can contain multiple lines in case of `#[doc = \"\"]`)."],["collapse_doc_fragments","Collapse a collection of [`DocFragment`]s into one string, handling indentation and newlines as needed."],["rustc_span",""],["unindent_doc_fragments","Removes excess indentation on comments in order for the Markdown to be parsed correctly. This is necessary because the convention for writing documentation is to provide a space between the /// or //! marker and the doc text, but Markdown is whitespace-sensitive. For example, a block of text with four-space indentation is parsed as a code block, so if we didn’t unindent comments, these list items"]],"mod":[["size_asserts",""]],"struct":[["Argument",""],["Arguments",""],["Attributes","The attributes on an [`Item`], including attributes like `#[derive(...)]` and `#[inline]`, as well as doc comments."],["BareFunctionDecl",""],["Constant",""],["Crate","The crate currently being documented."],["Discriminant",""],["DocFragment","A portion of documentation, extracted from a `#[doc]` attribute."],["Enum",""],["ExternalCrate",""],["FnDecl",""],["Function",""],["GenericParamDef",""],["Generics",""],["Impl",""],["Import",""],["ImportSource",""],["Item","Anything with a source location and set of attributes and, optionally, a name. That is, anything that can be documented. This doesn’t correspond directly to the AST’s concept of an item; it’s a strict superset."],["ItemLink","A link that has not yet been rendered."],["Lifetime",""],["Macro",""],["Module",""],["OpaqueTy",""],["Path",""],["PathSegment",""],["PolyTrait","A trait reference, which may have higher ranked lifetimes."],["ProcMacro",""],["QPathData",""],["RenderedLink",""],["Span","Small wrapper around [`rustc_span::Span`] that adds helper methods and enforces calling [`rustc_span::Span::source_callsite()`]."],["Static",""],["Struct",""],["Trait",""],["TraitAlias",""],["TraitWithExtraInfo","This struct is used to wrap additional information added by rustdoc on a `trait` item."],["TypeBinding","An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or `A: Send + Sync` in `Foo<A: Send + Sync>`)."],["Typedef",""],["Union",""],["VariantStruct","This is a more limited form of the standard Struct, different in that it lacks the things most items have (name, id, parameterization). Found only as a variant in an enum."]],"trait":[["AttributesExt",""],["NestedAttributesExt",""]],"type":[["ItemIdSet",""],["SimplifiedTypes",""]]};