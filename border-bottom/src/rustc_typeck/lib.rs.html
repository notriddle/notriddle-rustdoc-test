<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `compiler/rustc_typeck/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../rustc_typeck/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../rustc_typeck/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../rustc_typeck/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
</pre><pre class="rust"><code><span class="doccomment">/*!

# typeck

The type checker is responsible for:

1. Determining the type of each expression.
2. Resolving methods and traits.
3. Guaranteeing that most type rules are met. (&quot;Most?&quot;, you say, &quot;why most?&quot;
   Well, dear reader, read on.)

The main entry point is [`check_crate()`]. Type checking operates in
several major phases:

1. The collect phase first passes over all items and determines their
   type, without examining their &quot;innards&quot;.

2. Variance inference then runs to compute the variance of each parameter.

3. Coherence checks for overlapping or orphaned impls.

4. Finally, the check phase then checks function bodies and so forth.
   Within the check phase, we check each function body one at a time
   (bodies of function expressions are checked as part of the
   containing function).  Inference is used to supply types wherever
   they are unknown. The actual checking of a function itself has
   several phases (check, regionck, writeback), as discussed in the
   documentation for the [`check`] module.

The type checker is defined into various submodules which are documented
independently:

- astconv: converts the AST representation of types
  into the `ty` representation.

- collect: computes the types of each top-level item and enters them into
  the `tcx.types` table for later use.

- coherence: enforces coherence rules, builds some tables.

- variance: variance inference

- outlives: outlives inference

- check: walks over function bodies and type checks them, inferring types for
  local variables, type parameters, etc as necessary.

- infer: finds the types to use for each type variable such that
  all subtyping and assignment constraints are met.  In essence, the check
  module specifies the constraints, and the infer module solves them.

## Note

This API is completely unstable and subject to change.

*/

</span><span class="attribute">#![allow(rustc::potential_query_instability)]
#![doc(html_root_url = <span class="string">&quot;https://doc.rust-lang.org/nightly/nightly-rustc/&quot;</span>)]
#![feature(box_patterns)]
#![feature(control_flow_enum)]
#![feature(drain_filter)]
#![feature(hash_drain_filter)]
#![feature(if_let_guard)]
#![feature(is_sorted)]
#![feature(iter_intersperse)]
#![cfg_attr(bootstrap, feature(label_break_value))]
#![feature(let_chains)]
#![cfg_attr(bootstrap, feature(let_else))]
#![feature(min_specialization)]
#![feature(never_type)]
#![feature(once_cell)]
#![feature(slice_partition_dedup)]
#![feature(try_blocks)]
#![feature(is_some_with)]
#![feature(type_alias_impl_trait)]
#![recursion_limit = <span class="string">&quot;256&quot;</span>]

#[macro_use]
</span><span class="kw">extern crate </span>tracing;

<span class="attribute">#[macro_use]
</span><span class="kw">extern crate </span>rustc_middle;

<span class="comment">// These are used by Clippy.
</span><span class="kw">pub mod </span><a href="check/mod.rs.html#1-967">check</a>;
<span class="kw">pub mod </span><a href="expr_use_visitor.rs.html#1-915">expr_use_visitor</a>;

<span class="kw">mod </span><a href="astconv/mod.rs.html#1-3104">astconv</a>;
<span class="kw">mod </span><a href="bounds.rs.html#1-90">bounds</a>;
<span class="kw">mod </span><a href="check_unused.rs.html#1-187">check_unused</a>;
<span class="kw">mod </span><a href="coherence/mod.rs.html#8-237">coherence</a>;
<span class="kw">mod </span><a href="collect.rs.html#1-3401">collect</a>;
<span class="kw">mod </span><a href="constrained_generic_params.rs.html#1-221">constrained_generic_params</a>;
<span class="kw">mod </span><a href="errors.rs.html#1-347">errors</a>;
<span class="kw">pub mod </span><a href="hir_wf_check.rs.html#1-188">hir_wf_check</a>;
<span class="kw">mod </span><a href="impl_wf_check.rs.html#1-228">impl_wf_check</a>;
<span class="kw">mod </span><a href="mem_categorization.rs.html#1-786">mem_categorization</a>;
<span class="kw">mod </span><a href="outlives/mod.rs.html#1-129">outlives</a>;
<span class="kw">mod </span><a href="structured_errors.rs.html#1-42">structured_errors</a>;
<span class="kw">mod </span><a href="variance/mod.rs.html#1-63">variance</a>;

<span class="kw">use </span>rustc_errors::{<a href="../../rustc_errors/macro.struct_span_err.html">struct_span_err</a>, <a href="../../rustc_errors/struct.ErrorGuaranteed.html">ErrorGuaranteed</a>};
<span class="kw">use </span><a href="../../rustc_hir/index.html">rustc_hir</a> <span class="kw">as </span>hir;
<span class="kw">use </span><a href="../../rustc_span/def_id/struct.DefId.html">rustc_hir::def_id::DefId</a>;
<span class="kw">use </span>rustc_hir::{<a href="../../rustc_hir/hir/enum.Node.html">Node</a>, <a href="../../rustc_hir/hir_id/constant.CRATE_HIR_ID.html">CRATE_HIR_ID</a>};
<span class="kw">use </span>rustc_infer::infer::{<a href="../../rustc_infer/infer/struct.InferOk.html">InferOk</a>, <a href="../../rustc_infer/infer/trait.TyCtxtInferExt.html">TyCtxtInferExt</a>};
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/middle/index.html">rustc_middle::middle</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/struct.Providers.html">rustc_middle::ty::query::Providers</a>;
<span class="kw">use </span>rustc_middle::ty::{<a class="self" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html">self</a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html">Ty</a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html">TyCtxt</a>};
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/util/index.html">rustc_middle::util</a>;
<span class="kw">use </span><a href="../../rustc_session/config/enum.EntryFnType.html">rustc_session::config::EntryFnType</a>;
<span class="kw">use </span>rustc_span::{<a href="../../rustc_span/symbol/sym/index.html">symbol::sym</a>, <a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>, <a href="../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>};
<span class="kw">use </span><a href="../../rustc_target/spec/abi/enum.Abi.html">rustc_target::spec::abi::Abi</a>;
<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/error_reporting/trait.InferCtxtExt.html">rustc_trait_selection::traits::error_reporting::InferCtxtExt</a> <span class="kw">as _</span>;
<span class="kw">use </span>rustc_trait_selection::traits::{<a class="self" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/index.html">self</a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/traits/struct.ObligationCause.html">ObligationCause</a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/traits/enum.ObligationCauseCode.html">ObligationCauseCode</a>};

<span class="kw">use </span><a href="https://doc.rust-lang.org/nightly/core/iter/index.html">std::iter</a>;

<span class="kw">use </span><a href="astconv/mod.rs.html#55">astconv::AstConv</a>;
<span class="kw">use </span><a href="bounds.rs.html#24">bounds::Bounds</a>;

<span class="kw">fn </span>require_c_abi_if_c_variadic(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, decl: <span class="kw-2">&amp;</span>hir::FnDecl&lt;<span class="lifetime">&#39;_</span>&gt;, abi: <a href="../../rustc_target/spec/abi/enum.Abi.html">Abi</a>, span: <a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>) {
    <span class="kw">match </span>(<a href="#123">decl</a>.c_variadic, <a href="#123">abi</a>) {
        <span class="comment">// The function has the correct calling convention, or isn&#39;t a &quot;C-variadic&quot; function.
        </span>(<span class="bool-val">false</span>, <span class="kw">_</span>) | (<span class="bool-val">true</span>, <a href="../../rustc_target/spec/abi/enum.Abi.html">Abi::C</a> { .. }) | (<span class="bool-val">true</span>, <a href="../../rustc_target/spec/abi/enum.Abi.html">Abi::Cdecl</a> { .. }) =&gt; {}
        <span class="comment">// The function is a &quot;C-variadic&quot; function with an incorrect calling convention.
        </span>(<span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>err = <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
                tcx.sess,
                span,
                E0045,
                <span class="string">&quot;C-variadic function must have C or cdecl calling convention&quot;
            </span>);
            <a href="#129">err</a>.span_label(<a href="#123">span</a>, <span class="string">&quot;C-variadics require C or cdecl calling convention&quot;</span>).emit();
        }
    }
}

<span class="kw">fn </span>require_same_types&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    cause: <span class="kw-2">&amp;</span>ObligationCause&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    expected: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    actual: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
) -&gt; <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> {
    <a href="#141">tcx</a>.<a href="../../rustc_infer/infer/trait.TyCtxtInferExt.html">infer_ctxt</a>().enter(|<span class="kw-2">ref </span>infcx| {
        <span class="kw">let </span>param_env = ty::ParamEnv::empty();
        <span class="kw">let </span>errors = <span class="kw">match </span><a href="#146">infcx</a>.at(<a href="#142">cause</a>, <a href="#147">param_env</a>).eq(<a href="#143">expected</a>, <a href="#144">actual</a>) {
            <span class="prelude-val">Ok</span>(<a href="../../rustc_infer/infer/struct.InferOk.html">InferOk</a> { obligations, .. }) =&gt; traits::fully_solve_obligations(<a href="#146">infcx</a>, <a href="#149">obligations</a>),
            <span class="prelude-val">Err</span>(err) =&gt; {
                <a href="#146">infcx</a>.report_mismatched_types(<a href="#142">cause</a>, <a href="#143">expected</a>, <a href="#144">actual</a>, <a href="#150">err</a>).emit();
                <span class="kw">return </span><span class="bool-val">false</span>;
            }
        };

        <span class="kw">match </span><span class="kw-2">&amp;</span><a href="#148">errors</a>[..] {
            [] =&gt; <span class="bool-val">true</span>,
            errors =&gt; {
                <a href="#146">infcx</a>.<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/error_reporting/trait.InferCtxtExt.html">report_fulfillment_errors</a>(<a href="#158">errors</a>, <span class="prelude-val">None</span>, <span class="bool-val">false</span>);
                <span class="bool-val">false
            </span>}
        }
    })
}

<span class="kw">fn </span>check_main_fn_ty(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, main_def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) {
    <span class="kw">let </span>main_fnsig = <a href="#166">tcx</a>.fn_sig(<a href="#166">main_def_id</a>);
    <span class="kw">let </span>main_span = <a href="#166">tcx</a>.def_span(<a href="#166">main_def_id</a>);

    <span class="kw">fn </span>main_fn_diagnostics_hir_id(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>, sp: <a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>) -&gt; <a href="../../rustc_hir/hir_id/struct.HirId.html">hir::HirId</a> {
        <span class="kw">if let </span><span class="prelude-val">Some</span>(local_def_id) = <a href="#170">def_id</a>.as_local() {
            <span class="kw">let </span>hir_id = <a href="#170">tcx</a>.hir().local_def_id_to_hir_id(<a href="#171">local_def_id</a>);
            <span class="kw">let </span>hir_type = <a href="#170">tcx</a>.type_of(<a href="#171">local_def_id</a>);
            <span class="kw">if </span>!<span class="macro">matches!</span>(hir_type.kind(), ty::FnDef(..)) {
                <a class="macro" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.span_bug.html">span_bug!</a>(sp, <span class="string">&quot;main has a non-function type: found `{}`&quot;</span>, hir_type);
            }
            <a href="#172">hir_id</a>
        } <span class="kw">else </span>{
            <a href="../../rustc_hir/hir_id/constant.CRATE_HIR_ID.html">CRATE_HIR_ID</a>
        }
    }

    <span class="kw">fn </span>main_fn_generics_params_span(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>&gt; {
        <span class="kw">if </span>!def_id.is_local() {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span>hir_id = <a href="#183">tcx</a>.hir().local_def_id_to_hir_id(<a href="#183">def_id</a>.expect_local());
        <span class="kw">match </span><a href="#183">tcx</a>.hir().find(<a href="#187">hir_id</a>) {
            <span class="prelude-val">Some</span>(Node::Item(<a href="../../rustc_hir/hir/struct.Item.html">hir::Item</a> { kind: hir::ItemKind::Fn(<span class="kw">_</span>, <span class="kw-2">ref </span>generics, <span class="kw">_</span>), .. })) =&gt; {
                <span class="kw">if </span>!generics.params.is_empty() {
                    <span class="prelude-val">Some</span>(<a href="#189">generics</a>.span)
                } <span class="kw">else </span>{
                    <span class="prelude-val">None
                </span>}
            }
            <span class="kw">_ </span>=&gt; {
                <a class="macro" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.span_bug.html">span_bug!</a>(tcx.def_span(def_id), <span class="string">&quot;main has a non-function type&quot;</span>);
            }
        }
    }

    <span class="kw">fn </span>main_fn_where_clauses_span(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>&gt; {
        <span class="kw">if </span>!def_id.is_local() {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span>hir_id = <a href="#202">tcx</a>.hir().local_def_id_to_hir_id(<a href="#202">def_id</a>.expect_local());
        <span class="kw">match </span><a href="#202">tcx</a>.hir().find(<a href="#206">hir_id</a>) {
            <span class="prelude-val">Some</span>(Node::Item(<a href="../../rustc_hir/hir/struct.Item.html">hir::Item</a> { kind: hir::ItemKind::Fn(<span class="kw">_</span>, <span class="kw-2">ref </span>generics, <span class="kw">_</span>), .. })) =&gt; {
                <span class="prelude-val">Some</span>(<a href="#208">generics</a>.where_clause_span)
            }
            <span class="kw">_ </span>=&gt; {
                <a class="macro" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.span_bug.html">span_bug!</a>(tcx.def_span(def_id), <span class="string">&quot;main has a non-function type&quot;</span>);
            }
        }
    }

    <span class="kw">fn </span>main_fn_asyncness_span(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>&gt; {
        <span class="kw">if </span>!def_id.is_local() {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="prelude-val">Some</span>(<a href="#217">tcx</a>.def_span(<a href="#217">def_id</a>))
    }

    <span class="kw">fn </span>main_fn_return_type_span(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) -&gt; <span class="prelude-ty">Option</span>&lt;<a href="../../rustc_span/span_encoding/struct.Span.html">Span</a>&gt; {
        <span class="kw">if </span>!def_id.is_local() {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span>hir_id = <a href="#224">tcx</a>.hir().local_def_id_to_hir_id(<a href="#224">def_id</a>.expect_local());
        <span class="kw">match </span><a href="#224">tcx</a>.hir().find(<a href="#228">hir_id</a>) {
            <span class="prelude-val">Some</span>(Node::Item(<a href="../../rustc_hir/hir/struct.Item.html">hir::Item</a> { kind: hir::ItemKind::Fn(<span class="kw-2">ref </span>fn_sig, <span class="kw">_</span>, <span class="kw">_</span>), .. })) =&gt; {
                <span class="prelude-val">Some</span>(<a href="#230">fn_sig</a>.decl.output.span())
            }
            <span class="kw">_ </span>=&gt; {
                <a class="macro" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.span_bug.html">span_bug!</a>(tcx.def_span(def_id), <span class="string">&quot;main has a non-function type&quot;</span>);
            }
        }
    }

    <span class="kw">let </span><span class="kw-2">mut </span>error = <span class="bool-val">false</span>;
    <span class="kw">let </span>main_diagnostics_hir_id = <a href="#170">main_fn_diagnostics_hir_id</a>(<a href="#166">tcx</a>, <a href="#166">main_def_id</a>, <a href="#168">main_span</a>);
    <span class="kw">let </span>main_fn_generics = <a href="#166">tcx</a>.generics_of(<a href="#166">main_def_id</a>);
    <span class="kw">let </span>main_fn_predicates = <a href="#166">tcx</a>.predicates_of(<a href="#166">main_def_id</a>);
    <span class="kw">if </span>main_fn_generics.count() != <span class="number">0 </span>|| !main_fnsig.bound_vars().is_empty() {
        <span class="kw">let </span>generics_param_span = <a href="#183">main_fn_generics_params_span</a>(<a href="#166">tcx</a>, <a href="#166">main_def_id</a>);
        <span class="kw">let </span>msg = <span class="string">&quot;`main` function is not allowed to have generic \
            parameters&quot;</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>diag =
            <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(tcx.sess, generics_param_span.unwrap_or(main_span), E0131, <span class="string">&quot;{}&quot;</span>, msg);
        <span class="kw">if let </span><span class="prelude-val">Some</span>(generics_param_span) = <a href="#244">generics_param_span</a> {
            <span class="kw">let </span>label = <span class="string">&quot;`main` cannot have generic parameters&quot;</span>;
            <a href="#247">diag</a>.span_label(<a href="#249">generics_param_span</a>, <a href="#250">label</a>);
        }
        <a href="#247">diag</a>.emit();
        <a href="#239">error</a> = <span class="bool-val">true</span>;
    } <span class="kw">else if </span>!main_fn_predicates.predicates.is_empty() {
        <span class="comment">// generics may bring in implicit predicates, so we skip this check if generics is present.
        </span><span class="kw">let </span>generics_where_clauses_span = <a href="#202">main_fn_where_clauses_span</a>(<a href="#166">tcx</a>, <a href="#166">main_def_id</a>);
        <span class="kw">let </span><span class="kw-2">mut </span>diag = <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
            tcx.sess,
            generics_where_clauses_span.unwrap_or(main_span),
            E0646,
            <span class="string">&quot;`main` function is not allowed to have a `where` clause&quot;
        </span>);
        <span class="kw">if let </span><span class="prelude-val">Some</span>(generics_where_clauses_span) = <a href="#257">generics_where_clauses_span</a> {
            <a href="#258">diag</a>.span_label(<a href="#264">generics_where_clauses_span</a>, <span class="string">&quot;`main` cannot have a `where` clause&quot;</span>);
        }
        <a href="#258">diag</a>.emit();
        <a href="#239">error</a> = <span class="bool-val">true</span>;
    }

    <span class="kw">let </span>main_asyncness = <a href="#166">tcx</a>.asyncness(<a href="#166">main_def_id</a>);
    <span class="kw">if let </span>hir::IsAsync::Async = <a href="#271">main_asyncness</a> {
        <span class="kw">let </span><span class="kw-2">mut </span>diag = <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
            tcx.sess,
            main_span,
            E0752,
            <span class="string">&quot;`main` function is not allowed to be `async`&quot;
        </span>);
        <span class="kw">let </span>asyncness_span = <a href="#217">main_fn_asyncness_span</a>(<a href="#166">tcx</a>, <a href="#166">main_def_id</a>);
        <span class="kw">if let </span><span class="prelude-val">Some</span>(asyncness_span) = <a href="#279">asyncness_span</a> {
            <a href="#273">diag</a>.span_label(<a href="#280">asyncness_span</a>, <span class="string">&quot;`main` function is not allowed to be `async`&quot;</span>);
        }
        <a href="#273">diag</a>.emit();
        <a href="#239">error</a> = <span class="bool-val">true</span>;
    }

    <span class="kw">for </span>attr <span class="kw">in </span>tcx.get_attrs(main_def_id, sym::track_caller) {
        tcx.sess
            .struct_span_err(attr.span, <span class="string">&quot;`main` function is not allowed to be `#[track_caller]`&quot;</span>)
            .span_label(main_span, <span class="string">&quot;`main` function is not allowed to be `#[track_caller]`&quot;</span>)
            .emit();
        error = <span class="bool-val">true</span>;
    }

    <span class="kw">if </span>error {
        <span class="kw">return</span>;
    }

    <span class="kw">let </span>expected_return_type;
    <span class="kw">if let </span><span class="prelude-val">Some</span>(term_did) = <a href="#166">tcx</a>.lang_items().termination() {
        <span class="kw">let </span>return_ty = <a href="#167">main_fnsig</a>.output();
        <span class="kw">let </span>return_ty_span = <a href="#224">main_fn_return_type_span</a>(<a href="#166">tcx</a>, <a href="#166">main_def_id</a>).unwrap_or(<a href="#168">main_span</a>);
        <span class="kw">if </span>!return_ty.bound_vars().is_empty() {
            <span class="kw">let </span>msg = <span class="string">&quot;`main` function return type is not allowed to have generic \
                    parameters&quot;</span>;
            <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(tcx.sess, return_ty_span, E0131, <span class="string">&quot;{}&quot;</span>, msg).emit();
            <a href="#239">error</a> = <span class="bool-val">true</span>;
        }
        <span class="kw">let </span>return_ty = <a href="#301">return_ty</a>.skip_binder();
        <a href="#166">tcx</a>.<a href="../../rustc_infer/infer/trait.TyCtxtInferExt.html">infer_ctxt</a>().enter(|infcx| {
            <span class="comment">// Main should have no WC, so empty param env is OK here.
            </span><span class="kw">let </span>param_env = ty::ParamEnv::empty();
            <span class="kw">let </span>cause = traits::ObligationCause::new(
                <a href="#302">return_ty_span</a>,
                <a href="#240">main_diagnostics_hir_id</a>,
                ObligationCauseCode::MainFunctionType,
            );
            <span class="kw">let </span>ocx = traits::ObligationCtxt::new(<span class="kw-2">&amp;</span><a href="#310">infcx</a>);
            <span class="kw">let </span>norm_return_ty = <a href="#318">ocx</a>.normalize(<a href="#313">cause</a>.<a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">clone</a>(), <a href="#312">param_env</a>, <a href="#309">return_ty</a>);
            <a href="#318">ocx</a>.register_bound(<a href="#313">cause</a>, <a href="#312">param_env</a>, <a href="#319">norm_return_ty</a>, <a href="#300">term_did</a>);
            <span class="kw">let </span>errors = <a href="#318">ocx</a>.select_all_or_error();
            <span class="kw">if </span>!errors.is_empty() {
                <a href="#310">infcx</a>.<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/error_reporting/trait.InferCtxtExt.html">report_fulfillment_errors</a>(<span class="kw-2">&amp;</span><a href="#321">errors</a>, <span class="prelude-val">None</span>, <span class="bool-val">false</span>);
                <a href="#239">error</a> = <span class="bool-val">true</span>;
            }
        });
        <span class="comment">// now we can take the return type of the given main function
        </span><a href="#299">expected_return_type</a> = <a href="#167">main_fnsig</a>.output();
    } <span class="kw">else </span>{
        <span class="comment">// standard () main return type
        </span><a href="#299">expected_return_type</a> = ty::Binder::dummy(<a href="#166">tcx</a>.mk_unit());
    }

    <span class="kw">if </span>error {
        <span class="kw">return</span>;
    }

    <span class="kw">let </span>se_ty = <a href="#166">tcx</a>.mk_fn_ptr(<a href="#299">expected_return_type</a>.map_bound(|expected_return_type| {
        <a href="#166">tcx</a>.mk_fn_sig(iter::empty(), <a href="#338">expected_return_type</a>, <span class="bool-val">false</span>, hir::Unsafety::Normal, Abi::Rust)
    }));

    <a href="#140-145">require_same_types</a>(
        <a href="#166">tcx</a>,
        <span class="kw-2">&amp;</span>ObligationCause::new(
            <a href="#168">main_span</a>,
            <a href="#240">main_diagnostics_hir_id</a>,
            ObligationCauseCode::MainFunctionType,
        ),
        <a href="#338">se_ty</a>,
        <a href="#166">tcx</a>.mk_fn_ptr(<a href="#167">main_fnsig</a>),
    );
}
<span class="kw">fn </span>check_start_fn_ty(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;, start_def_id: <a href="../../rustc_span/def_id/struct.DefId.html">DefId</a>) {
    <span class="kw">let </span>start_def_id = <a href="#353">start_def_id</a>.expect_local();
    <span class="kw">let </span>start_id = <a href="#353">tcx</a>.hir().local_def_id_to_hir_id(<a href="#354">start_def_id</a>);
    <span class="kw">let </span>start_span = <a href="#353">tcx</a>.def_span(<a href="#354">start_def_id</a>);
    <span class="kw">let </span>start_t = <a href="#353">tcx</a>.type_of(<a href="#354">start_def_id</a>);
    <span class="kw">match </span><a href="#357">start_t</a>.kind() {
        ty::FnDef(..) =&gt; {
            <span class="kw">if let </span><span class="prelude-val">Some</span>(Node::Item(it)) = <a href="#353">tcx</a>.hir().find(<a href="#355">start_id</a>) {
                <span class="kw">if let </span>hir::ItemKind::Fn(<span class="kw-2">ref </span>sig, <span class="kw-2">ref </span>generics, <span class="kw">_</span>) = <a href="#360">it</a>.kind {
                    <span class="kw">let </span><span class="kw-2">mut </span>error = <span class="bool-val">false</span>;
                    <span class="kw">if </span>!generics.params.is_empty() {
                        <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
                            tcx.sess,
                            generics.span,
                            E0132,
                            <span class="string">&quot;start function is not allowed to have type parameters&quot;
                        </span>)
                        .span_label(<a href="#361">generics</a>.span, <span class="string">&quot;start function cannot have type parameters&quot;</span>)
                        .emit();
                        <a href="#362">error</a> = <span class="bool-val">true</span>;
                    }
                    <span class="kw">if </span>generics.has_where_clause_predicates {
                        <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
                            tcx.sess,
                            generics.where_clause_span,
                            E0647,
                            <span class="string">&quot;start function is not allowed to have a `where` clause&quot;
                        </span>)
                        .span_label(
                            <a href="#361">generics</a>.where_clause_span,
                            <span class="string">&quot;start function cannot have a `where` clause&quot;</span>,
                        )
                        .emit();
                        <a href="#362">error</a> = <span class="bool-val">true</span>;
                    }
                    <span class="kw">if let </span>hir::IsAsync::Async = <a href="#361">sig</a>.header.asyncness {
                        <span class="kw">let </span>span = <a href="#353">tcx</a>.def_span(<a href="#360">it</a>.def_id);
                        <a class="macro" href="../../rustc_errors/macro.struct_span_err.html">struct_span_err!</a>(
                            tcx.sess,
                            span,
                            E0752,
                            <span class="string">&quot;`start` is not allowed to be `async`&quot;
                        </span>)
                        .span_label(<a href="#389">span</a>, <span class="string">&quot;`start` is not allowed to be `async`&quot;</span>)
                        .emit();
                        <a href="#362">error</a> = <span class="bool-val">true</span>;
                    }

                    <span class="kw">let </span>attrs = <a href="#353">tcx</a>.hir().attrs(<a href="#355">start_id</a>);
                    <span class="kw">for </span>attr <span class="kw">in </span>attrs {
                        <span class="kw">if </span>attr.has_name(sym::track_caller) {
                            tcx.sess
                                .struct_span_err(
                                    attr.span,
                                    <span class="string">&quot;`start` is not allowed to be `#[track_caller]`&quot;</span>,
                                )
                                .span_label(
                                    start_span,
                                    <span class="string">&quot;`start` is not allowed to be `#[track_caller]`&quot;</span>,
                                )
                                .emit();
                            error = <span class="bool-val">true</span>;
                        }
                    }

                    <span class="kw">if </span>error {
                        <span class="kw">return</span>;
                    }
                }
            }

            <span class="kw">let </span>se_ty = <a href="#353">tcx</a>.mk_fn_ptr(ty::Binder::dummy(<a href="#353">tcx</a>.mk_fn_sig(
                [<a href="#353">tcx</a>.types.isize, <a href="#353">tcx</a>.mk_imm_ptr(<a href="#353">tcx</a>.mk_imm_ptr(<a href="#353">tcx</a>.types.u8))].iter().<a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html">cloned</a>(),
                <a href="#353">tcx</a>.types.isize,
                <span class="bool-val">false</span>,
                hir::Unsafety::Normal,
                Abi::Rust,
            )));

            <a href="#140-145">require_same_types</a>(
                <a href="#353">tcx</a>,
                <span class="kw-2">&amp;</span>ObligationCause::new(<a href="#356">start_span</a>, <a href="#355">start_id</a>, ObligationCauseCode::StartFunctionType),
                <a href="#424">se_ty</a>,
                <a href="#353">tcx</a>.mk_fn_ptr(<a href="#353">tcx</a>.fn_sig(<a href="#354">start_def_id</a>)),
            );
        }
        <span class="kw">_ </span>=&gt; {
            <a class="macro" href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.span_bug.html">span_bug!</a>(start_span, <span class="string">&quot;start has a non-function type: found `{}`&quot;</span>, start_t);
        }
    }
}

<span class="kw">fn </span>check_for_entry_fn(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;) {
    <span class="kw">match </span><a href="#445">tcx</a>.entry_fn(()) {
        <span class="prelude-val">Some</span>((def_id, <a href="../../rustc_session/config/enum.EntryFnType.html">EntryFnType::Main</a> { .. })) =&gt; <a href="#166">check_main_fn_ty</a>(<a href="#445">tcx</a>, <a href="#447">def_id</a>),
        <span class="prelude-val">Some</span>((def_id, EntryFnType::Start)) =&gt; <a href="#353">check_start_fn_ty</a>(<a href="#445">tcx</a>, <a href="#448">def_id</a>),
        <span class="kw">_ </span>=&gt; {}
    }
}

<span class="kw">pub fn </span>provide(providers: <span class="kw-2">&amp;mut </span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/struct.Providers.html">Providers</a>) {
    <a href="collect.rs.html#65">collect::provide</a>(<a href="#453">providers</a>);
    <a href="coherence/mod.rs.html#140">coherence::provide</a>(<a href="#453">providers</a>);
    <a href="check/mod.rs.html#240">check::provide</a>(<a href="#453">providers</a>);
    <a href="variance/mod.rs.html#28">variance::provide</a>(<a href="#453">providers</a>);
    <a href="outlives/mod.rs.html#16">outlives::provide</a>(<a href="#453">providers</a>);
    <a href="impl_wf_check.rs.html#70">impl_wf_check::provide</a>(<a href="#453">providers</a>);
    <a href="hir_wf_check.rs.html#11">hir_wf_check::provide</a>(<a href="#453">providers</a>);
}

<span class="kw">pub fn </span>check_crate(tcx: TyCtxt&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(), <a href="../../rustc_errors/struct.ErrorGuaranteed.html">ErrorGuaranteed</a>&gt; {
    <span class="kw">let </span>_prof_timer = <a href="#463">tcx</a>.sess.timer(<span class="string">&quot;type_check_crate&quot;</span>);

    <span class="comment">// this ensures that later parts of type checking can assume that items
    // have valid types and not error
    // FIXME(matthewjasper) We shouldn&#39;t need to use `track_errors`.
    </span>tcx.sess.track_errors(|| {
        tcx.sess.time(<span class="string">&quot;type_collecting&quot;</span>, || {
            tcx.hir().for_each_module(|module| tcx.ensure().collect_mod_item_types(module))
        });
    })<span class="question-mark">?</span>;

    <span class="kw">if </span>tcx.features().rustc_attrs {
        tcx.sess.track_errors(|| {
            tcx.sess.time(<span class="string">&quot;outlives_testing&quot;</span>, || outlives::test::test_inferred_outlives(tcx));
        })<span class="question-mark">?</span>;
    }

    tcx.sess.track_errors(|| {
        tcx.sess.time(<span class="string">&quot;impl_wf_inference&quot;</span>, || {
            tcx.hir().for_each_module(|module| tcx.ensure().check_mod_impl_wf(module))
        });
    })<span class="question-mark">?</span>;

    tcx.sess.track_errors(|| {
        tcx.sess.time(<span class="string">&quot;coherence_checking&quot;</span>, || {
            <span class="kw">for </span><span class="kw-2">&amp;</span>trait_def_id <span class="kw">in </span>tcx.all_local_trait_impls(()).keys() {
                tcx.ensure().coherent_trait(trait_def_id);
            }

            <span class="comment">// these queries are executed for side-effects (error reporting):
            </span>tcx.ensure().crate_inherent_impls(());
            tcx.ensure().crate_inherent_impls_overlap_check(());
        });
    })<span class="question-mark">?</span>;

    <span class="kw">if </span>tcx.features().rustc_attrs {
        tcx.sess.track_errors(|| {
            tcx.sess.time(<span class="string">&quot;variance_testing&quot;</span>, || variance::test::test_variance(tcx));
        })<span class="question-mark">?</span>;
    }

    tcx.sess.track_errors(|| {
        tcx.sess.time(<span class="string">&quot;wf_checking&quot;</span>, || {
            tcx.hir().par_for_each_module(|module| tcx.ensure().check_mod_type_wf(module))
        });
    })<span class="question-mark">?</span>;

    <span class="comment">// NOTE: This is copy/pasted in librustdoc/core.rs and should be kept in sync.
    </span><a href="#463">tcx</a>.sess.time(<span class="string">&quot;item_types_checking&quot;</span>, || {
        <a href="#463">tcx</a>.hir().for_each_module(|module| <a href="#463">tcx</a>.ensure().check_mod_item_types(<a href="#513">module</a>))
    });

    <a href="#463">tcx</a>.sess.time(<span class="string">&quot;item_bodies_checking&quot;</span>, || <a href="#463">tcx</a>.typeck_item_bodies(()));

    <a href="check_unused.rs.html#10">check_unused::check_crate</a>(<a href="#463">tcx</a>);
    <a href="#445">check_for_entry_fn</a>(<a href="#463">tcx</a>);

    <span class="kw">if let </span><span class="prelude-val">Some</span>(reported) = <a href="#463">tcx</a>.sess.has_errors() { <span class="prelude-val">Err</span>(<a href="#521">reported</a>) } <span class="kw">else </span>{ <span class="prelude-val">Ok</span>(()) }
}

<span class="doccomment">/// A quasi-deprecated helper used in rustdoc and clippy to get
/// the type from a HIR node.
</span><span class="kw">pub fn </span>hir_ty_to_ty&lt;<span class="lifetime">&#39;tcx</span>&gt;(tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;, hir_ty: <span class="kw-2">&amp;</span>hir::Ty&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; Ty&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="comment">// In case there are any projections, etc., find the &quot;environment&quot;
    // def-ID that will be used to determine the traits/predicates in
    // scope.  This is derived from the enclosing item-like thing.
    </span><span class="kw">let </span>env_def_id = <a href="#526">tcx</a>.hir().get_parent_item(<a href="#526">hir_ty</a>.hir_id);
    <span class="kw">let </span>item_cx = <span class="self">self</span>::collect::ItemCtxt::new(<a href="#526">tcx</a>, <a href="#530">env_def_id</a>.to_def_id());
    &lt;<span class="kw">dyn </span>AstConv&lt;<span class="lifetime">&#39;_</span>&gt;&gt;::ast_ty_to_ty(<span class="kw-2">&amp;</span><a href="#531">item_cx</a>, <a href="#526">hir_ty</a>)
}

<span class="kw">pub fn </span>hir_trait_to_predicates&lt;<span class="lifetime">&#39;tcx</span>&gt;(
    tcx: TyCtxt&lt;<span class="lifetime">&#39;tcx</span>&gt;,
    hir_trait: <span class="kw-2">&amp;</span>hir::TraitRef&lt;<span class="lifetime">&#39;_</span>&gt;,
    self_ty: Ty&lt;<span class="lifetime">&#39;tcx</span>&gt;,
) -&gt; Bounds&lt;<span class="lifetime">&#39;tcx</span>&gt; {
    <span class="comment">// In case there are any projections, etc., find the &quot;environment&quot;
    // def-ID that will be used to determine the traits/predicates in
    // scope.  This is derived from the enclosing item-like thing.
    </span><span class="kw">let </span>env_def_id = <a href="#536">tcx</a>.hir().get_parent_item(<a href="#537">hir_trait</a>.hir_ref_id);
    <span class="kw">let </span>item_cx = <span class="self">self</span>::collect::ItemCtxt::new(<a href="#536">tcx</a>, <a href="#543">env_def_id</a>.to_def_id());
    <span class="kw">let </span><span class="kw-2">mut </span>bounds = Bounds::default();
    <span class="kw">let _ </span>= &lt;<span class="kw">dyn </span>AstConv&lt;<span class="lifetime">&#39;_</span>&gt;&gt;::instantiate_poly_trait_ref(
        <span class="kw-2">&amp;</span><a href="#544">item_cx</a>,
        <a href="#537">hir_trait</a>,
        <a href="../../rustc_span/span_encoding/constant.DUMMY_SP.html">DUMMY_SP</a>,
        ty::BoundConstness::NotConst,
        <a href="#538">self_ty</a>,
        <span class="kw-2">&amp;mut </span><a href="#545">bounds</a>,
        <span class="bool-val">true</span>,
    );

    <a href="#545">bounds</a>
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rustc_typeck" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-dev" ></div></body></html>