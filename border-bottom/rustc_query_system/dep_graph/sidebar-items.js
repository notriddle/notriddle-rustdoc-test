window.SIDEBAR_ITEMS = {"enum":[["DepNodeColor",""],["FingerprintStyle","Describes the contents of the fingerprint generated by a given query."],["TaskDepsRef",""]],"fn":[["hash_result",""]],"mod":[["debug","Code for debugging the dep-graph."],["dep_node","This module defines the `DepNode` type which the compiler uses to represent nodes in the dependency graph. A `DepNode` consists of a `DepKind` (which specifies the kind of thing it represents, like a piece of HIR, MIR, etc) and a `Fingerprint`, a 128 bit hash value the exact meaning of which depends on the node’s `DepKind`. Together, the kind and the fingerprint fully identify a dependency node, even across multiple compilation sessions. In other words, the value of the fingerprint does not depend on anything that is specific to a given compilation session, like an unpredictable interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a pointer. The concept behind this could be compared to how git commit hashes uniquely identify a given commit and has a few advantages:"],["graph",""],["query",""],["serialized","The data that we will serialize and deserialize."]],"struct":[["DepGraph",""],["DepGraphQuery",""],["DepNode",""],["DepNodeIndex",""],["SerializedDepGraph","Data for use when recompiling the current crate."],["SerializedDepNodeIndex",""],["TaskDeps",""],["WorkProduct","A “work product” is an intermediate result that we save into the incremental directory for later re-use. The primary example are the object files that we save for each partition at code generation time."],["WorkProductId","A “work product” corresponds to a `.o` (or other) file that we save in between runs. These IDs do not have a `DefId` but rather some independent path or string that persists between runs without the need to be mapped or unmapped. (This ensures we can serialize them even in the absence of a tcx.)"]],"trait":[["DepContext",""],["DepKind","Describe the different families of dependency nodes."],["DepNodeParams",""],["HasDepContext",""]]};