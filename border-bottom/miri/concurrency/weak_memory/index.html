<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of C++11-consistent weak memory emulation using store buffers based on Dynamic Race Detection for C++ (‚Äúthe paper‚Äù): https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf"><meta name="keywords" content="rust, rustlang, rust-lang, weak_memory"><title>miri::concurrency::weak_memory - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../miri/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../miri/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module weak_memory</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../miri/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">miri</a>::<wbr><a href="../index.html">concurrency</a>::<wbr><a class="mod" href="#">weak_memory</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/miri/concurrency/weak_memory.rs.html#1-630">source</a> ¬∑ <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of C++11-consistent weak memory emulation using store buffers
based on Dynamic Race Detection for C++ (‚Äúthe paper‚Äù):
<a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf</a></p>
<p>This implementation will never generate weak memory behaviours forbidden by the C++11 model,
but it is incapable of producing all possible weak behaviours allowed by the model. There are
certain weak behaviours observable on real hardware but not while using this.</p>
<p>Note that this implementation does not fully take into account of C++20‚Äôs memory model revision to SC accesses
and fences introduced by P0668 (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html</a>).
This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20
disallows (<a href="https://github.com/rust-lang/miri/issues/2301">https://github.com/rust-lang/miri/issues/2301</a>).</p>
<p>A modification is made to the paper‚Äôs model to partially address C++20 changes.
Specifically, if an SC load reads from an atomic store of any ordering, then a later SC load cannot read from
an earlier store in the location‚Äôs modification order. This is to prevent creating a backwards S edge from the second
load to the first, as a result of C++20‚Äôs coherence-ordered before rules.</p>
<p>Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++‚Äôs
std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the
same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes
an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is
A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (<a href="https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf">https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf</a>)
However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).</p>
<p>If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust‚Äôs atomic accesses
and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!</p>
<p>One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in
Taming Release-Acquire Consistency by Ori Lahav et al. (<a href="https://plv.mpi-sws.org/sra/paper.pdf">https://plv.mpi-sws.org/sra/paper.pdf</a>) or Promising Semantics noted above,
is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location
and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record
information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.
Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is
used to make sure a value in a thread‚Äôs view is not overwritten by a write that occured earlier than the one in the existing view.
In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.</p>
<p>The C++ memory model is built around the notion of an ‚Äòatomic object‚Äô, so it would be natural
to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has
‚Äòatomic accesses‚Äô. Therefore Miri cannot know when and where atomic ‚Äòobjects‚Äô are being
created or destroyed, to manage its store buffers. Instead, we hence lazily create an
atomic object on the first atomic access to a given region, and we destroy that object
on the next non-atomic or imperfectly overlapping atomic access to that region.
These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and
get_or_create_store_buffer() on atomic accesses. This mostly works well, but it does
lead to some issues (<a href="https://github.com/rust-lang/miri/issues/2164">https://github.com/rust-lang/miri/issues/2164</a>).</p>
<p>One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations
than the C++20 atomic API was intended to allow, such as non-atomically accessing
a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation
(such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.
In Rust, these operations can only be done through a <code>&amp;mut AtomicFoo</code> reference or one derived from it, therefore these operations
can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.
A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.
Mixed size atomic accesses must not race with any other atomic access, whether read or write, or a UB will be thrown.
You can refer to test cases in weak_memory/extra_cpp.rs and weak_memory/extra_cpp_unsafe.rs for examples of these operations.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LoadInfo.html" title="miri::concurrency::weak_memory::LoadInfo struct">LoadInfo</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StoreBuffer.html" title="miri::concurrency::weak_memory::StoreBuffer struct">StoreBuffer</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StoreBufferAlloc.html" title="miri::concurrency::weak_memory::StoreBufferAlloc struct">StoreBufferAlloc</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StoreElement.html" title="miri::concurrency::weak_memory::StoreElement struct">StoreElement</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.LoadRecency.html" title="miri::concurrency::weak_memory::LoadRecency enum">LoadRecency</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="item-right docblock-short">Whether a load returned the latest value or not.</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.STORE_BUFFER_LIMIT.html" title="miri::concurrency::weak_memory::STORE_BUFFER_LIMIT constant">STORE_BUFFER_LIMIT</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EvalContextExt.html" title="miri::concurrency::weak_memory::EvalContextExt trait">EvalContextExt</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.AllocExtra.html" title="miri::concurrency::weak_memory::AllocExtra type">AllocExtra</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="miri" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-dev" ></div></body></html>