window.SIDEBAR_ITEMS = {"enum":[["Abi","Describes how values of the type are passed by target ABIs, in terms of categories of C types there are ABI rules for."],["Endian","Endianness of the target, which must match cfg(target-endian)."],["FieldsShape","Describes how the fields of a type are located in memory."],["InitKind","Used in `might_permit_raw_init` to indicate the kind of initialisation that is checked to be valid"],["Integer","Integers, also used for enum discriminants."],["PointerKind",""],["Primitive","Fundamental unit of memory access and layout."],["Scalar","Information about one scalar component of a Rust type."],["TagEncoding",""],["TargetDataLayoutErrors",""],["Variants",""]],"mod":[["call",""]],"struct":[["AbiAndPrefAlign","A pair of alignments, ABI-mandated and preferred."],["AddressSpace","An identifier that specifies the address space that some operation should operate on. Special address spaces have an effect on code generation, depending on the target and the address spaces it implements."],["Align","Alignment of a type in bytes (always a power of two)."],["Layout",""],["LayoutS",""],["Niche",""],["PointeeInfo",""],["Size","Size of a type in bytes."],["TargetDataLayout","Parsed Data layout for a target, which contains everything needed to compute layouts."],["TyAndLayout","The layout of a type, alongside the type itself. Provides various type traversal APIs (e.g., recursing into fields)."],["VariantIdx",""],["WrappingRange","Inclusive wrap-around range of valid values, that is, if start > end, it represents `start..=MAX`, followed by `0..=end`."]],"trait":[["HasDataLayout",""],["TyAbiInterface","Trait that needs to be implemented by the higher-level type representation (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality."]]};