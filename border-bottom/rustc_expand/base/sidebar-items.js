window.SIDEBAR_ITEMS = {"enum":[["Annotatable",""],["ExpandResult","Result of an expansion that may need to be retried. Consider using this for non-`MultiItemModifier` expanders as well."],["MacroKind","The kind of macro invocation or definition."],["SyntaxExtensionKind","A syntax extension kind."]],"fn":[["ann_pretty_printing_compatibility_hack",""],["check_zero_tts","Non-fatally assert that `tts` is empty. Note that this function returns even when `tts` is non-empty, macros that need to stop compilation should call `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be done as rarely as possible)."],["expr_to_spanned_string","Extracts a string literal from the macro expanded version of `expr`, returning a diagnostic error of `err_msg` if `expr` is not a string literal. The returned bool indicates whether an applicable suggestion has already been added to the diagnostic to avoid emitting multiple suggestions. `Err(None)` indicates that an ast error was encountered."],["expr_to_string","Extracts a string literal from the macro expanded version of `expr`, emitting `err_msg` if `expr` is not a string literal. This does not stop compilation on error, merely emits a non-fatal error and returns `None`."],["get_exprs_from_tts","Extracts comma-separated expressions from `tts`. On error, emit it, and return `None`."],["get_single_str_from_tts","Interpreting `tts` as a comma-separated sequence of expressions, expect exactly one string literal, or emit an error and return `None`."],["nt_pretty_printing_compatibility_hack",""],["parse_expr","Parse an expression. On error, emit it, advancing to `Eof`, and return `None`."],["parse_macro_name_and_helper_attrs",""],["pretty_printing_compatibility_hack","This nonterminal looks like some specific enums from `proc-macro-hack` and `procedural-masquerade` crates. We need to maintain some special pretty-printing behavior for them due to incorrect asserts in old versions of those crates and their wide use in the ecosystem. See issue #73345 for more details. FIXME(#73933): Remove this eventually."],["resolve_path","Resolves a `path` mentioned inside Rust code, returning an absolute path."]],"macro":[["make_MacEager",""],["make_stmts_default",""]],"struct":[["DummyResult","Fill-in macro expansion result, to allow compilation to continue after hitting errors."],["ExpansionData",""],["ExtCtxt","One of these is made during expansion and incrementally updated as we go; when a macro expansion occurs, the resulting nodes have the `backtrace() -> expn_data` of their expansion context stored into their span."],["Indeterminate","Error type that denotes indeterminacy."],["MacEager","`MacResult` implementation for the common case where you’ve already built each form of AST that you might return."],["ModuleData",""],["SyntaxExtension","A struct representing a macro definition in “lowered” form ready for expansion."]],"trait":[["AttrProcMacro",""],["BangProcMacro",""],["LintStoreExpand",""],["MacResult","The result of a macro expansion. The return values of the various methods are spliced into the AST at the callsite of the macro."],["MultiItemModifier",""],["ResolverExpand",""],["TTMacroExpander","Represents a thing that maps token trees to Macro Results"]],"type":[["DeriveResolutions",""],["LintStoreExpandDyn",""],["MacroExpanderFn",""]]};