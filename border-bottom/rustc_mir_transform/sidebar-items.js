window.SIDEBAR_ITEMS = {"fn":[["inner_mir_for_ctfe",""],["inner_optimized_mir",""],["is_mir_available",""],["mir_const","Make MIR ready for const evaluation. This is run on all MIR, not just on consts! FIXME(oli-obk): it’s unclear whether we still need this phase (and its corresponding query). We used to have this for pre-miri MIR based const eval."],["mir_const_qualif",""],["mir_drops_elaborated_and_const_checked","Obtain just the main MIR (no promoteds) and run some cleanups on it. This also runs mir borrowck before doing so in order to ensure that borrowck can be run and doesn’t end up missing the source MIR due to stealing happening."],["mir_for_ctfe","Compute the MIR that is used during CTFE (and thus has no optimizations run on it)"],["mir_for_ctfe_of_const_arg","Same as `mir_for_ctfe`, but used to get the MIR of a const generic parameter. The docs on `WithOptConstParam` explain this a bit more, but the TLDR is that we’d get cycle errors with `mir_for_ctfe`, because typeck would need to typeck the const parameter while type checking the main body, which in turn would try to type check the main body again."],["mir_keys","Finds the full set of `DefId`s within the current crate that have MIR associated with them."],["mir_promoted","Compute the main MIR body and the list of MIR bodies of the promoteds."],["optimized_mir","Optimize the MIR and prepare it for codegen."],["promoted_mir","Fetch all the promoteds of an item and prepare their MIR bodies to be ready for constant evaluation once all substitutions become known."],["provide",""],["remap_mir_for_const_eval_select",""],["run_analysis_cleanup_passes","After this series of passes, no lifetime analysis based on borrowing can be done."],["run_analysis_to_runtime_passes",""],["run_optimization_passes",""],["run_runtime_cleanup_passes","Returns the sequence of passes that do the initial cleanup of runtime MIR."],["run_runtime_lowering_passes","Returns the sequence of passes that lowers analysis to runtime MIR."]],"mod":[["abort_unwinding_calls",""],["add_call_guards",""],["add_moves_for_packed_drops",""],["add_retag","This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate. It has to be run really early, before transformations like inlining, because introducing these calls adds UB – so, conceptually, this pass is actually part of MIR building, and only after this pass we think of the program has having the normal MIR semantics."],["check_const_item_mutation",""],["check_packed_ref",""],["check_unsafety",""],["cleanup_post_borrowck","This module provides a pass to replacing the following statements with `Nop`s"],["const_debuginfo","Finds locals which are assigned once to a const and unused except for debuginfo and converts their debuginfo to use the const directly, allowing the local to be removed."],["const_goto","This pass optimizes the following sequence"],["const_prop","Propagates constants for early reporting of statically known assertion failures"],["const_prop_lint","Propagates constants for early reporting of statically known assertion failures"],["coverage",""],["dead_store_elimination","This module implements a dead store elimination (DSE) routine."],["deaggregator",""],["deduplicate_blocks","This pass finds basic blocks that are completely equal, and replaces all uses with just one of them."],["deref_separator",""],["dest_prop","Propagates assignment destinations backwards in the CFG to eliminate redundant assignments."],["dump_mir","This pass just dumps MIR at a specified point."],["early_otherwise_branch",""],["elaborate_box_derefs","This pass transforms derefs of Box into a deref of the pointer inside Box."],["elaborate_drops",""],["ffi_unwind_calls",""],["function_item_references",""],["generator","This is the implementation of the pass which transforms generators into state machines."],["inline","Inlining pass for MIR functions"],["instcombine","Performs various peephole optimizations."],["lower_intrinsics","Lowers intrinsic calls"],["lower_slice_len","This pass lowers calls to core::slice::len to just Len op. It should run before inlining!"],["marker",""],["match_branches",""],["multiple_return_terminators","This pass removes jumps to basic blocks containing only a return, and replaces them with a return instead."],["normalize_array_len","This pass eliminates casting of arrays into slices when their length is taken using `.len()` method. Handy to preserve information in MIR for const prop"],["nrvo","See the docs for [`RenameReturnPlace`]."],["pass_manager",""],["remove_false_edges",""],["remove_noop_landing_pads",""],["remove_storage_markers","This pass removes storage markers if they won’t be emitted during codegen."],["remove_uninit_drops",""],["remove_unneeded_drops","This pass replaces a drop of a type that does not need dropping, with a goto."],["remove_zsts","Removes assignments to ZST places."],["required_consts",""],["reveal_all","Normalizes MIR in RevealAll mode."],["separate_const_switch","A pass that duplicates switch-terminated blocks into a new copy for each predecessor, provided the predecessor sets the value being switched over to a constant."],["shim",""],["simplify","A number of passes which remove various redundancies in the CFG."],["simplify_branches",""],["simplify_comparison_integral",""],["simplify_try","The general point of the optimizations provided here is to simplify something like:"],["uninhabited_enum_branching","A pass that eliminates branches on uninhabited enum variants."],["unreachable_prop","A pass that propagates the unreachable terminator of a block to its predecessors when all of their successors are unreachable. This is achieved through a post-order traversal of the blocks."]]};