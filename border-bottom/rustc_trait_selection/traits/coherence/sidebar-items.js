window.SIDEBAR_ITEMS = {"enum":[["Conflict",""],["InCrate","Whether we do the orphan check relative to this crate or to some remote crate."],["OrphanCheckEarlyExit",""],["OrphanCheckErr",""]],"fn":[["add_placeholder_note",""],["equate",""],["equate_impl_headers",""],["implicit_negative","Given impl1 and impl2 check if both impls can be satisfied by a common type (including where-clauses) If so, return false, otherwise return true, they are disjoint."],["negative_impl","Given impl1 and impl2 check if both impls are never satisfied by a common type (including where-clauses) If so, return true, they are disjoint and false otherwise."],["negative_impl_exists","Try to prove that a negative impl exist for the given obligation and its super predicates."],["orphan_check","Checks the coherence orphan rules. `impl_def_id` should be the `DefId` of a trait impl. To pass, either the trait must be local, or else two conditions must be satisfied:"],["orphan_check_trait_ref","Checks whether a trait-ref is potentially implementable by a crate."],["overlap","Can both impl `a` and impl `b` be satisfied by a common type (including where-clauses)? If so, returns an `ImplHeader` that unifies the two impls."],["overlap_within_probe",""],["overlapping_impls","If there are types that satisfy both impls, invokes `on_overlap` with a suitably-freshened `ImplHeader` with those types substituted. Otherwise, invokes `no_overlap`."],["resolve_negative_obligation",""],["trait_ref_is_knowable",""],["trait_ref_is_local_or_fundamental",""],["with_fresh_ty_vars",""]],"struct":[["OrphanChecker",""],["OverlapResult",""]]};