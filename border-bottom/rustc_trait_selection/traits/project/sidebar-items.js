window.SIDEBAR_ITEMS = {"enum":[["ProjectAndUnifyResult","States returned from `poly_project_and_unify_type`. Takes the place of the old return type, which was:"],["Projected",""],["ProjectionCandidate",""],["ProjectionCandidateSet",""],["ProjectionError","When attempting to resolve `<T as TraitRef>::Name` …"],["Reveal","Depending on the stage of compilation, we want projection to be more or less conservative."]],"fn":[["assemble_candidate_for_impl_trait_in_trait","If the predicate’s item is an `ImplTraitPlaceholder`, we do a select on the corresponding trait ref. If this yields an `impl`, then we’re able to project to a concrete type, since we have an `impl`’s method  to provide the RPITIT."],["assemble_candidates_from_impls",""],["assemble_candidates_from_object_ty","In the case of a trait object like `<dyn Iterator<Item = ()> as Iterator>::Item` we can use the existential predicate in the trait object."],["assemble_candidates_from_param_env","The first thing we have to do is scan through the parameter environment to see whether there are any projection predicates there that can answer this question."],["assemble_candidates_from_predicates",""],["assemble_candidates_from_trait_def","In the case of a nested projection like <::FooT as Bar>::BarT, we may find that the definition of `Foo` has some clues:"],["assoc_def","Locate the definition of an associated type in the specialization hierarchy, starting from the given impl."],["assoc_ty_own_obligations",""],["confirm_callable_candidate",""],["confirm_candidate",""],["confirm_closure_candidate",""],["confirm_discriminant_kind_candidate",""],["confirm_fn_pointer_candidate",""],["confirm_generator_candidate",""],["confirm_impl_candidate",""],["confirm_impl_trait_in_trait_candidate",""],["confirm_param_env_candidate",""],["confirm_pointee_candidate",""],["confirm_select_candidate",""],["needs_normalization",""],["normalize","Normalizes any associated type projections in `value`, replacing them with a fully resolved type where possible. The return value combines the normalized result and any additional obligations that were incurred as result."],["normalize_projection_type","The guts of `normalize`: normalize a specific projection like `<T as Trait>::Item`. The result is always a type (and possibly additional obligations). If ambiguity arises, which implies that there are unresolved type variables in the projection, we will substitute a fresh type variable `$X` and generate a new obligation `<T as Trait>::Item == $X` for later."],["normalize_to",""],["normalize_to_error","If we are projecting `<T as Trait>::Item`, but `T: Trait` does not hold. In various error cases, we cannot generate a valid normalized projection. Therefore, we create an inference variable return an associated obligation that, when fulfilled, will lead to an error."],["normalize_with_depth","As `normalize`, but with a custom depth."],["normalize_with_depth_to",""],["opt_normalize_projection_type","The guts of `normalize`: normalize a specific projection like `<T as Trait>::Item`. The result is always a type (and possibly additional obligations). Returns `None` in the case of ambiguity, which indicates that there are unbound type variables."],["poly_project_and_unify_type","Evaluates constraints of the form:"],["project","Computes the result of a projection type (if we can)."],["project_and_unify_type","Evaluates constraints of the form:"],["try_normalize_with_depth_to",""],["with_replaced_escaping_bound_vars","Executes `f` on `value` after replacing all escaping bound variables with placeholders and then replaces these placeholders with the original bound variables in the result."]],"struct":[["AssocTypeNormalizer",""],["BoundVarReplacer",""],["InProgress",""],["PlaceholderReplacer",""],["Progress",""]],"trait":[["ProjectionCacheKeyExt",""]],"type":[["PolyProjectionObligation",""],["ProjectionObligation",""],["ProjectionTyObligation",""]]};