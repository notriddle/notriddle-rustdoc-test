window.SIDEBAR_ITEMS = {"enum":[["TupleArgumentsFlag",""]],"fn":[["anonymize_predicate",""],["closure_trait_ref_and_return_type",""],["count_own_vtable_entries","Given a trait `trait_ref`, returns the number of vtable entries that come from `trait_ref`, excluding its supertraits. Used in computing the vtable base for an upcast trait of a trait object."],["elaborate_obligations",""],["elaborate_predicates",""],["elaborate_predicates_with_span",""],["elaborate_trait_ref",""],["elaborate_trait_refs",""],["expand_trait_aliases",""],["generator_trait_ref_and_outputs",""],["get_vtable_index_of_object_method","Given an upcast trait object described by `object`, returns the index of the method `method_def_id` (which should be part of `object.upcast_trait_ref`) within the vtable for `object`."],["impl_item_is_final",""],["impl_subject_and_oblig","Instantiate all bound parameters of the impl subject with the given substs, returning the resulting subject and all obligations that arise. The obligations are closed under normalization."],["predicate_for_trait_def",""],["predicate_for_trait_ref",""],["supertrait_def_ids",""],["supertraits",""],["transitive_bounds",""],["transitive_bounds_that_define_assoc_type","A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may define the given associated type `assoc_name`. It uses the `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that aren’t related to `assoc_item`.  This is used when resolving types like `Self::Item` or `T::Item` and helps to avoid cycle errors (see e.g. #35237)."],["upcast_choices","Casts a trait reference into a reference to one of its super traits; returns `None` if `target_trait_def_id` is not a supertrait."]],"mod":[["traits","Trait Resolution. See the rustc-dev-guide for more information on how this works."]],"struct":[["Elaborator","“Elaboration” is the process of identifying all the predicates that are implied by a source predicate. Currently, this basically means walking the “supertraits” and other similar assumptions. For example, if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd` holds as well. Similarly, if we have `trait Foo: 'static`, and we know that `T: Foo`, then we know that `T: 'static`."],["FilterToTraits","A filter around an iterator of predicates that makes it yield up just trait references."],["PredicateSet",""],["SupertraitDefIds",""],["TraitAliasExpander","“Trait alias expansion” is the process of expanding a sequence of trait references into another sequence by transitively following all trait aliases. e.g. If you have bounds like `Foo + Send`, a trait alias `trait Foo = Bar + Sync;`, and another trait alias `trait Bar = Read + Write`, then the bounds would expand to `Read + Write + Sync + Send`. Expansion is done via a DFS (depth-first search), and the `visited` field is used to avoid cycles."],["TraitAliasExpansionInfo","Stores information about the expansion of a trait via a path of zero or more trait aliases."]],"type":[["Supertraits",""]]};