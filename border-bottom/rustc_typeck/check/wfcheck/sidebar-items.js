window.SIDEBAR_ITEMS = {"constant":[["HELP_FOR_SELF_TYPE",""]],"fn":[["augment_param_env","Add a new set of predicates to the caller_bounds of an existing param_env."],["check_associated_item",""],["check_associated_type_bounds","Checks all associated type defaults of trait `trait_def_id`."],["check_fn_or_method",""],["check_foreign_item",""],["check_gat_where_clauses","Require that the user writes where clauses on GATs for the implicit outlives bounds involving trait parameters in trait functions and lifetimes passed as GAT substs. See `self-outlives-lint` test."],["check_impl",""],["check_impl_item",""],["check_item","Checks that the field types (in a struct def’n) or argument types (in an enum def’n) are well-formed, meaning that they do not require any constraints not declared in the struct definition itself. For example, this definition would be illegal:"],["check_item_fn",""],["check_item_type",""],["check_method_receiver",""],["check_mod_type_wf",""],["check_object_unsafe_self_trait_by_name","Detect when an object unsafe trait is referring to itself in one of its associated items. When this is done, suggest using `Self` instead."],["check_param_wf",""],["check_return_position_impl_trait_in_trait_bounds","Basically `check_associated_type_bounds`, but separated for now and should be deduplicated when RPITITs get lowered into real associated items."],["check_trait",""],["check_trait_item",""],["check_type_defn","In a type definition, we check that to ensure that the types of the fields are well-formed."],["check_variances_for_type_defn",""],["check_well_formed",""],["check_where_clauses","Checks where-clauses and inline bounds that are declared on `def_id`."],["could_be_self",""],["e0307",""],["enter_wf_checking_ctxt",""],["error_392",""],["gather_gat_bounds","We use the following trait as an example throughout this function. Specifically, let’s assume that `to_check` here is the return type of `into_iter`, and the GAT we are checking this for is `Iter`."],["item_adt_kind",""],["provide",""],["receiver_is_implemented",""],["receiver_is_valid","Returns whether `receiver_ty` would be considered a valid receiver type for `self_ty`. If `arbitrary_self_types` is enabled, `receiver_ty` must transitively deref to `self_ty`, possibly through a `*const/mut T` raw pointer. If the feature is not enabled, the requirements are more strict: `receiver_ty` must implement `Receiver` and directly implement `Deref<Target = self_ty>`."],["region_known_to_outlive","Given a known `param_env` and a set of well formed types, can we prove that `region_a` outlives `region_b`"],["report_bivariance",""],["resolve_regions_with_wf_tys","Given a known `param_env` and a set of well formed types, set up an `InferCtxt`, call the passed function (to e.g. set up region constraints to be tested), then resolve region and return errors"],["ty_known_to_outlive","Given a known `param_env` and a set of well formed types, can we prove that `ty` outlives `region`."]],"struct":[["AdtField",""],["AdtVariant",""],["GATSubstCollector","TypeVisitor that looks for uses of GATs like `<P0 as Trait<P1..Pn>>::GAT<Pn..Pm>` and adds the arguments `P0..Pm` into the two vectors, `regions` and `types` (depending on their kind). For each parameter `Pi` also track the index `i`."],["WfCheckingCtxt",""]]};