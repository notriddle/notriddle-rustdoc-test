window.SIDEBAR_ITEMS = {"fn":[["borrowed_locals","The set of locals that are borrowed at some point in the MIR body."],["for_each_mut_borrow","Calls `f` for each mutable borrow or raw reference in the program."],["switch_on_enum_discriminant","Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is an enum discriminant."]],"mod":[["borrowed_locals",""],["init_locals","A less precise version of `MaybeInitializedPlaces` whose domain is entire locals."],["liveness",""],["storage_liveness",""]],"struct":[["DefinitelyInitializedPlaces","`DefinitelyInitializedPlaces` tracks all places that are definitely initialized upon reaching a particular point in the control flow for a function."],["EverInitializedPlaces","`EverInitializedPlaces` tracks all places that might have ever been initialized upon reaching a particular point in the control flow for a function, without an intervening `StorageDead`."],["MaybeBorrowedLocals","A dataflow analysis that tracks whether a pointer or reference could possibly exist that points to a given local."],["MaybeInitializedLocals",""],["MaybeInitializedPlaces","`MaybeInitializedPlaces` tracks all places that might be initialized upon reaching a particular point in the control flow for a function."],["MaybeLiveLocals","A live-variable dataflow analysis."],["MaybeRequiresStorage","Dataflow analysis that determines whether each local requires storage at a given location; i.e. whether its storage can go away without being observed."],["MaybeStorageLive",""],["MaybeTransitiveLiveLocals","Like `MaybeLiveLocals`, but does not mark locals as live if they are used in a dead assignment."],["MaybeUninitializedPlaces","`MaybeUninitializedPlaces` tracks all places that might be uninitialized upon reaching a particular point in the control flow for a function."],["OnMutBorrow",""]]};