<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clippy Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">2.</strong> Usage</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="lints.html"><strong aria-hidden="true">4.</strong> Clippy's Lints</a></li><li class="chapter-item expanded "><a href="continuous_integration/index.html"><strong aria-hidden="true">5.</strong> Continuous Integration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="continuous_integration/github_actions.html"><strong aria-hidden="true">5.1.</strong> GitHub Actions</a></li><li class="chapter-item expanded "><a href="continuous_integration/travis.html"><strong aria-hidden="true">5.2.</strong> Travis CI</a></li></ol></li><li class="chapter-item expanded "><a href="development/index.html"><strong aria-hidden="true">6.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/basics.html"><strong aria-hidden="true">6.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="development/adding_lints.html"><strong aria-hidden="true">6.2.</strong> Adding Lints</a></li><li class="chapter-item expanded "><a href="development/common_tools_writing_lints.html"><strong aria-hidden="true">6.3.</strong> Common Tools</a></li><li class="chapter-item expanded "><a href="development/infrastructure/index.html"><strong aria-hidden="true">6.4.</strong> Infrastructure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/infrastructure/sync.html"><strong aria-hidden="true">6.4.1.</strong> Syncing changes between Clippy and rust-lang/rust</a></li><li class="chapter-item expanded "><a href="development/infrastructure/backport.html"><strong aria-hidden="true">6.4.2.</strong> Backporting Changes</a></li><li class="chapter-item expanded "><a href="development/infrastructure/changelog_update.html"><strong aria-hidden="true">6.4.3.</strong> Updating the Changelog</a></li><li class="chapter-item expanded "><a href="development/infrastructure/release.html"><strong aria-hidden="true">6.4.4.</strong> Release a New Version</a></li><li class="chapter-item expanded "><a href="development/infrastructure/book.html"><strong aria-hidden="true">6.4.5.</strong> The Clippy Book</a></li></ol></li><li class="chapter-item expanded "><a href="development/proposals/index.html"><strong aria-hidden="true">6.5.</strong> Proposals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/proposals/roadmap-2021.html"><strong aria-hidden="true">6.5.1.</strong> Roadmap 2021</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clippy Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust-clippy/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p><a href="https://github.com/rust-lang/rust-clippy/actions?query=workflow%3A%22Clippy+Test%22+event%3Apush+branch%3Aauto"><img src="https://github.com/rust-lang/rust-clippy/workflows/Clippy%20Test/badge.svg?branch=auto&amp;event=push" alt="Clippy Test" /></a>
<a href="https://github.com/rust-lang/rust-clippy#license"><img src="https://img.shields.io/crates/l/clippy.svg" alt="License: MIT OR Apache-2.0" /></a></p>
<p>A collection of lints to catch common mistakes and improve your
<a href="https://github.com/rust-lang/rust">Rust</a> code.</p>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html">There are over 550 lints included in this crate!</a></p>
<p>Lints are divided into categories, each with a default <a href="https://doc.rust-lang.org/rustc/lints/levels.html">lint
level</a>. You can choose how
much Clippy is supposed to <del>annoy</del> help you by changing the lint level by
category.</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th><th>Default level</th></tr></thead><tbody>
<tr><td><code>clippy::all</code></td><td>all lints that are on by default (correctness, suspicious, style, complexity, perf)</td><td><strong>warn/deny</strong></td></tr>
<tr><td><code>clippy::correctness</code></td><td>code that is outright wrong or useless</td><td><strong>deny</strong></td></tr>
<tr><td><code>clippy::suspicious</code></td><td>code that is most likely wrong or useless</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::complexity</code></td><td>code that does something simple but in a complex way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::perf</code></td><td>code that can be written to run faster</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::style</code></td><td>code that should be written in a more idiomatic way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::pedantic</code></td><td>lints which are rather strict or might have false positives</td><td>allow</td></tr>
<tr><td><code>clippy::nursery</code></td><td>new lints that are still under development</td><td>allow</td></tr>
<tr><td><code>clippy::cargo</code></td><td>lints for the cargo manifest</td><td>allow</td></tr>
</tbody></table>
</div>
<p>More to come, please <a href="https://github.com/rust-lang/rust-clippy/issues">file an
issue</a> if you have ideas!</p>
<p>The <a href="https://rust-lang.github.io/rust-clippy/master/index.html">lint list</a> also
contains &quot;restriction lints&quot;, which are for things which are usually not
considered &quot;bad&quot;, but may be useful to turn on in specific cases. These should
be used very selectively, if at all.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>If you're using <code>rustup</code> to install and manage you're Rust toolchains, Clippy is
usually <strong>already installed</strong>. In that case you can skip this chapter and go to
the <a href="usage.html">Usage</a> chapter.</p>
<blockquote>
<p>Note: If you used the <code>minimal</code> profile when installing a Rust toolchain,
Clippy is not automatically installed.</p>
</blockquote>
<h2 id="using-rustup"><a class="header" href="#using-rustup">Using Rustup</a></h2>
<p>If Clippy was not installed for a toolchain, it can be installed with</p>
<pre><code>$ rustup component add clippy [--toolchain=&lt;name&gt;]
</code></pre>
<h2 id="from-source"><a class="header" href="#from-source">From Source</a></h2>
<p>Take a look at the <a href="development/basics.html#install-from-source">Basics</a> chapter in the Clippy developer guide to find step
by step instructions on how to build and install Clippy from source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>This chapter describes how to use Clippy to get the most out of it. Clippy can
be used as a <code>cargo</code> subcommand or, like <code>rustc</code>, directly with the
<code>clippy-driver</code> binary.</p>
<blockquote>
<p><em>Note:</em> This chapter assumes that you have Clippy installed already. If you're
not sure, take a look at the <a href="installation.html">Installation</a> chapter.</p>
</blockquote>
<h2 id="cargo-subcommand"><a class="header" href="#cargo-subcommand">Cargo subcommand</a></h2>
<p>The easiest and most common way to run Clippy is through <code>cargo</code>. To do that,
just run</p>
<pre><code class="language-bash">cargo clippy
</code></pre>
<h3 id="lint-configuration"><a class="header" href="#lint-configuration">Lint configuration</a></h3>
<p>The above command will run the default set of lints, which are included in the
lint group <code>clippy::all</code>. You might want to use even more lints or you might not
agree with every Clippy lint, and for that there are ways to configure lint
levels.</p>
<blockquote>
<p><em>Note:</em> Clippy is meant to be used with a generous sprinkling of
<code>#[allow(..)]</code>s through your code. So if you disagree with a lint, don't feel
bad disabling them for parts of your code or the whole project.</p>
</blockquote>
<h4 id="command-line"><a class="header" href="#command-line">Command line</a></h4>
<p>You can configure lint levels on the command line by adding
<code>-A/W/D clippy::lint_name</code> like this:</p>
<pre><code class="language-bash">cargo clippy -- -Aclippy::style -Wclippy::double_neg -Dclippy::perf
</code></pre>
<p>For <a href="continuous_integration/index.html">CI</a> all warnings can be elevated to errors which will inturn fail
the build and cause Clippy to exit with a code other than <code>0</code>.</p>
<pre><code>cargo clippy -- -Dwarnings
</code></pre>
<blockquote>
<p><em>Note:</em> Adding <code>-D warnings</code> will cause your build to fail if <strong>any</strong> warnings
are found in your code. That includes warnings found by rustc (e.g.
<code>dead_code</code>, etc.).</p>
</blockquote>
<p>For more information on configuring lint levels, see the <a href="https://doc.rust-lang.org/rustc/lints/levels.html#configuring-warning-levels">rustc documentation</a>.</p>
<h4 id="even-more-lints"><a class="header" href="#even-more-lints">Even more lints</a></h4>
<p>Clippy has lint groups which are allow-by-default. This means, that you will
have to enable the lints in those groups manually.</p>
<p>For a full list of all lints with their description and examples, please refer
to <a href="https://rust-lang.github.io/rust-clippy/master/index.html">Clippy's lint list</a>. The two most important allow-by-default groups are
described below:</p>
<h5 id="clippypedantic"><a class="header" href="#clippypedantic"><code>clippy::pedantic</code></a></h5>
<p>The first group is the <code>pedantic</code> group. This group contains really opinionated
lints, that may have some intentional false positives in order to prevent false
negatives. So while this group is ready to be used in production, you can expect
to sprinkle multiple <code>#[allow(..)]</code>s in your code. If you find any false
positives, you're still welcome to report them to us for future improvements.</p>
<blockquote>
<p>FYI: Clippy uses the whole group to lint itself.</p>
</blockquote>
<h5 id="clippyrestriction"><a class="header" href="#clippyrestriction"><code>clippy::restriction</code></a></h5>
<p>The second group is the <code>restriction</code> group. This group contains lints that
&quot;restrict&quot; the language in some way. For example the <code>clippy::unwrap</code> lint from
this group won't allow you to use <code>.unwrap()</code> in your code. You may want to look
through the lints in this group and enable the ones that fit your need.</p>
<blockquote>
<p><em>Note:</em> You shouldn't enable the whole lint group, but cherry-pick lints from
this group. Some lints in this group will even contradict other Clippy lints!</p>
</blockquote>
<h4 id="too-many-lints"><a class="header" href="#too-many-lints">Too many lints</a></h4>
<p>The most opinionated warn-by-default group of Clippy is the <code>clippy::style</code>
group. Some people prefer to disable this group completely and then cherry-pick
some lints they like from this group. The same is of course possible with every
other of Clippy's lint groups.</p>
<blockquote>
<p><em>Note:</em> We try to keep the warn-by-default groups free from false positives
(FP). If you find that a lint wrongly triggers, please report it in an issue
(if there isn't an issue for that FP already)</p>
</blockquote>
<h4 id="source-code"><a class="header" href="#source-code">Source Code</a></h4>
<p>You can configure lint levels in source code the same way you can configure
<code>rustc</code> lints:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(clippy::style)]

#[warn(clippy::double_neg)]
fn main() {
    let x = 1;
    let y = --x;
    //      ^^ warning: double negation
}
</code></pre></pre>
<h3 id="automatically-applying-clippy-suggestions"><a class="header" href="#automatically-applying-clippy-suggestions">Automatically applying Clippy suggestions</a></h3>
<p>Clippy can automatically apply some lint suggestions, just like the compiler.</p>
<pre><code class="language-terminal">cargo clippy --fix
</code></pre>
<h3 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h3>
<p>All the usual workspace options should work with Clippy. For example the
following command will run Clippy on the <code>example</code> crate in your workspace:</p>
<pre><code class="language-terminal">cargo clippy -p example
</code></pre>
<p>As with <code>cargo check</code>, this includes dependencies that are members of the
workspace, like path dependencies. If you want to run Clippy <strong>only</strong> on the
given crate, use the <code>--no-deps</code> option like this:</p>
<pre><code class="language-terminal">cargo clippy -p example -- --no-deps
</code></pre>
<h2 id="using-clippy-without-cargo-clippy-driver"><a class="header" href="#using-clippy-without-cargo-clippy-driver">Using Clippy without <code>cargo</code>: <code>clippy-driver</code></a></h2>
<p>Clippy can also be used in projects that do not use cargo. To do so, run
<code>clippy-driver</code> with the same arguments you use for <code>rustc</code>. For example:</p>
<pre><code class="language-terminal">clippy-driver --edition 2018 -Cpanic=abort foo.rs
</code></pre>
<blockquote>
<p><em>Note:</em> <code>clippy-driver</code> is designed for running Clippy and should not be used
as a general replacement for <code>rustc</code>. <code>clippy-driver</code> may produce artifacts
that are not optimized as expected, for example.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-clippy"><a class="header" href="#configuring-clippy">Configuring Clippy</a></h1>
<blockquote>
<p><strong>Note:</strong> The configuration file is unstable and may be deprecated in the future.</p>
</blockquote>
<p>Some lints can be configured in a TOML file named <code>clippy.toml</code> or <code>.clippy.toml</code>. It contains a
basic <code>variable = value</code> mapping eg.</p>
<pre><code class="language-toml">avoid-breaking-exported-api = false
disallowed-names = [&quot;toto&quot;, &quot;tata&quot;, &quot;titi&quot;]
cognitive-complexity-threshold = 30
</code></pre>
<p>See the <a href="https://rust-lang.github.io/rust-clippy/master/index.html">list of lints</a> for more information about which
lints can be configured and the meaning of the variables.</p>
<p>To deactivate the &quot;for further information visit <em>lint-link</em>&quot; message you can define the <code>CLIPPY_DISABLE_DOCS_LINKS</code>
environment variable.</p>
<h3 id="allowingdenying-lints"><a class="header" href="#allowingdenying-lints">Allowing/denying lints</a></h3>
<p>You can add options to your code to <code>allow</code>/<code>warn</code>/<code>deny</code> Clippy lints:</p>
<ul>
<li>
<p>the whole set of <code>Warn</code> lints using the <code>clippy</code> lint group (<code>#![deny(clippy::all)]</code>)</p>
</li>
<li>
<p>all lints using both the <code>clippy</code> and <code>clippy::pedantic</code> lint groups (<code>#![deny(clippy::all)]</code>,
<code>#![deny(clippy::pedantic)]</code>). Note that <code>clippy::pedantic</code> contains some very aggressive lints prone to false
positives.</p>
</li>
<li>
<p>only some lints (<code>#![deny(clippy::single_match, clippy::box_vec)]</code>, etc.)</p>
</li>
<li>
<p><code>allow</code>/<code>warn</code>/<code>deny</code> can be limited to a single function or module using <code>#[allow(...)]</code>, etc.</p>
</li>
</ul>
<p>Note: <code>allow</code> means to suppress the lint for your code. With <code>warn</code> the lint will only emit a warning, while with <code>deny</code>
the lint will emit an error, when triggering for your code. An error causes clippy to exit with an error code, so is
useful in scripts like CI/CD.</p>
<p>If you do not want to include your lint levels in your code, you can globally enable/disable lints by passing extra
flags to Clippy during the run:</p>
<p>To allow <code>lint_name</code>, run</p>
<pre><code class="language-terminal">cargo clippy -- -A clippy::lint_name
</code></pre>
<p>And to warn on <code>lint_name</code>, run</p>
<pre><code class="language-terminal">cargo clippy -- -W clippy::lint_name
</code></pre>
<p>This also works with lint groups. For example you can run Clippy with warnings for all lints enabled:</p>
<pre><code class="language-terminal">cargo clippy -- -W clippy::pedantic
</code></pre>
<p>If you care only about a single lint, you can allow all others and then explicitly warn on the lint(s) you are
interested in:</p>
<pre><code class="language-terminal">cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...
</code></pre>
<h3 id="specifying-the-minimum-supported-rust-version"><a class="header" href="#specifying-the-minimum-supported-rust-version">Specifying the minimum supported Rust version</a></h3>
<p>Projects that intend to support old versions of Rust can disable lints pertaining to newer features by specifying the
minimum supported Rust version (MSRV) in the clippy configuration file.</p>
<pre><code class="language-toml">msrv = &quot;1.30.0&quot;
</code></pre>
<p>The MSRV can also be specified as an inner attribute, like below.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![feature(custom_inner_attributes)]
#![clippy::msrv = &quot;1.30.0&quot;]

fn main() {
    ...
}
</code></pre></pre>
<p>You can also omit the patch version when specifying the MSRV, so <code>msrv = 1.30</code>
is equivalent to <code>msrv = 1.30.0</code>.</p>
<p>Note: <code>custom_inner_attributes</code> is an unstable feature so it has to be enabled explicitly.</p>
<p>Lints that recognize this configuration option can be
found <a href="https://rust-lang.github.io/rust-clippy/master/index.html#msrv">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippys-lints"><a class="header" href="#clippys-lints">Clippy's Lints</a></h1>
<p>Clippy offers a bunch of additional lints, to help its users write more correct
and idiomatic Rust code. A full list of all lints, that can be filtered by
category, lint level or keywords, can be found in the <a href="https://rust-lang.github.io/rust-clippy/">Clippy lint
documentation</a>.</p>
<p>This chapter will give an overview of the different lint categories, which kind
of lints they offer and recommended actions when you should see a lint out of
that category. For examples, see the <a href="https://rust-lang.github.io/rust-clippy/">Clippy lint documentation</a> and filter by
category.</p>
<p>The different lint groups were defined in the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories">Clippy 1.0 RFC</a>.</p>
<h2 id="correctness"><a class="header" href="#correctness">Correctness</a></h2>
<p>The <code>clippy::correctness</code> group is the only lint group in Clippy which lints are
deny-by-default and abort the compilation when triggered. This is for good
reason: If you see a <code>correctness</code> lint, it means that your code is outright
wrong or useless and you should try to fix it.</p>
<p>Lints in this category are carefully picked and should be free of false
positives. So just <code>#[allow]</code>ing those lints is not recommended.</p>
<h2 id="suspicious"><a class="header" href="#suspicious">Suspicious</a></h2>
<p>The <code>clippy::suspicious</code> group is similar to the correctness lints in that it
contains lints that trigger on code that is really <em>sus</em> and should be fixed. As
opposed to correctness lints, it might be possible that the linted code is
intentionally written like it is.</p>
<p>It is still recommended to fix code that is linted by lints out of this group
instead of <code>#[allow]</code>ing the lint. In case you intentionally have written code
that offends the lint you should specifically and locally <code>#[allow]</code> the lint
and add give a reason why the code is correct as written.</p>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<p>The <code>clippy::complexity</code> group offers lints that give you suggestions on how to
simplify your code. It mostly focuses on code that can be written in a shorter
and more readable way, while preserving the semantics.</p>
<p>If you should see a complexity lint, it usually means that you can remove or
replace some code and it is recommended to do so. However, if you need the more
complex code for some expressiveness reason, it is recommended to allow
complexity lints on a case-by-case basis.</p>
<h2 id="perf"><a class="header" href="#perf">Perf</a></h2>
<p>The <code>clippy::perf</code> group gives you suggestions on how you can increase the
performance of your code. Those lints are mostly about code that the compiler
can't trivially optimize, but has to be written in a slightly different way to
make the optimizer's job easier.</p>
<p>Perf lints are usually easy to apply and it is recommended to do so.</p>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>The <code>clippy::style</code> group is mostly about writing idiomatic code. Because style
is subjective, this lint group is the most opinionated warn-by-default group in
Clippy.</p>
<p>If you see a style lint, applying the suggestion usually makes your code more
readable and idiomatic. But because we know that this is opinionated, feel free
to sprinkle <code>#[allow]</code>s for style lints in your code or <code>#![allow]</code> a style lint
on your whole crate if you disagree with the suggested style completely.</p>
<h2 id="pedantic"><a class="header" href="#pedantic">Pedantic</a></h2>
<p>The <code>clippy::pedantic</code> group makes Clippy even more <em>pedantic</em>. You can enable
the whole group with <code>#![warn(clippy::pedantic)]</code> in the <code>lib.rs</code>/<code>main.rs</code> of
your crate. This lint group is for Clippy power users that want an in depth
check of their code.</p>
<blockquote>
<p><em>Note:</em> Instead of enabling the whole group (like Clippy itself does), you may
want to cherry-pick lints out of the pedantic group.</p>
</blockquote>
<p>If you enable this group, expect to also use <code>#[allow]</code> attributes generously
throughout your code. Lints in this group are designed to be pedantic and false
positives sometimes are intentional in order to prevent false negatives.</p>
<h2 id="restriction"><a class="header" href="#restriction">Restriction</a></h2>
<p>The <code>clippy::restriction</code> group contains lints that will <em>restrict</em> you from
using certain parts of the Rust language. It is <strong>not</strong> recommended to enable
the whole group, but rather cherry-pick lints that are useful for your code base
and your use case.</p>
<blockquote>
<p><em>Note:</em> Clippy will produce a warning if it finds a
<code>#![warn(clippy::restriction)]</code> attribute in your code!</p>
</blockquote>
<p>Lints from this group will restrict you in some way. If you enable a restriction
lint for your crate it is recommended to also fix code that this lint triggers
on. However, those lints are really strict by design and you might want to
<code>#[allow]</code> them in some special cases, with a comment justifying that.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>The <code>clippy::cargo</code> group gives you suggestions on how to improve your
<code>Cargo.toml</code> file. This might be especially interesting if you want to publish
your crate and are not sure if you have all useful information in your
<code>Cargo.toml</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<p>It is recommended to run Clippy on CI with <code>-Dwarnings</code>, so that Clippy lints
prevent CI from passing. To enforce errors on warnings on all <code>cargo</code> commands
not just <code>cargo clippy</code>, you can set the env var <code>RUSTFLAGS=&quot;-Dwarnings&quot;</code>.</p>
<p>We recommend to use Clippy from the same toolchain, that you use for compiling
your crate for maximum compatibility. E.g. if your crate is compiled with the
<code>stable</code> toolchain, you should also use <code>stable</code> Clippy.</p>
<blockquote>
<p><em>Note:</em> New Clippy lints are first added to the <code>nightly</code> toolchain. If you
want to help with improving Clippy and have CI resources left, please consider
adding a <code>nightly</code> Clippy check to your CI and report problems like false
positives back to us. With that we can fix bugs early, before they can get to
stable.</p>
</blockquote>
<p>This chapter will give an overview on how to use Clippy on different popular CI
providers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h1>
<p>GitHub hosted runners using the latest stable version of Rust have Clippy pre-installed.
It is as simple as running <code>cargo clippy</code> to run lints against the codebase.</p>
<pre><code class="language-yml">on: push
name: Clippy check

# Make sure CI fails on all warnings, including Clippy lints
env:
  RUSTFLAGS: &quot;-Dwarnings&quot;

jobs:
  clippy_check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Clippy
        run: cargo clippy --all-targets --all-features
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h1>
<p>You can add Clippy to Travis CI in the same way you use it locally:</p>
<pre><code class="language-yml">language: rust
rust:
  - stable
  - beta
before_script:
  - rustup component add clippy
script:
  - cargo clippy
  # if you want the build job to fail when encountering warnings, use
  - cargo clippy -- -D warnings
  # in order to also check tests and non-default crate features, use
  - cargo clippy --all-targets --all-features -- -D warnings
  - cargo test
  # etc.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy-development"><a class="header" href="#clippy-development">Clippy Development</a></h1>
<p>Hello fellow Rustacean! If you made it here, you're probably interested in
making Clippy better by contributing to it. In that case, welcome to the
project!</p>
<blockquote>
<p><em>Note:</em> If you're just interested in using Clippy, there's nothing to see from
this point onward and you should return to one of the earlier chapters.</p>
</blockquote>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>If this is your first time contributing to Clippy, you should first read the
<a href="development/basics.html">Basics docs</a>. This will explain the basics on how to get the source
code and how to compile and test the code.</p>
<h2 id="writing-code"><a class="header" href="#writing-code">Writing code</a></h2>
<p>If you have done the basic setup, it's time to start hacking.</p>
<p>The <a href="development/adding_lints.html">Adding lints</a> chapter is a walk through on how to add a
new lint to Clippy. This is also interesting if you just want to fix a lint,
because it also covers how to test lints and gives an overview of the bigger
picture.</p>
<p>If you want to add a new lint or change existing ones apart from bugfixing, it's
also a good idea to give the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#stability-guarantees">stability guarantees</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories">lint categories</a> sections of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md">Clippy 1.0 RFC</a> a
quick read. The lint categories are also described <a href="development/../lints.html">earlier in this
book</a>.</p>
<blockquote>
<p><em>Note:</em> Some higher level things about contributing to Clippy are still
covered in the <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> document. Some of those will be moved to
the book over time, like:</p>
<ul>
<li>Finding something to fix</li>
<li>IDE setup</li>
<li>High level overview on how Clippy works</li>
<li>Triage procedure</li>
<li>Bors and Homu</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-for-hacking-on-clippy"><a class="header" href="#basics-for-hacking-on-clippy">Basics for hacking on Clippy</a></h1>
<p>This document explains the basics for hacking on Clippy. Besides others, this
includes how to build and test Clippy. For a more in depth description on the
codebase take a look at <a href="https://github.com/rust-lang/rust-clippy/blob/master/book/src/development/adding_lints.md">Adding Lints</a> or <a href="https://github.com/rust-lang/rust-clippy/blob/master/book/src/development/common_tools_writing_lints.md">Common Tools</a>.</p>
<ul>
<li><a href="development/basics.html#basics-for-hacking-on-clippy">Basics for hacking on Clippy</a>
<ul>
<li><a href="development/basics.html#get-the-code">Get the Code</a></li>
<li><a href="development/basics.html#building-and-testing">Building and Testing</a></li>
<li><a href="development/basics.html#cargo-dev"><code>cargo dev</code></a></li>
<li><a href="development/basics.html#lintcheck">lintcheck</a></li>
<li><a href="development/basics.html#pr">PR</a></li>
<li><a href="development/basics.html#common-abbreviations">Common Abbreviations</a></li>
<li><a href="development/basics.html#install-from-source">Install from source</a></li>
</ul>
</li>
</ul>
<h2 id="get-the-code"><a class="header" href="#get-the-code">Get the Code</a></h2>
<p>First, make sure you have checked out the latest version of Clippy. If this is
your first time working on Clippy, create a fork of the repository and clone it
afterwards with the following command:</p>
<pre><code class="language-bash">git clone git@github.com:&lt;your-username&gt;/rust-clippy
</code></pre>
<p>If you've already cloned Clippy in the past, update it to the latest version:</p>
<pre><code class="language-bash"># If the upstream remote has not been added yet
git remote add upstream https://github.com/rust-lang/rust-clippy
# upstream has to be the remote of the rust-lang/rust-clippy repo
git fetch upstream
# make sure that you are on the master branch
git checkout master
# rebase your master branch on the upstream master
git rebase upstream/master
# push to the master branch of your fork
git push
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and Testing</a></h2>
<p>You can build and test Clippy like every other Rust project:</p>
<pre><code class="language-bash">cargo build  # builds Clippy
cargo test   # tests Clippy
</code></pre>
<p>Since Clippy's test suite is pretty big, there are some commands that only run a
subset of Clippy's tests:</p>
<pre><code class="language-bash"># only run UI tests
cargo uitest
# only run UI tests starting with `test_`
TESTNAME=&quot;test_&quot; cargo uitest
# only run dogfood tests
cargo dev dogfood
</code></pre>
<p>If the output of a <a href="https://rustc-dev-guide.rust-lang.org/tests/adding.html#guide-to-the-ui-tests">UI test</a> differs from the expected output, you can update
the reference file with:</p>
<pre><code class="language-bash">cargo dev bless
</code></pre>
<p>For example, this is necessary, if you fix a typo in an error message of a lint
or if you modify a test file to add a test case.</p>
<blockquote>
<p><em>Note:</em> This command may update more files than you intended. In that case
only commit the files you wanted to update.</p>
</blockquote>
<h2 id="cargo-dev"><a class="header" href="#cargo-dev"><code>cargo dev</code></a></h2>
<p>Clippy has some dev tools to make working on Clippy more convenient. These tools
can be accessed through the <code>cargo dev</code> command. Available tools are listed
below. To get more information about these commands, just call them with
<code>--help</code>.</p>
<pre><code class="language-bash"># formats the whole Clippy codebase and all tests
cargo dev fmt
# register or update lint names/groups/...
cargo dev update_lints
# create a new lint and register it
cargo dev new_lint
# deprecate a lint and attempt to remove code relating to it
cargo dev deprecate
# automatically formatting all code before each commit
cargo dev setup git-hook
# (experimental) Setup Clippy to work with IntelliJ-Rust
cargo dev setup intellij
# runs the `dogfood` tests
cargo dev dogfood
</code></pre>
<p>More about intellij command usage and reasons
<a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#intellij-rust">here</a></p>
<h2 id="lintcheck"><a class="header" href="#lintcheck">lintcheck</a></h2>
<p><code>cargo lintcheck</code> will build and run clippy on a fixed set of crates and
generate a log of the results.  You can <code>git diff</code> the updated log against its
previous version and see what impact your lint made on a small set of crates.
If you add a new lint, please audit the resulting warnings and make sure there
are no false positives and that the suggestions are valid.</p>
<p>Refer to the tools <a href="https://github.com/rust-lang/rust-clippy/blob/master/lintcheck/README.md">README</a> for more details.</p>
<h2 id="pr"><a class="header" href="#pr">PR</a></h2>
<p>We follow a rustc no merge-commit policy. See
<a href="https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr">https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr</a>.</p>
<h2 id="common-abbreviations"><a class="header" href="#common-abbreviations">Common Abbreviations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Abbreviation</th><th>Meaning</th></tr></thead><tbody>
<tr><td>UB</td><td>Undefined Behavior</td></tr>
<tr><td>FP</td><td>False Positive</td></tr>
<tr><td>FN</td><td>False Negative</td></tr>
<tr><td>ICE</td><td>Internal Compiler Error</td></tr>
<tr><td>AST</td><td>Abstract Syntax Tree</td></tr>
<tr><td>MIR</td><td>Mid-Level Intermediate Representation</td></tr>
<tr><td>HIR</td><td>High-Level Intermediate Representation</td></tr>
<tr><td>TCX</td><td>Type context</td></tr>
</tbody></table>
</div>
<p>This is a concise list of abbreviations that can come up during Clippy
development. An extensive general list can be found in the <a href="https://rustc-dev-guide.rust-lang.org/appendix/glossary.html">rustc-dev-guide
glossary</a>. Always feel free to ask if an abbreviation or meaning is
unclear to you.</p>
<h2 id="install-from-source"><a class="header" href="#install-from-source">Install from source</a></h2>
<p>If you are hacking on Clippy and want to install it from source, do the
following:</p>
<p>First, take note of the toolchain
<a href="https://rust-lang.github.io/rustup/overrides.html">override</a> in
<code>/rust-toolchain</code>. We will use this override to install Clippy into the right
toolchain.</p>
<blockquote>
<p>Tip: You can view the active toolchain for the current directory with <code>rustup show active-toolchain</code>.</p>
</blockquote>
<p>From the Clippy project root, run the following command to build the Clippy
binaries and copy them into the toolchain directory. This will override the
currently installed Clippy component.</p>
<pre><code class="language-terminal">cargo build --release --bin cargo-clippy --bin clippy-driver -Zunstable-options --out-dir &quot;$(rustc --print=sysroot)/bin&quot;
</code></pre>
<p>Now you may run <code>cargo clippy</code> in any project, using the toolchain where you
just installed Clippy.</p>
<pre><code class="language-terminal">cd my-project
cargo +nightly-2021-07-01 clippy
</code></pre>
<p>...or <code>clippy-driver</code></p>
<pre><code class="language-terminal">clippy-driver +nightly-2021-07-01 &lt;filename&gt;
</code></pre>
<p>If you need to restore the default Clippy installation, run the following (from
the Clippy project root).</p>
<pre><code class="language-terminal">rustup component remove clippy
rustup component add clippy
</code></pre>
<blockquote>
<p><strong>DO NOT</strong> install using <code>cargo install --path . --force</code> since this will
overwrite rustup
<a href="https://rust-lang.github.io/rustup/concepts/proxies.html">proxies</a>. That is,
<code>~/.cargo/bin/cargo-clippy</code> and <code>~/.cargo/bin/clippy-driver</code> should be hard or
soft links to <code>~/.cargo/bin/rustup</code>. You can repair these by running <code>rustup update</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-new-lint"><a class="header" href="#adding-a-new-lint">Adding a new lint</a></h1>
<p>You are probably here because you want to add a new lint to Clippy. If this is
the first time you're contributing to Clippy, this document guides you through
creating an example lint from scratch.</p>
<p>To get started, we will create a lint that detects functions called <code>foo</code>,
because that's clearly a non-descriptive name.</p>
<ul>
<li><a href="development/adding_lints.html#adding-a-new-lint">Adding a new lint</a>
<ul>
<li><a href="development/adding_lints.html#setup">Setup</a></li>
<li><a href="development/adding_lints.html#getting-started">Getting Started</a>
<ul>
<li><a href="development/adding_lints.html#defining-our-lint">Defining Our Lint</a>
<ul>
<li><a href="development/adding_lints.html#standalone">Standalone</a></li>
<li><a href="development/adding_lints.html#specific-type">Specific Type</a></li>
<li><a href="development/adding_lints.html#tests-location">Tests Location</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="development/adding_lints.html#testing">Testing</a>
<ul>
<li><a href="development/adding_lints.html#cargo-lints">Cargo lints</a></li>
</ul>
</li>
<li><a href="development/adding_lints.html#rustfix-tests">Rustfix tests</a></li>
<li><a href="development/adding_lints.html#testing-manually">Testing manually</a></li>
<li><a href="development/adding_lints.html#lint-declaration">Lint declaration</a></li>
<li><a href="development/adding_lints.html#lint-registration">Lint registration</a></li>
<li><a href="development/adding_lints.html#lint-passes">Lint passes</a></li>
<li><a href="development/adding_lints.html#emitting-a-lint">Emitting a lint</a></li>
<li><a href="development/adding_lints.html#adding-the-lint-logic">Adding the lint logic</a></li>
<li><a href="development/adding_lints.html#specifying-the-lints-minimum-supported-rust-version-msrv">Specifying the lint's minimum supported Rust version (MSRV)</a></li>
<li><a href="development/adding_lints.html#author-lint">Author lint</a></li>
<li><a href="development/adding_lints.html#print-hir-lint">Print HIR lint</a></li>
<li><a href="development/adding_lints.html#documentation">Documentation</a></li>
<li><a href="development/adding_lints.html#running-rustfmt">Running rustfmt</a></li>
<li><a href="development/adding_lints.html#debugging">Debugging</a></li>
<li><a href="development/adding_lints.html#pr-checklist">PR Checklist</a></li>
<li><a href="development/adding_lints.html#adding-configuration-to-a-lint">Adding configuration to a lint</a></li>
<li><a href="development/adding_lints.html#cheat-sheet">Cheat Sheet</a></li>
</ul>
</li>
</ul>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>See the <a href="development/basics.html#get-the-code">Basics</a> documentation.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>There is a bit of boilerplate code that needs to be set up when creating a new
lint. Fortunately, you can use the Clippy dev tools to handle this for you. We
are naming our new lint <code>foo_functions</code> (lints are generally written in snake
case), and we don't need type information, so it will have an early pass type
(more on this later). If you're unsure if the name you chose fits the lint,
take a look at our <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming guidelines</a>.</p>
<h2 id="defining-our-lint"><a class="header" href="#defining-our-lint">Defining Our Lint</a></h2>
<p>To get started, there are two ways to define our lint.</p>
<h3 id="standalone"><a class="header" href="#standalone">Standalone</a></h3>
<p>Command: <code>cargo dev new_lint --name=foo_functions --pass=early --category=pedantic</code>
(category will default to nursery if not provided)</p>
<p>This command will create a new file: <code>clippy_lints/src/foo_functions.rs</code>, as well
as <a href="development/adding_lints.html#lint-registration">register the lint</a>.</p>
<h3 id="specific-type"><a class="header" href="#specific-type">Specific Type</a></h3>
<p>Command: <code>cargo dev new_lint --name=foo_functions --type=functions --category=pedantic</code></p>
<p>This command will create a new file: <code>clippy_lints/src/{type}/foo_functions.rs</code>.</p>
<p>Notice how this command has a <code>--type</code> flag instead of <code>--pass</code>. Unlike a standalone
definition, this lint won't be registered in the traditional sense. Instead, you will
call your lint from within the type's lint pass, found in <code>clippy_lints/src/{type}/mod.rs</code>.</p>
<p>A &quot;type&quot; is just the name of a directory in <code>clippy_lints/src</code>, like <code>functions</code> in
the example command. These are groupings of lints with common behaviors, so if your
lint falls into one, it would be best to add it to that type.</p>
<h3 id="tests-location"><a class="header" href="#tests-location">Tests Location</a></h3>
<p>Both commands will create a file: <code>tests/ui/foo_functions.rs</code>. For cargo lints,
two project hierarchies (fail/pass) will be created by default under <code>tests/ui-cargo</code>.</p>
<p>Next, we'll open up these files and add our lint!</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Let's write some tests first that we can execute while we iterate on our lint.</p>
<p>Clippy uses UI tests for testing. UI tests check that the output of Clippy is
exactly as expected. Each test is just a plain Rust file that contains the code
we want to check. The output of Clippy is compared against a <code>.stderr</code> file.
Note that you don't have to create this file yourself, we'll get to generating
the <code>.stderr</code> files further down.</p>
<p>We start by opening the test file created at <code>tests/ui/foo_functions.rs</code>.</p>
<p>Update the file with some examples to get started:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![warn(clippy::foo_functions)]

// Impl methods
struct A;
impl A {
    pub fn fo(&amp;self) {}
    pub fn foo(&amp;self) {}
    pub fn food(&amp;self) {}
}

// Default trait methods
trait B {
    fn fo(&amp;self) {}
    fn foo(&amp;self) {}
    fn food(&amp;self) {}
}

// Plain functions
fn fo() {}
fn foo() {}
fn food() {}

fn main() {
    // We also don't want to lint method calls
    foo();
    let a = A;
    a.foo();
}
</code></pre></pre>
<p>Now we can run the test with <code>TESTNAME=foo_functions cargo uitest</code>, currently
this test is meaningless though.</p>
<p>While we are working on implementing our lint, we can keep running the UI test.
That allows us to check if the output is turning into what we want.</p>
<p>Once we are satisfied with the output, we need to run <code>cargo dev bless</code> to
update the <code>.stderr</code> file for our lint. Please note that, we should run
<code>TESTNAME=foo_functions cargo uitest</code> every time before running <code>cargo dev bless</code>. Running <code>TESTNAME=foo_functions cargo uitest</code> should pass then. When we
commit our lint, we need to commit the generated <code>.stderr</code> files, too. In
general, you should only commit files changed by <code>cargo dev bless</code> for the
specific lint you are creating/editing. Note that if the generated files are
empty, they should be removed.</p>
<blockquote>
<p><em>Note:</em> you can run multiple test files by specifying a comma separated list:
<code>TESTNAME=foo_functions,test2,test3</code>.</p>
</blockquote>
<h3 id="cargo-lints"><a class="header" href="#cargo-lints">Cargo lints</a></h3>
<p>For cargo lints, the process of testing differs in that we are interested in the
<code>Cargo.toml</code> manifest file. We also need a minimal crate associated with that
manifest.</p>
<p>If our new lint is named e.g. <code>foo_categories</code>, after running <code>cargo dev new_lint</code> we will find by default two new crates, each with its manifest file:</p>
<ul>
<li><code>tests/ui-cargo/foo_categories/fail/Cargo.toml</code>: this file should cause the
new lint to raise an error.</li>
<li><code>tests/ui-cargo/foo_categories/pass/Cargo.toml</code>: this file should not trigger
the lint.</li>
</ul>
<p>If you need more cases, you can copy one of those crates (under
<code>foo_categories</code>) and rename it.</p>
<p>The process of generating the <code>.stderr</code> file is the same, and prepending the
<code>TESTNAME</code> variable to <code>cargo uitest</code> works too.</p>
<h2 id="rustfix-tests"><a class="header" href="#rustfix-tests">Rustfix tests</a></h2>
<p>If the lint you are working on is making use of structured suggestions, the test
file should include a <code>// run-rustfix</code> comment at the top. This will
additionally run <a href="https://github.com/rust-lang/rustfix">rustfix</a> for that test. Rustfix will apply the suggestions
from the lint to the code of the test file and compare that to the contents of a
<code>.fixed</code> file.</p>
<p>Use <code>cargo dev bless</code> to automatically generate the <code>.fixed</code> file after running
the tests.</p>
<h2 id="testing-manually"><a class="header" href="#testing-manually">Testing manually</a></h2>
<p>Manually testing against an example file can be useful if you have added some
<code>println!</code>s and the test suite output becomes unreadable. To try Clippy with
your local modifications, run</p>
<pre><code>cargo dev lint input.rs
</code></pre>
<p>from the working copy root. With tests in place, let's have a look at
implementing our lint now.</p>
<h2 id="lint-declaration"><a class="header" href="#lint-declaration">Lint declaration</a></h2>
<p>Let's start by opening the new file created in the <code>clippy_lints</code> crate at
<code>clippy_lints/src/foo_functions.rs</code>. That's the crate where all the lint code
is. This file has already imported some initial things we will need:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_lint::{EarlyLintPass, EarlyContext};
use rustc_session::{declare_lint_pass, declare_tool_lint};
use rustc_ast::ast::*;
<span class="boring">}
</span></code></pre></pre>
<p>The next step is to update the lint declaration. Lints are declared using the
<a href="https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60"><code>declare_clippy_lint!</code></a> macro, and we just need to update
the auto-generated lint declaration to have a real description, something like
this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// ### What it does
    ///
    /// ### Why is this bad?
    ///
    /// ### Example
    /// ```rust
    /// // example code
    /// ```
    #[clippy::version = &quot;1.29.0&quot;]
    pub FOO_FUNCTIONS,
    pedantic,
    &quot;function named `foo`, which is not a descriptive name&quot;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The section of lines prefixed with <code>///</code> constitutes the lint documentation
section. This is the default documentation style and will be displayed <a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure">like
this</a>. To render and open this documentation locally in a
browser, run <code>cargo dev serve</code>.</li>
<li>The <code>#[clippy::version]</code> attribute will be rendered as part of the lint
documentation. The value should be set to the current Rust version that the
lint is developed in, it can be retrieved by running <code>rustc -vV</code> in the
rust-clippy directory. The version is listed under <em>release</em>. (Use the version
without the <code>-nightly</code>) suffix.</li>
<li><code>FOO_FUNCTIONS</code> is the name of our lint. Be sure to follow the <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming
guidelines</a> here when naming your lint. In short, the name should
state the thing that is being checked for and read well when used with
<code>allow</code>/<code>warn</code>/<code>deny</code>.</li>
<li><code>pedantic</code> sets the lint level to <code>Allow</code>. The exact mapping can be found
<a href="https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L110">here</a></li>
<li>The last part should be a text that explains what exactly is wrong with the
code</li>
</ul>
<p>The rest of this file contains an empty implementation for our lint pass, which
in this case is <code>EarlyLintPass</code> and should look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// clippy_lints/src/foo_functions.rs

// .. imports and lint declaration ..

declare_lint_pass!(FooFunctions =&gt; [FOO_FUNCTIONS]);

impl EarlyLintPass for FooFunctions {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="lint-registration"><a class="header" href="#lint-registration">Lint registration</a></h2>
<p>When using <code>cargo dev new_lint</code>, the lint is automatically registered and
nothing more has to be done.</p>
<p>When declaring a new lint by hand and <code>cargo dev update_lints</code> is used, the lint
pass may have to be registered manually in the <code>register_plugins</code> function in
<code>clippy_lints/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>store.register_early_pass(|| Box::new(foo_functions::FooFunctions));
<span class="boring">}
</span></code></pre></pre>
<p>As one may expect, there is a corresponding <code>register_late_pass</code> method
available as well. Without a call to one of <code>register_early_pass</code> or
<code>register_late_pass</code>, the lint pass in question will not be run.</p>
<p>One reason that <code>cargo dev update_lints</code> does not automate this step is that
multiple lints can use the same lint pass, so registering the lint pass may
already be done when adding a new lint. Another reason that this step is not
automated is that the order that the passes are registered determines the order
the passes actually run, which in turn affects the order that any emitted lints
are output in.</p>
<h2 id="lint-passes"><a class="header" href="#lint-passes">Lint passes</a></h2>
<p>Writing a lint that only checks for the name of a function means that we only
have to deal with the AST and don't have to deal with the type system at all.
This is good, because it makes writing this particular lint less complicated.</p>
<p>We have to make this decision with every new Clippy lint. It boils down to using
either <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a>.</p>
<p>In short, the <code>LateLintPass</code> has access to type information while the
<code>EarlyLintPass</code> doesn't. If you don't need access to type information, use the
<code>EarlyLintPass</code>. The <code>EarlyLintPass</code> is also faster. However linting speed
hasn't really been a concern with Clippy so far.</p>
<p>Since we don't need type information for checking the function name, we used
<code>--pass=early</code> when running the new lint automation and all the imports were
added accordingly.</p>
<h2 id="emitting-a-lint"><a class="header" href="#emitting-a-lint">Emitting a lint</a></h2>
<p>With UI tests and the lint declaration in place, we can start working on the
implementation of the lint logic.</p>
<p>Let's start by implementing the <code>EarlyLintPass</code> for our <code>FooFunctions</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        // TODO: Emit lint here
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We implement the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn"><code>check_fn</code></a> method from the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> trait. This gives us access to various
information about the function that is currently being checked. More on that in
the next section. Let's worry about the details later and emit our lint for
<em>every</em> function definition first.</p>
<p>Depending on how complex we want our lint message to be, we can choose from a
variety of lint emission functions. They can all be found in
<a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs"><code>clippy_utils/src/diagnostics.rs</code></a>.</p>
<p><code>span_lint_and_help</code> seems most appropriate in this case. It allows us to
provide an extra help message and we can't really suggest a better name
automatically. This is how it looks:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        span_lint_and_help(
            cx,
            FOO_FUNCTIONS,
            span,
            &quot;function named `foo`&quot;,
            None,
            &quot;consider using a more meaningful name&quot;
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running our UI test should now produce output that contains the lint message.</p>
<p>According to <a href="https://rustc-dev-guide.rust-lang.org/diagnostics.html">the rustc-dev-guide</a>, the text should be matter of fact and avoid
capitalization and periods, unless multiple sentences are needed. When code or
an identifier must appear in a message or label, it should be surrounded with
single grave accents `.</p>
<h2 id="adding-the-lint-logic"><a class="header" href="#adding-the-lint-logic">Adding the lint logic</a></h2>
<p>Writing the logic for your lint will most likely be different from our example,
so this section is kept rather short.</p>
<p>Using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn"><code>check_fn</code></a> method gives us access to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html"><code>FnKind</code></a>
that has the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn"><code>FnKind::Fn</code></a> variant. It provides access to the name of the
function/method via an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a>.</p>
<p>With that we can expand our <code>check_fn</code> method to:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        if is_foo_fn(fn_kind) {
            span_lint_and_help(
                cx,
                FOO_FUNCTIONS,
                span,
                &quot;function named `foo`&quot;,
                None,
                &quot;consider using a more meaningful name&quot;
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We separate the lint conditional from the lint emissions because it makes the
code a bit easier to read. In some cases this separation would also allow to
write some unit tests (as opposed to only UI tests) for the separate function.</p>
<p>In our example, <code>is_foo_fn</code> looks like:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// use statements, impl EarlyLintPass, check_fn, ..

fn is_foo_fn(fn_kind: FnKind&lt;'_&gt;) -&gt; bool {
    match fn_kind {
        FnKind::Fn(_, ident, ..) =&gt; {
            // check if `fn` name is `foo`
            ident.name.as_str() == &quot;foo&quot;
        }
        // ignore closures
        FnKind::Closure(..) =&gt; false
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we should also run the full test suite with <code>cargo test</code>. At this point
running <code>cargo test</code> should produce the expected output. Remember to run <code>cargo dev bless</code> to update the <code>.stderr</code> file.</p>
<p><code>cargo test</code> (as opposed to <code>cargo uitest</code>) will also ensure that our lint
implementation is not violating any Clippy lints itself.</p>
<p>That should be it for the lint implementation. Running <code>cargo test</code> should now
pass.</p>
<h2 id="specifying-the-lints-minimum-supported-rust-version-msrv"><a class="header" href="#specifying-the-lints-minimum-supported-rust-version-msrv">Specifying the lint's minimum supported Rust version (MSRV)</a></h2>
<p>Sometimes a lint makes suggestions that require a certain version of Rust. For
example, the <code>manual_strip</code> lint suggests using <code>str::strip_prefix</code> and
<code>str::strip_suffix</code> which is only available after Rust 1.45. In such cases, you
need to ensure that the MSRV configured for the project is &gt;= the MSRV of the
required Rust feature. If multiple features are required, just use the one with
a lower MSRV.</p>
<p>First, add an MSRV alias for the required feature in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/msrvs/index.html"><code>clippy_utils::msrvs</code></a>.
This can be accessed later as <code>msrvs::STR_STRIP_PREFIX</code>, for example.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>msrv_aliases! {
    ..
    1,45,0 { STR_STRIP_PREFIX }
}
<span class="boring">}
</span></code></pre></pre>
<p>In order to access the project-configured MSRV, you need to have an <code>msrv</code> field
in the LintPass struct, and a constructor to initialize the field. The <code>msrv</code>
value is passed to the constructor in <code>clippy_lints/lib.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ManualStrip {
    msrv: Option&lt;RustcVersion&gt;,
}

impl ManualStrip {
    #[must_use]
    pub fn new(msrv: Option&lt;RustcVersion&gt;) -&gt; Self {
        Self { msrv }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The project's MSRV can then be matched against the feature MSRV in the LintPass
using the <code>meets_msrv</code> utility function.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !meets_msrv(self.msrv, msrvs::STR_STRIP_PREFIX) {
    return;
}
<span class="boring">}
</span></code></pre></pre>
<p>The project's MSRV can also be specified as an inner attribute, which overrides
the value from <code>clippy.toml</code>. This can be accounted for using the
<code>extract_msrv_attr!(LintContext)</code> macro and passing
<code>LateContext</code>/<code>EarlyContext</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for ManualStrip {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx Expr&lt;'_&gt;) {
        ...
    }
    extract_msrv_attr!(LateContext);
}
<span class="boring">}
</span></code></pre></pre>
<p>Once the <code>msrv</code> is added to the lint, a relevant test case should be added to
<code>tests/ui/min_rust_version_attr.rs</code> which verifies that the lint isn't emitted
if the project's MSRV is lower.</p>
<p>As a last step, the lint should be added to the lint documentation. This is done
in <code>clippy_lints/src/utils/conf.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_Conf! {
    /// Lint: LIST, OF, LINTS, &lt;THE_NEWLY_ADDED_LINT&gt;. The minimum rust version that the project supports
    (msrv: Option&lt;String&gt; = None),
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="author-lint"><a class="header" href="#author-lint">Author lint</a></h2>
<p>If you have trouble implementing your lint, there is also the internal <code>author</code>
lint to generate Clippy code that detects the offending pattern. It does not
work for all of the Rust syntax, but can give a good starting point.</p>
<p>The quickest way to use it, is the <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=9a12cb60e5c6ad4e3003ac6d5e63cf55">Rust playground:
play.rust-lang.org</a>. Put the code you want to lint into the
editor and add the <code>#[clippy::author]</code> attribute above the item. Then run Clippy
via <code>Tools -&gt; Clippy</code> and you should see the generated code in the output below.</p>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=9a12cb60e5c6ad4e3003ac6d5e63cf55">Here</a> is an example on the playground.</p>
<p>If the command was executed successfully, you can copy the code over to where
you are implementing your lint.</p>
<h2 id="print-hir-lint"><a class="header" href="#print-hir-lint">Print HIR lint</a></h2>
<p>To implement a lint, it's helpful to first understand the internal
representation that rustc uses. Clippy has the <code>#[clippy::dump]</code> attribute that
prints the <a href="https://rustc-dev-guide.rust-lang.org/hir.html"><em>High-Level Intermediate Representation (HIR)</em></a> of the item,
statement, or expression that the attribute is attached to. To attach the
attribute to expressions you often need to enable
<code>#![feature(stmt_expr_attributes)]</code>.</p>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=daf14db3a7f39ca467cd1b86c34b9afb">Here</a> you can find an example, just select <em>Tools</em> and run
<em>Clippy</em>.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The final thing before submitting our PR is to add some documentation to our
lint declaration.</p>
<p>Please document your lint with a doc comment akin to the following:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// ### What it does
    /// Checks for ... (describe what the lint matches).
    ///
    /// ### Why is this bad?
    /// Supply the reason for linting the code.
    ///
    /// ### Example
    ///
    /// ```rust,ignore
    /// // A short example of code that triggers the lint
    /// ```
    ///
    /// Use instead:
    /// ```rust,ignore
    /// // A short example of improved code that doesn't trigger the lint
    /// ```
    #[clippy::version = &quot;1.29.0&quot;]
    pub FOO_FUNCTIONS,
    pedantic,
    &quot;function named `foo`, which is not a descriptive name&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>Once your lint is merged, this documentation will show up in the <a href="https://rust-lang.github.io/rust-clippy/master/index.html">lint
list</a>.</p>
<h2 id="running-rustfmt"><a class="header" href="#running-rustfmt">Running rustfmt</a></h2>
<p><a href="https://github.com/rust-lang/rustfmt">Rustfmt</a> is a tool for formatting Rust code according to style guidelines. Your
code has to be formatted by <code>rustfmt</code> before a PR can be merged. Clippy uses
nightly <code>rustfmt</code> in the CI.</p>
<p>It can be installed via <code>rustup</code>:</p>
<pre><code class="language-bash">rustup component add rustfmt --toolchain=nightly
</code></pre>
<p>Use <code>cargo dev fmt</code> to format the whole codebase. Make sure that <code>rustfmt</code> is
installed for the nightly toolchain.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>If you want to debug parts of your lint implementation, you can use the <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a>
macro anywhere in your code. Running the tests should then include the debug
output in the <code>stdout</code> part.</p>
<h2 id="pr-checklist"><a class="header" href="#pr-checklist">PR Checklist</a></h2>
<p>Before submitting your PR make sure you followed all of the basic requirements:</p>
<!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->
<ul>
<li>[ ] Followed <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming conventions</a></li>
<li>[ ] Added passing UI tests (including committed <code>.stderr</code> file)</li>
<li>[ ] <code>cargo test</code> passes locally</li>
<li>[ ] Executed <code>cargo dev update_lints</code></li>
<li>[ ] Added lint documentation</li>
<li>[ ] Run <code>cargo dev fmt</code></li>
</ul>
<h2 id="adding-configuration-to-a-lint"><a class="header" href="#adding-configuration-to-a-lint">Adding configuration to a lint</a></h2>
<p>Clippy supports the configuration of lints values using a <code>clippy.toml</code> file in
the workspace directory. Adding a configuration to a lint can be useful for
thresholds or to constrain some behavior that can be seen as a false positive
for some users. Adding a configuration is done in the following steps:</p>
<ol>
<li>
<p>Adding a new configuration entry to <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/conf.rs"><code>clippy_lints::utils::conf</code></a> like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Lint: LINT_NAME.
///
/// &lt;The configuration field doc comment&gt;
(configuration_ident: Type = DefaultValue),
<span class="boring">}
</span></code></pre></pre>
<p>The doc comment is automatically added to the documentation of the listed
lints. The default value will be formatted using the <code>Debug</code> implementation
of the type.</p>
</li>
<li>
<p>Adding the configuration value to the lint impl struct:</p>
<ol>
<li>
<p>This first requires the definition of a lint impl struct. Lint impl
structs are usually generated with the <code>declare_lint_pass!</code> macro. This
struct needs to be defined manually to add some kind of metadata to it:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generated struct definition
declare_lint_pass!(StructName =&gt; [
    LINT_NAME
]);

// New manual definition struct
#[derive(Copy, Clone)]
pub struct StructName {}

impl_lint_pass!(StructName =&gt; [
    LINT_NAME
]);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Next add the configuration value and a corresponding creation method like
this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
pub struct StructName {
    configuration_ident: Type,
}

// ...

impl StructName {
    pub fn new(configuration_ident: Type) -&gt; Self {
        Self {
            configuration_ident,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
</li>
<li>
<p>Passing the configuration value to the lint impl struct:</p>
<p>First find the struct construction in the <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs"><code>clippy_lints</code> lib file</a>. The
configuration value is now cloned or copied into a local value that is then
passed to the impl struct like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default generated registration:
store.register_*_pass(|| box module::StructName);

// New registration with configuration value
let configuration_ident = conf.configuration_ident.clone();
store.register_*_pass(move || box module::StructName::new(configuration_ident));
<span class="boring">}
</span></code></pre></pre>
<p>Congratulations the work is almost done. The configuration value can now be
accessed in the linting code via <code>self.configuration_ident</code>.</p>
</li>
<li>
<p>Adding tests:</p>
<ol>
<li>The default configured value can be tested like any normal lint in
<a href="https://github.com/rust-lang/rust-clippy/blob/master/tests/ui"><code>tests/ui</code></a>.</li>
<li>The configuration itself will be tested separately in <a href="https://github.com/rust-lang/rust-clippy/blob/master/tests/ui-toml"><code>tests/ui-toml</code></a>.
Simply add a new subfolder with a fitting name. This folder contains a
<code>clippy.toml</code> file with the configuration value and a rust file that
should be linted by Clippy. The test can otherwise be written as usual.</li>
</ol>
</li>
</ol>
<h2 id="cheat-sheet"><a class="header" href="#cheat-sheet">Cheat Sheet</a></h2>
<p>Here are some pointers to things you are likely going to need for every lint:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/index.html">Clippy utils</a> - Various helper functions. Maybe the function you need
is already in here (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.is_type_diagnostic_item.html"><code>is_type_diagnostic_item</code></a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.implements_trait.html"><code>implements_trait</code></a>,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/source/fn.snippet.html"><code>snippet</code></a>, etc)</li>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs">Clippy diagnostics</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/94927">Let chains</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> and
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html"><code>in_external_macro</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html"><code>Applicability</code></a></li>
<li><a href="development/common_tools_writing_lints.html">Common tools for writing lints</a> helps with
common operations</li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">The rustc-dev-guide</a> explains a lot of internal compiler
concepts</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/">The nightly rustc docs</a> which has been linked to throughout
this guide</li>
</ul>
<p>For <code>EarlyLintPass</code> lints:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html"><code>rustc_ast::ast</code></a></li>
</ul>
<p>For <code>LateLintPass</code> lints:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/index.html"><code>Ty::TyKind</code></a></li>
</ul>
<p>While most of Clippy's lint utils are documented, most of rustc's internals lack
documentation currently. This is unfortunate, but in most cases you can probably
get away with copying things from existing similar lints. If you are stuck,
don't hesitate to ask on <a href="https://rust-lang.zulipchat.com/#narrow/stream/clippy">Zulip</a> or in the issue/PR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-tools-for-writing-lints"><a class="header" href="#common-tools-for-writing-lints">Common tools for writing lints</a></h1>
<p>You may need following tooltips to catch up with common operations.</p>
<ul>
<li><a href="development/common_tools_writing_lints.html#common-tools-for-writing-lints">Common tools for writing lints</a>
<ul>
<li><a href="development/common_tools_writing_lints.html#retrieving-the-type-of-an-expression">Retrieving the type of an expression</a></li>
<li><a href="development/common_tools_writing_lints.html#checking-if-an-expr-is-calling-a-specific-method">Checking if an expr is calling a specific method</a></li>
<li><a href="development/common_tools_writing_lints.html#checking-for-a-specific-type">Checking for a specific type</a></li>
<li><a href="development/common_tools_writing_lints.html#checking-if-a-type-implements-a-specific-trait">Checking if a type implements a specific trait</a></li>
<li><a href="development/common_tools_writing_lints.html#checking-if-a-type-defines-a-specific-method">Checking if a type defines a specific method</a></li>
<li><a href="development/common_tools_writing_lints.html#dealing-with-macros-and-expansions">Dealing with macros</a></li>
</ul>
</li>
</ul>
<p>Useful Rustc dev guide links:</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation">Stages of compilation</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html">Diagnostic items</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/type-checking.html">Type checking</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/ty.html">Ty module</a></li>
</ul>
<h2 id="retrieving-the-type-of-an-expression"><a class="header" href="#retrieving-the-type-of-an-expression">Retrieving the type of an expression</a></h2>
<p>Sometimes you may want to retrieve the type <code>Ty</code> of an expression <code>Expr</code>, for
example to answer following questions:</p>
<ul>
<li>which type does this expression correspond to (using its <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html"><code>TyKind</code></a>)?</li>
<li>is it a sized type?</li>
<li>is it a primitive type?</li>
<li>does it implement a trait?</li>
</ul>
<p>This operation is performed using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"><code>expr_ty()</code></a> method from the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> struct, that gives you access to the underlying
structure <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html"><code>Ty</code></a>.</p>
<p>Example of use:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Get type of `expr`
        let ty = cx.typeck_results().expr_ty(expr);
        // Match its kind to enter its type
        match ty.kind {
            ty::Adt(adt_def, _) if adt_def.is_struct() =&gt; println!(&quot;Our `expr` is a struct!&quot;),
            _ =&gt; ()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Similarly in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> methods, you have the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty"><code>pat_ty()</code></a> method to retrieve a type from a pattern.</p>
<p>Two noticeable items here:</p>
<ul>
<li><code>cx</code> is the lint context <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html"><code>LateContext</code></a>. The two most useful
data structures in this context are <code>tcx</code> and the <code>TypeckResults</code> returned by
<code>LateContext::typeck_results</code>, allowing us to jump to type definitions and
other compilation stages such as HIR.</li>
<li><code>typeck_results</code>'s return value is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> and is
created by type checking step, it includes useful information such as types of
expressions, ways to resolve methods and so on.</li>
</ul>
<h2 id="checking-if-an-expr-is-calling-a-specific-method"><a class="header" href="#checking-if-an-expr-is-calling-a-specific-method">Checking if an expr is calling a specific method</a></h2>
<p>Starting with an <code>expr</code>, you can check whether it is calling a specific method
<code>some_method</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx hir::Expr&lt;'_&gt;) {
        // Check our expr is calling a method
        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &amp;expr.kind
            // Check the name of this method is `some_method`
            &amp;&amp; path.ident.name == sym!(some_method)
            // Optionally, check the type of the self argument.
            // - See &quot;Checking for a specific type&quot;
        {
                // ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="checking-for-a-specific-type"><a class="header" href="#checking-for-a-specific-type">Checking for a specific type</a></h2>
<p>There are three ways to check if an expression type is a specific type we want
to check for. All of these methods only check for the base type, generic
arguments have to be checked separately.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};
use clippy_utils::{paths, match_def_path};
use rustc_span::symbol::sym;
use rustc_hir::LangItem;

impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Getting the expression type
        let ty = cx.typeck_results().expr_ty(expr);

        // 1. Using diagnostic items
        // The last argument is the diagnostic item to check for
        if is_type_diagnostic_item(cx, ty, sym::Option) {
            // The type is an `Option`
        }

        // 2. Using lang items
        if is_type_lang_item(cx, ty, LangItem::RangeFull) {
            // The type is a full range like `.drain(..)`
        }

        // 3. Using the type path
        // This method should be avoided if possible
        if match_def_path(cx, def_id, &amp;paths::RESULT) {
            // The type is a `core::result::Result`
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Prefer using diagnostic items and lang items where possible.</p>
<h2 id="checking-if-a-type-implements-a-specific-trait"><a class="header" href="#checking-if-a-type-implements-a-specific-trait">Checking if a type implements a specific trait</a></h2>
<p>There are three ways to do this, depending on if the target trait has a
diagnostic item, lang item or neither.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::{implements_trait, is_trait_method, match_trait_method, paths};
use rustc_span::symbol::sym;

impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // 1. Using diagnostic items with the expression
        // we use `is_trait_method` function from Clippy's utils
        if is_trait_method(cx, expr, sym::Iterator) {
            // method call in `expr` belongs to `Iterator` trait
        }

        // 2. Using lang items with the expression type
        let ty = cx.typeck_results().expr_ty(expr);
        if cx.tcx.lang_items()
            // we are looking for the `DefId` of `Drop` trait in lang items
            .drop_trait()
            // then we use it with our type `ty` by calling `implements_trait` from Clippy's utils
            .map_or(false, |id| implements_trait(cx, ty, id, &amp;[])) {
                // `expr` implements `Drop` trait
            }

        // 3. Using the type path with the expression
        // we use `match_trait_method` function from Clippy's utils
        // (This method should be avoided if possible)
        if match_trait_method(cx, expr, &amp;paths::INTO) {
            // `expr` implements `Into` trait
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Prefer using diagnostic and lang items, if the target trait has one.</p>
</blockquote>
<p>We access lang items through the type context <code>tcx</code>. <code>tcx</code> is of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html"><code>TyCtxt</code></a> and is defined in the <code>rustc_middle</code> crate. A list of defined
paths for Clippy can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/paths/index.html">paths.rs</a></p>
<h2 id="checking-if-a-type-defines-a-specific-method"><a class="header" href="#checking-if-a-type-defines-a-specific-method">Checking if a type defines a specific method</a></h2>
<p>To check if our type defines a method called <code>some_method</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::ty::is_type_diagnostic_item;
use clippy_utils::return_ty;

impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for MyTypeImpl {
    fn check_impl_item(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, impl_item: &amp;'tcx ImplItem&lt;'_&gt;) {
        // Check if item is a method/function
        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind
            // Check the method is named `some_method`
            &amp;&amp; impl_item.ident.name == sym!(some_method)
            // We can also check it has a parameter `self`
            &amp;&amp; signature.decl.implicit_self.has_implicit_self()
            // We can go further and even check if its return type is `String`
            &amp;&amp; is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type))
        {
            // ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="dealing-with-macros-and-expansions"><a class="header" href="#dealing-with-macros-and-expansions">Dealing with macros and expansions</a></h2>
<p>Keep in mind that macros are already expanded and desugaring is already applied
to the code representation that you are working with in Clippy. This
unfortunately causes a lot of false positives because macro expansions are
&quot;invisible&quot; unless you actively check for them. Generally speaking, code with
macro expansions should just be ignored by Clippy because that code can be
dynamic in ways that are difficult or impossible to see. Use the following
functions to deal with macros:</p>
<ul>
<li>
<p><code>span.from_expansion()</code>: detects if a span is from macro expansion or
desugaring. Checking this is a common first step in a lint.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if expr.span.from_expansion() {
    // just forget it
    return;
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>span.ctxt()</code>: the span's context represents whether it is from expansion, and
if so, which macro call expanded it. It is sometimes useful to check if the
context of two spans are equal.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// expands to `1 + 0`, but don't lint
1 + mac!()
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if left.span.ctxt() != right.span.ctxt() {
    // the coder most likely cannot modify this expression
    return;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Code that is not from expansion is in the &quot;root&quot; context. So any spans
where <code>from_expansion</code> returns <code>true</code> can be assumed to have the same
context. And so just using <code>span.from_expansion()</code> is often good enough.</p>
</blockquote>
</li>
<li>
<p><code>in_external_macro(span)</code>: detect if the given span is from a macro defined in
a foreign crate. If you want the lint to work with macro-generated code, this
is the next line of defense to avoid macros not defined in the current crate.
It doesn't make sense to lint code that the coder can't change.</p>
<p>You may want to use it for example to not start linting in macros from other
crates</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate a_crate_with_macros;

// `foo` is defined in `a_crate_with_macros`
foo!(&quot;bar&quot;);

// if we lint the `match` of `foo` call and test its span
assert_eq!(in_external_macro(cx.sess(), match_span), true);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>span.ctxt()</code>: the span's context represents whether it is from expansion, and
if so, what expanded it</p>
<p>One thing <code>SpanContext</code> is useful for is to check if two spans are in the same
context. For example, in <code>a == b</code>, <code>a</code> and <code>b</code> have the same context. In a
<code>macro_rules!</code> with <code>a == $b</code>, <code>$b</code> is expanded to some expression with a
different context from <code>a</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($a:expr, $b:expr) =&gt; {
        if $a.is_some() {
            $b;
        }
    }
}

let x: Option&lt;u32&gt; = Some(42);
m!(x, x.unwrap());

// These spans are not from the same context
// x.is_some() is from inside the macro
// x.unwrap() is from outside the macro
assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<p>In order to deploy Clippy over <code>rustup</code>, some infrastructure is necessary. This
chapter describes the different parts of the Clippy infrastructure that need to
be maintained to make this possible.</p>
<p>The most important part is the sync between the <code>rust-lang/rust</code> repository and
the Clippy repository that takes place every two weeks. This process is
described in the <a href="development/infrastructure/sync.html">Syncing changes between Clippy and <code>rust-lang/rust</code></a>
section.</p>
<p>A new Clippy release is done together with every Rust release, so every six
weeks. The release process is described in the <a href="development/infrastructure/release.html">Release a new Clippy
Version</a> section. During a release cycle a changelog entry for the
next release has to be written. The format of that and how to do that is
documented in the <a href="development/infrastructure/changelog_update.html">Changelog Update</a> section.</p>
<blockquote>
<p><em>Note:</em> The Clippy CI should also be described in this chapter, but for now is
left as a TODO.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syncing-changes-between-clippy-and-rust-langrust"><a class="header" href="#syncing-changes-between-clippy-and-rust-langrust">Syncing changes between Clippy and <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></a></h1>
<p>Clippy currently gets built with a pinned nightly version.</p>
<p>In the <code>rust-lang/rust</code> repository, where rustc resides, there's a copy of
Clippy that compiler hackers modify from time to time to adapt to changes in the
unstable API of the compiler.</p>
<p>We need to sync these changes back to this repository periodically, and the
changes made to this repository in the meantime also need to be synced to the
<code>rust-lang/rust</code> repository.</p>
<p>To avoid flooding the <code>rust-lang/rust</code> PR queue, this two-way sync process is
done in a bi-weekly basis if there's no urgent changes. This is done starting on
the day of the Rust stable release and then every other week. That way we
guarantee that we keep this repo up to date with the latest compiler API, and
every feature in Clippy is available for 2 weeks in nightly, before it can get
to beta. For reference, the first sync following this cadence was performed the
2020-08-27.</p>
<p>This process is described in detail in the following sections. For general
information about <code>subtree</code>s in the Rust repository see <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree">Rust's
<code>CONTRIBUTING.md</code></a>.</p>
<h2 id="patching-git-subtree-to-work-with-big-repos"><a class="header" href="#patching-git-subtree-to-work-with-big-repos">Patching git-subtree to work with big repos</a></h2>
<p>Currently, there's a bug in <code>git-subtree</code> that prevents it from working properly
with the <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> repo. There's an open PR to fix that, but it's
stale. Before continuing with the following steps, we need to manually apply
that fix to our local copy of <code>git-subtree</code>.</p>
<p>You can get the patched version of <code>git-subtree</code> from <a href="https://github.com/gitgitgadget/git/pull/493">here</a>.
Put this file under <code>/usr/lib/git-core</code> (making a backup of the previous file)
and make sure it has the proper permissions:</p>
<pre><code class="language-bash">sudo cp --backup /path/to/patched/git-subtree.sh /usr/lib/git-core/git-subtree
sudo chmod --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree
sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree
</code></pre>
<blockquote>
<p><em>Note:</em> The first time running <code>git subtree push</code> a cache has to be built.
This involves going through the complete Clippy history once. For this you
have to increase the stack limit though, which you can do with <code>ulimit -s 60000</code>. Make sure to run the <code>ulimit</code> command from the same session you call
git subtree.</p>
</blockquote>
<blockquote>
<p><em>Note:</em> If you are a Debian user, <code>dash</code> is the shell used by default for
scripts instead of <code>sh</code>. This shell has a hardcoded recursion limit set to
1000. In order to make this process work, you need to force the script to run
<code>bash</code> instead. You can do this by editing the first line of the <code>git-subtree</code>
script and changing <code>sh</code> to <code>bash</code>.</p>
</blockquote>
<h2 id="defining-remotes"><a class="header" href="#defining-remotes">Defining remotes</a></h2>
<p>You may want to define remotes, so you don't have to type out the remote
addresses on every sync. You can do this with the following commands (these
commands still have to be run inside the <code>rust</code> directory):</p>
<pre><code class="language-bash"># Set clippy-upstream remote for pulls
$ git remote add clippy-upstream https://github.com/rust-lang/rust-clippy
# Make sure to not push to the upstream repo
$ git remote set-url --push clippy-upstream DISABLED
# Set a local remote
$ git remote add clippy-local /path/to/rust-clippy
</code></pre>
<blockquote>
<p>Note: The following sections assume that you have set those remotes with the
above remote names.</p>
</blockquote>
<h2 id="performing-the-sync-from-rust-langrust-to-clippy"><a class="header" href="#performing-the-sync-from-rust-langrust-to-clippy">Performing the sync from <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> to Clippy</a></h2>
<p>Here is a TL;DR version of the sync process (all of the following commands have
to be run inside the <code>rust</code> directory):</p>
<ol>
<li>
<p>Clone the <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> repository or make sure it is up to date.</p>
</li>
<li>
<p>Checkout the commit from the latest available nightly. You can get it using
<code>rustup check</code>.</p>
</li>
<li>
<p>Sync the changes to the rust-copy of Clippy to your Clippy fork:</p>
<pre><code class="language-bash"># Make sure to change `your-github-name` to your github name in the following command. Also be
# sure to either use a net-new branch, e.g. `sync-from-rust`, or delete the branch beforehand
# because changes cannot be fast forwarded and you have to run this command again.
git subtree push -P src/tools/clippy clippy-local sync-from-rust
</code></pre>
<blockquote>
<p><em>Note:</em> Most of the time you have to create a merge commit in the
<code>rust-clippy</code> repo (this has to be done in the Clippy repo, not in the
rust-copy of Clippy):</p>
</blockquote>
<pre><code class="language-bash">git fetch upstream  # assuming upstream is the rust-lang/rust remote
git checkout sync-from-rust
git merge upstream/master --no-ff
</code></pre>
<blockquote>
<p>Note: This is one of the few instances where a merge commit is allowed in
a PR.</p>
</blockquote>
</li>
<li>
<p>Bump the nightly version in the Clippy repository by changing the date in the
rust-toolchain file to the current date and committing it with the message:</p>
<pre><code class="language-bash">git commit -m &quot;Bump nightly version -&gt; YYYY-MM-DD&quot;
</code></pre>
</li>
<li>
<p>Open a PR to <code>rust-lang/rust-clippy</code> and wait for it to get merged (to
accelerate the process ping the <code>@rust-lang/clippy</code> team in your PR and/or
ask them in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/clippy">Zulip</a> stream.)</p>
</li>
</ol>
<h2 id="performing-the-sync-from-clippy-to-rust-langrust"><a class="header" href="#performing-the-sync-from-clippy-to-rust-langrust">Performing the sync from Clippy to <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></a></h2>
<p>All of the following commands have to be run inside the <code>rust</code> directory.</p>
<ol>
<li>Make sure you have checked out the latest <code>master</code> of <code>rust-lang/rust</code>.</li>
<li>Sync the <code>rust-lang/rust-clippy</code> master to the rust-copy of Clippy:
<pre><code class="language-bash">git checkout -b sync-from-clippy
git subtree pull -P src/tools/clippy clippy-upstream master
</code></pre>
</li>
<li>Open a PR to <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backport-changes"><a class="header" href="#backport-changes">Backport Changes</a></h1>
<p>Sometimes it is necessary to backport changes to the beta release of Clippy.
Backports in Clippy are rare and should be approved by the Clippy team. For
example, a backport is done, if a crucial ICE was fixed or a lint is broken to a
point, that it has to be disabled, before landing on stable.</p>
<p>Backports are done to the <code>beta</code> branch of Clippy. Backports to stable Clippy
releases basically don't exist, since this would require a Rust point release,
which is almost never justifiable for a Clippy fix.</p>
<h2 id="backport-the-changes"><a class="header" href="#backport-the-changes">Backport the changes</a></h2>
<p>Backports are done on the beta branch of the Clippy repository.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Clippy repository
$ git checkout beta
$ git checkout -b backport
$ git cherry-pick &lt;SHA&gt;  # `&lt;SHA&gt;` is the commit hash of the commit(s), that should be backported
$ git push origin backport
</code></pre>
<p>Now you should test that the backport passes all the tests in the Rust
repository. You can do this with:</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Rust repository
$ git checkout beta
$ git subtree pull -p src/tools/clippy https://github.com/&lt;your-github-name&gt;/rust-clippy backport
$ ./x.py test src/tools/clippy
</code></pre>
<p>Should the test fail, you can fix Clippy directly in the Rust repository. This
has to be first applied to the Clippy beta branch and then again synced to the
Rust repository, though. The easiest way to do this is:</p>
<pre><code class="language-bash"># In the Rust repository
$ git diff --patch --relative=src/tools/clippy &gt; clippy.patch
# In the Clippy repository
$ git apply /path/to/clippy.patch
$ git add -u
$ git commit -m &quot;Fix rustup fallout&quot;
$ git push origin backport
</code></pre>
<p>After this, you can open a PR to the <code>beta</code> branch of the Clippy repository.</p>
<h2 id="update-clippy-in-the-rust-repository"><a class="header" href="#update-clippy-in-the-rust-repository">Update Clippy in the Rust Repository</a></h2>
<p>This step must be done, <strong>after</strong> the PR of the previous step was merged.</p>
<p>After the backport landed in the Clippy repository, the branch has to be synced
back to the beta branch of the Rust repository.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Rust repository
$ git checkout beta
$ git checkout -b clippy_backport
$ git subtree pull -p src/tools/clippy https://github.com/rust-lang/rust-clippy beta
$ git push origin clippy_backport
</code></pre>
<p>Make sure to test the backport in the Rust repository before opening a PR. This
is done with <code>./x.py test src/tools/clippy</code>. If that passes all tests, open a PR
to the <code>beta</code> branch of the Rust repository. In this PR you should tag the
Clippy team member, that agreed to the backport or the <code>@rust-lang/clippy</code> team.
Make sure to add <code>[beta]</code> to the title of the PR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog-update"><a class="header" href="#changelog-update">Changelog Update</a></h1>
<p>If you want to help with updating the <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md">changelog</a>, you're in the right place.</p>
<h2 id="when-to-update"><a class="header" href="#when-to-update">When to update</a></h2>
<p>Typos and other small fixes/additions are <em>always</em> welcome.</p>
<p>Special care needs to be taken when it comes to updating the changelog for a new
Rust release. For that purpose, the changelog is ideally updated during the week
before an upcoming stable release. You can find the release dates on the <a href="https://forge.rust-lang.org/">Rust
Forge</a>.</p>
<p>Most of the time we only need to update the changelog for minor Rust releases.
It's been very rare that Clippy changes were included in a patch release.</p>
<h2 id="changelog-update-walkthrough"><a class="header" href="#changelog-update-walkthrough">Changelog update walkthrough</a></h2>
<h3 id="1-finding-the-relevant-clippy-commits"><a class="header" href="#1-finding-the-relevant-clippy-commits">1. Finding the relevant Clippy commits</a></h3>
<p>Each Rust release ships with its own version of Clippy. The Clippy subtree can
be found in the <code>tools</code> directory of the Rust repository.</p>
<p>Depending on the current time and what exactly you want to update, the following
bullet points might be helpful:</p>
<ul>
<li>When writing the release notes for the <strong>upcoming stable release</strong> you need to
check out the Clippy commit of the current Rust <code>beta</code> branch.
<a href="https://github.com/rust-lang/rust/tree/beta/src/tools/clippy">Link</a></li>
<li>When writing the release notes for the <strong>upcoming beta release</strong>, you need to
check out the Clippy commit of the current Rust <code>master</code>.
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/clippy">Link</a></li>
<li>When writing the (forgotten) release notes for a <strong>past stable release</strong>, you
need to check out the Rust release tag of the stable release.
<a href="https://github.com/rust-lang/rust/releases">Link</a></li>
</ul>
<p>Usually you want to write the changelog of the <strong>upcoming stable release</strong>. Make
sure though, that <code>beta</code> was already branched in the Rust repository.</p>
<p>To find the commit hash, issue the following command when in a <code>rust-lang/rust</code>
checkout:</p>
<pre><code>git log --oneline -- src/tools/clippy/ | grep -o &quot;Merge commit '[a-f0-9]*' into .*&quot; | head -1 | sed -e &quot;s/Merge commit '\([a-f0-9]*\)' into .*/\1/g&quot;
</code></pre>
<h3 id="2-fetching-the-prs-between-those-commits"><a class="header" href="#2-fetching-the-prs-between-those-commits">2. Fetching the PRs between those commits</a></h3>
<p>Once you've got the correct commit range, run</p>
<pre><code>util/fetch_prs_between.sh commit1 commit2 &gt; changes.txt
</code></pre>
<p>and open that file in your editor of choice.</p>
<p>When updating the changelog it's also a good idea to make sure that <code>commit1</code> is
already correct in the current changelog.</p>
<h3 id="3-authoring-the-final-changelog"><a class="header" href="#3-authoring-the-final-changelog">3. Authoring the final changelog</a></h3>
<p>The above script should have dumped all the relevant PRs to the file you
specified. It should have filtered out most of the irrelevant PRs already, but
it's a good idea to do a manual cleanup pass where you look for more irrelevant
PRs. If you're not sure about some PRs, just leave them in for the review and
ask for feedback.</p>
<p>With the PRs filtered, you can start to take each PR and move the <code>changelog: </code>
content to <code>CHANGELOG.md</code>. Adapt the wording as you see fit but try to keep it
somewhat coherent.</p>
<p>The order should roughly be:</p>
<ol>
<li>New lints</li>
<li>Moves or deprecations of lints</li>
<li>Changes that expand what code existing lints cover</li>
<li>False positive fixes</li>
<li>Suggestion fixes/improvements</li>
<li>ICE fixes</li>
<li>Documentation improvements</li>
<li>Others</li>
</ol>
<p>As section headers, we use:</p>
<pre><code>### New Lints
### Moves and Deprecations
### Enhancements
### False Positive Fixes
### Suggestion Fixes/Improvements
### ICE Fixes
### Documentation Improvements
### Others
</code></pre>
<p>Please also be sure to update the Beta/Unreleased sections at the top with the
relevant commit ranges.</p>
<p>If you have the time, it would be appreciated if you double-check, that the
<code>#[clippy::version]</code> attributes for the added lints contains the correct version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-a-new-clippy-version"><a class="header" href="#release-a-new-clippy-version">Release a new Clippy Version</a></h1>
<blockquote>
<p><em>NOTE:</em> This document is probably only relevant to you, if you're a member of
the Clippy team.</p>
</blockquote>
<p>Clippy is released together with stable Rust releases. The dates for these
releases can be found at the <a href="https://forge.rust-lang.org/">Rust Forge</a>. This document explains the necessary
steps to create a Clippy release.</p>
<ol>
<li><a href="development/infrastructure/release.html#remerge-the-beta-branch">Remerge the <code>beta</code> branch</a></li>
<li><a href="development/infrastructure/release.html#update-the-beta-branch">Update the <code>beta</code> branch</a></li>
<li><a href="development/infrastructure/release.html#find-the-clippy-commit">Find the Clippy commit</a></li>
<li><a href="development/infrastructure/release.html#tag-the-stable-commit">Tag the stable commit</a></li>
<li><a href="development/infrastructure/release.html#update-changelogmd">Update <code>CHANGELOG.md</code></a></li>
</ol>
<blockquote>
<p><em>NOTE:</em> This document is for stable Rust releases, not for point releases. For
point releases, step 1. and 2. should be enough.</p>
</blockquote>
<h2 id="remerge-the-beta-branch"><a class="header" href="#remerge-the-beta-branch">Remerge the <code>beta</code> branch</a></h2>
<p>This step is only necessary, if since the last release something was backported
to the beta Rust release. The remerge is then necessary, to make sure that the
Clippy commit, that was used by the now stable Rust release, persists in the
tree of the Clippy repository.</p>
<p>To find out if this step is necessary run</p>
<pre><code class="language-bash"># Assumes that the local master branch of rust-lang/rust-clippy is up-to-date
$ git fetch upstream
$ git branch master --contains upstream/beta
</code></pre>
<p>If this command outputs <code>master</code>, this step is <strong>not</strong> necessary.</p>
<pre><code class="language-bash"># Assuming `HEAD` is the current `master` branch of rust-lang/rust-clippy
$ git checkout -b backport_remerge
$ git merge upstream/beta
$ git diff  # This diff has to be empty, otherwise something with the remerge failed
$ git push origin backport_remerge  # This can be pushed to your fork
</code></pre>
<p>After this, open a PR to the master branch. In this PR, the commit hash of the
<code>HEAD</code> of the <code>beta</code> branch must exists. In addition to that, no files should be
changed by this PR.</p>
<h2 id="update-the-beta-branch"><a class="header" href="#update-the-beta-branch">Update the <code>beta</code> branch</a></h2>
<p>This step must be done <strong>after</strong> the PR of the previous step was merged.</p>
<p>First, the Clippy commit of the <code>beta</code> branch of the Rust repository has to be
determined.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Rust repository
$ git fetch upstream
$ git checkout upstream/beta
$ BETA_SHA=$(git log --oneline -- src/tools/clippy/ | grep -o &quot;Merge commit '[a-f0-9]*' into .*&quot; | head -1 | sed -e &quot;s/Merge commit '\([a-f0-9]*\)' into .*/\1/g&quot;)
</code></pre>
<p>After finding the Clippy commit, the <code>beta</code> branch in the Clippy repository can
be updated.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Clippy repository
$ git checkout beta
$ git reset --hard $BETA_SHA
$ git push upstream beta
</code></pre>
<h2 id="find-the-clippy-commit"><a class="header" href="#find-the-clippy-commit">Find the Clippy commit</a></h2>
<p>The first step is to tag the Clippy commit, that is included in the stable Rust
release. This commit can be found in the Rust repository.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Rust repository
$ git fetch upstream    # `upstream` is the `rust-lang/rust` remote
$ git checkout 1.XX.0   # XX should be exchanged with the corresponding version
$ SHA=$(git log --oneline -- src/tools/clippy/ | grep -o &quot;Merge commit '[a-f0-9]*' into .*&quot; | head -1 | sed -e &quot;s/Merge commit '\([a-f0-9]*\)' into .*/\1/g&quot;)
</code></pre>
<h2 id="tag-the-stable-commit"><a class="header" href="#tag-the-stable-commit">Tag the stable commit</a></h2>
<p>After finding the Clippy commit, it can be tagged with the release number.</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Clippy repository
$ git checkout $SHA
$ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version
$ git push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote
</code></pre>
<p>After this, the release should be available on the Clippy <a href="https://github.com/rust-lang/rust-clippy/releases">release page</a>.</p>
<h2 id="update-the-stable-branch"><a class="header" href="#update-the-stable-branch">Update the <code>stable</code> branch</a></h2>
<p>At this step you should have already checked out the commit of the <code>rust-1.XX.0</code>
tag. Updating the stable branch from here is as easy as:</p>
<pre><code class="language-bash"># Assuming the current directory corresponds to the Clippy repository and the
# commit of the just created rust-1.XX.0 tag is checked out.
$ git push upstream rust-1.XX.0:stable  # `upstream` is the `rust-lang/rust-clippy` remote
</code></pre>
<blockquote>
<p><em>NOTE:</em> Usually there are no stable backports for Clippy, so this update
should be possible without force pushing or anything like this. If there
should have happened a stable backport, make sure to re-merge those changes
just as with the <code>beta</code> branch.</p>
</blockquote>
<h2 id="update-changelogmd"><a class="header" href="#update-changelogmd">Update <code>CHANGELOG.md</code></a></h2>
<p>For this see the document on <a href="development/infrastructure/changelog_update.html">how to update the changelog</a>.</p>
<p>If you don't have time to do a complete changelog update right away, just update
the following parts:</p>
<ul>
<li>
<p>Remove the <code>(beta)</code> from the new stable version:</p>
<pre><code class="language-markdown">## Rust 1.XX (beta) -&gt; ## Rust 1.XX
</code></pre>
</li>
<li>
<p>Update the release date line of the new stable version:</p>
<pre><code class="language-markdown">Current beta, release 20YY-MM-DD -&gt; Current stable, released 20YY-MM-DD
</code></pre>
</li>
<li>
<p>Update the release date line of the previous stable version:</p>
<pre><code class="language-markdown">Current stable, released 20YY-MM-DD -&gt; Released 20YY-MM-DD
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-clippy-book"><a class="header" href="#the-clippy-book">The Clippy Book</a></h1>
<p>This document explains how to make additions and changes to the Clippy book, the
guide to Clippy that you're reading right now. The Clippy book is formatted with
<a href="https://www.markdownguide.org">Markdown</a> and generated by
<a href="https://github.com/rust-lang/mdBook">mdbook</a>.</p>
<ul>
<li><a href="development/infrastructure/book.html#get-mdbook">Get mdbook</a></li>
<li><a href="development/infrastructure/book.html#make-changes">Make changes</a></li>
</ul>
<h2 id="get-mdbook"><a class="header" href="#get-mdbook">Get mdbook</a></h2>
<p>While not strictly necessary since the book source is simply Markdown text
files, having mdbook locally will allow you to build, test and serve the book
locally to view changes before you commit them to the repository. You likely
already have <code>cargo</code> installed, so the easiest option is to simply:</p>
<pre><code class="language-shell">cargo install mdbook
</code></pre>
<p>See the mdbook <a href="https://github.com/rust-lang/mdBook#installation">installation</a>
instructions for other options.</p>
<h2 id="make-changes"><a class="header" href="#make-changes">Make changes</a></h2>
<p>The book's
<a href="https://github.com/rust-lang/rust-clippy/tree/master/book/src">src</a>
directory contains all of the markdown files used to generate the book. If you
want to see your changes in real time, you can use the mdbook <code>serve</code> command to
run a web server locally that will automatically update changes as they are
made. From the top level of your <code>rust-clippy</code> directory:</p>
<pre><code class="language-shell">mdbook serve book --open
</code></pre>
<p>Then navigate to <code>http://localhost:3000</code> to see the generated book. While the
server is running, changes you make will automatically be updated.</p>
<p>For more information, see the mdbook
<a href="https://rust-lang.github.io/mdBook/">guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proposals"><a class="header" href="#proposals">Proposals</a></h1>
<p>This chapter is about accepted proposals for changes that should be worked on in
or around Clippy in the long run.</p>
<p>Besides adding more and more lints and improve the lints that Clippy already
has, Clippy is also interested in making the experience of its users, developers
and maintainers better over time. Projects that address bigger picture things
like this usually take more time and it is useful to have a proposal for those
first. This is the place where such proposals are collected, so that we can
refer to them when working on them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap-2021"><a class="header" href="#roadmap-2021">Roadmap 2021</a></h1>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This Roadmap lays out the plans for Clippy in 2021:</p>
<ul>
<li>Improving usability and reliability</li>
<li>Improving experience of contributors and maintainers</li>
<li>Develop and specify processes</li>
</ul>
<p>Members of the Clippy team will be assigned tasks from one or more of these
topics. The team member is then responsible to complete the assigned tasks. This
can either be done by implementing them or by providing mentorship to interested
contributors.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>With the ongoing growth of the Rust language and with that of the whole
ecosystem, also Clippy gets more and more users and contributors. This is good
for the project, but also brings challenges along. Some of these challenges are:</p>
<ul>
<li>More issues about reliability or usability are popping up</li>
<li>Traffic is hard to handle for a small team</li>
<li>Bigger projects don't get completed due to the lack of processes and/or time
of the team members</li>
</ul>
<p>Additionally, according to the <a href="https://github.com/rust-lang/rfcs/pull/3037">Rust Roadmap 2021</a>, clear processes should be
defined by every team and unified across teams. This Roadmap is the first step
towards this.</p>
<h1 id="explanation"><a class="header" href="#explanation">Explanation</a></h1>
<p>This section will explain the things that should be done in 2021. It is
important to note, that this document focuses on the &quot;What?&quot;, not the &quot;How?&quot;.
The later will be addressed in follow-up tracking issue, with an assigned team
member.</p>
<p>The following is split up in two major sections. The first section covers the
user facing plans, the second section the internal plans.</p>
<h2 id="user-facing"><a class="header" href="#user-facing">User Facing</a></h2>
<p>Clippy should be as pleasant to use and configure as possible. This section
covers plans that should be implemented to improve the situation of Clippy in
this regard.</p>
<h3 id="usability"><a class="header" href="#usability">Usability</a></h3>
<p>In the following, plans to improve the usability are covered.</p>
<h4 id="no-output-after-cargo-check"><a class="header" href="#no-output-after-cargo-check">No Output After <code>cargo check</code></a></h4>
<p>Currently when <code>cargo clippy</code> is run after <code>cargo check</code>, it does not produce
any output. This is especially problematic since <code>rust-analyzer</code> is on the rise
and it uses <code>cargo check</code> for checking code. A fix is already implemented, but
it still has to be pushed over the finish line. This also includes the
stabilization of the <code>cargo clippy --fix</code> command or the support of multi-span
suggestions in <code>rustfix</code>.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/4612">#4612</a></li>
</ul>
<h4 id="lintstoml-configuration"><a class="header" href="#lintstoml-configuration"><code>lints.toml</code> Configuration</a></h4>
<p>This is something that comes up every now and then: a reusable configuration
file, where lint levels can be defined. Discussions about this often lead to
nothing specific or to &quot;we need an RFC for this&quot;. And this is exactly what needs
to be done. Get together with the cargo team and write an RFC and implement such
a configuration file somehow and somewhere.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/3164">#3164</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/5034">cargo#5034</a></li>
<li><a href="https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8">IRLO</a></li>
</ul>
<h4 id="lint-groups"><a class="header" href="#lint-groups">Lint Groups</a></h4>
<p>There are more and more issues about managing lints in Clippy popping up. Lints
are hard to implement with a guarantee of no/few false positives (FPs). One way
to address this might be to introduce more lint groups to give users the ability
to better manage lints, or improve the process of classifying lints, so that
disabling lints due to FPs becomes rare. It is important to note, that Clippy
lints are less conservative than <code>rustc</code> lints, which won't change in the
future.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/5537">#5537</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6366">#6366</a></li>
</ul>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<p>In the following, plans to improve the reliability are covered.</p>
<h4 id="false-positive-rate"><a class="header" href="#false-positive-rate">False Positive Rate</a></h4>
<p>In the worst case, new lints are only available in nightly for 2 weeks, before
hitting beta and ultimately stable. This and the fact that fewer people use
nightly Rust nowadays makes it more probable that a lint with many FPs hits
stable. This leads to annoyed users, that will disable these new lints in the
best case and to more annoyed users, that will stop using Clippy in the worst.
A process should be developed and implemented to prevent this from happening.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429">#6429</a></li>
</ul>
<h2 id="internal"><a class="header" href="#internal">Internal</a></h2>
<p>(The end of) 2020 has shown, that Clippy has to think about the available
resources, especially regarding management and maintenance of the project. This
section address issues affecting team members and contributors.</p>
<h3 id="management"><a class="header" href="#management">Management</a></h3>
<p>In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open
PRs. This is simultaneously a win and a loss. More issues and PRs means more
people are interested in Clippy and in contributing to it. On the other hand, it
means for team members more work and for contributors longer wait times for
reviews. The following will describe plans how to improve the situation for both
team members and contributors.</p>
<h4 id="clear-expectations-for-team-members"><a class="header" href="#clear-expectations-for-team-members">Clear Expectations for Team Members</a></h4>
<p>According to the <a href="https://github.com/rust-lang/rfcs/pull/3037">Rust Roadmap 2021</a>, a document specifying what it means to be
a member of the team should be produced. This should not put more pressure on
the team members, but rather help them and interested folks to know what the
expectations are. With this it should also be easier to recruit new team members
and may encourage people to get in touch, if they're interested to join.</p>
<h4 id="scaling-up-the-team"><a class="header" href="#scaling-up-the-team">Scaling up the Team</a></h4>
<p>More people means less work for each individual. Together with the document
about expectations for team members, a document defining the process of how to
join the team should be produced. This can also increase the stability of the
team, in case of current members dropping out (temporarily). There can also be
different roles in the team, like people triaging vs. people reviewing.</p>
<h4 id="regular-meetings"><a class="header" href="#regular-meetings">Regular Meetings</a></h4>
<p>Other teams have regular meetings. Clippy is big enough that it might be worth
to also do them. Especially if more people join the team, this can be important
for sync-ups. Besides the asynchronous communication, that works well for
working on separate lints, a meeting adds a synchronous alternative at a known
time. This is especially helpful if there are bigger things that need to be
discussed (like the projects in this roadmap). For starters bi-weekly meetings
before Rust syncs might make sense.</p>
<h4 id="triaging"><a class="header" href="#triaging">Triaging</a></h4>
<p>To get a handle on the influx of open issues, a process for triaging issues and
PRs should be developed. Officially, Clippy follows the Rust triage process, but
currently no one enforces it. This can be improved by sharing triage teams
across projects or by implementing dashboards / tools which simplify triaging.</p>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<p>Improving the developer and contributor experience is something the Clippy team
works on regularly. Though, some things might need special attention and
planing. These topics are listed in the following.</p>
<h4 id="process-for-new-and-existing-lints"><a class="header" href="#process-for-new-and-existing-lints">Process for New and Existing Lints</a></h4>
<p>As already mentioned above, classifying new lints gets quite hard, because the
probability of a buggy lint getting into stable is quite high. A process should
be implemented on how to classify lints. In addition, a test system should be
developed to find out which lints are currently problematic in real world code
to fix or disable them.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379">#6429 (comment)</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345">#6429 (comment)</a></li>
</ul>
<h4 id="processes"><a class="header" href="#processes">Processes</a></h4>
<p>Related to the point before, a process for suggesting and discussing major
changes should be implemented. It's also not clearly defined when a lint should
be enabled or disabled by default. This can also be improved by the test system
mentioned above.</p>
<h4 id="dev-tools"><a class="header" href="#dev-tools">Dev-Tools</a></h4>
<p>There's already <code>cargo dev</code> which makes Clippy development easier and more
pleasant. This can still be expanded, so that it covers more areas of the
development process.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/5394">#5394</a></li>
</ul>
<h4 id="contributor-guide"><a class="header" href="#contributor-guide">Contributor Guide</a></h4>
<p>Similar to a Clippy Book, which describes how to use Clippy, a book about how to
contribute to Clippy might be helpful for new and existing contributors. There's
already the <code>doc</code> directory in the Clippy repo, this can be turned into a
<code>mdbook</code>.</p>
<h4 id="rustc-integration"><a class="header" href="#rustc-integration"><code>rustc</code> integration</a></h4>
<p>Recently Clippy was integrated with <code>git subtree</code> into the <code>rust-lang/rust</code>
repository. This made syncing between the two repositories easier. A
<code>#[non_exhaustive]</code> list of things that still can be improved is:</p>
<ol>
<li>Use the same <code>rustfmt</code> version and configuration as <code>rustc</code>.</li>
<li>Make <code>cargo dev</code> work in the Rust repo, just as it works in the Clippy repo.
E.g. <code>cargo dev bless</code> or <code>cargo dev update_lints</code>. And even add more things
to it that might be useful for the Rust repo, e.g. <code>cargo dev deprecate</code>.</li>
<li>Easier sync process. The <code>subtree</code> situation is not ideal.</li>
</ol>
<h2 id="prioritization"><a class="header" href="#prioritization">Prioritization</a></h2>
<p>The most pressing issues for users of Clippy are of course the user facing
issues. So there should be a priority on those issues, but without losing track
of the internal issues listed in this document.</p>
<p>Getting the FP rate of warn/deny-by-default lints under control should have the
highest priority. Other user facing issues should also get a high priority, but
shouldn't be in the way of addressing internal issues.</p>
<p>To better manage the upcoming projects, the basic internal processes, like
meetings, tracking issues and documentation, should be established as soon as
possible. They might even be necessary to properly manage the projects,
regarding the user facing issues.</p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior Art</a></h1>
<h2 id="rust-roadmap"><a class="header" href="#rust-roadmap">Rust Roadmap</a></h2>
<p>Rust's roadmap process was established by <a href="https://rust-lang.github.io/rfcs/1728-north-star.html">RFC 1728</a> in 2016. Since then every
year a roadmap was published, that defined the bigger plans for the coming
years. This years roadmap can be found <a href="https://github.com/rust-lang/rfcs/pull/3037">here</a>.</p>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<h2 id="big-roadmap"><a class="header" href="#big-roadmap">Big Roadmap</a></h2>
<p>This roadmap is pretty big and not all items listed in this document might be
addressed during 2021. Because this is the first roadmap for Clippy, having open
tasks at the end of 2021 is fine, but they should be revisited in the 2022
roadmap.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
