window.SIDEBAR_ITEMS = {"constant":[["ASSOC_CONST_DISCR128_BEGIN_HI",""],["ASSOC_CONST_DISCR128_BEGIN_LO",""],["ASSOC_CONST_DISCR128_END_HI",""],["ASSOC_CONST_DISCR128_END_LO",""],["ASSOC_CONST_DISCR128_EXACT_HI",""],["ASSOC_CONST_DISCR128_EXACT_LO",""],["ASSOC_CONST_DISCR_BEGIN",""],["ASSOC_CONST_DISCR_END",""],["ASSOC_CONST_DISCR_EXACT",""],["ASSOC_CONST_DISCR_NAME",""],["SINGLE_VARIANT_VIRTUAL_DISR",""],["TAG_FIELD_NAME",""],["TAG_FIELD_NAME_128_HI",""],["TAG_FIELD_NAME_128_LO",""]],"fn":[["build_enum_type_di_node","In CPP-like mode, we generate a union with a field for each variant and an explicit tag field. The field of each variant has a struct type that encodes the discrimiant of the variant and it’s data layout. The union also has a nested enumeration type that is only used for encoding variant names in an efficient way. Its enumerator values do not correspond to the enum’s discriminant values. It’s roughly equivalent to the following C/C++ code:"],["build_generator_di_node","A generator debuginfo node looks the same as a that of an enum type."],["build_single_variant_union_fields",""],["build_union_fields_for_direct_tag_enum_or_generator","This is a helper function shared between enums and generators that makes sure fields have the expect names."],["build_union_fields_for_direct_tag_generator",""],["build_union_fields_for_enum",""],["build_variant_names_type_di_node","This function builds a DW_AT_enumeration_type that contains an entry for each variant. Note that this has nothing to do with the discriminant. The numeric value of each enumerator corresponds to the variant index. The type is only used for efficiently encoding the name of each variant in debuginfo."],["build_variant_struct_wrapper_type_di_node",""],["split_128",""],["variant_names_enum_base_type",""],["variant_struct_wrapper_type_name",""],["variant_union_field_name",""]],"struct":[["Split128",""],["VariantFieldInfo","Information about a single field of the top-level DW_TAG_union_type."]]};