window.SIDEBAR_ITEMS = {"enum":[["Class","How a span of text is classified. Mostly corresponds to token kinds."],["Highlight",""],["Tooltip",""]],"fn":[["can_merge","Check if two `Class` can be merged together. In the following rules, “unclassified” means `None` basically (since it’s `Option<Class>`). The following rules apply:"],["enter_span","Called when we start processing a span of text that should be highlighted. The `Class` argument specifies how it should be highlighted."],["exit_span","Called at the end of a span of highlighted text."],["get_real_ident_class","Classifies into identifier class; returns `None` if this is a non-keyword identifier."],["render_example_with_highlighting","Highlights `src` as an inline example, returning the HTML output."],["render_macro_with_highlighting","Highlights `src` as a macro, returning the HTML output."],["render_source_with_highlighting","Highlights `src` as a source code page, returning the HTML output."],["string","Called for a span of text. If the text should be highlighted differently from the surrounding text, then the `Class` argument will be a value other than `None`."],["string_without_closing_tag","This function writes `text` into `out` with some modifications depending on `klass`:"],["write_code","Convert the given `src` source code into HTML by adding classes for highlighting."],["write_footer",""],["write_header",""]],"struct":[["Classifier","Processes program tokens, classifying strings of text by highlighting category (`Class`)."],["DecorationInfo","Decorations are represented as a map from CSS class to vector of character ranges. Each range will be wrapped in a span with that class."],["Decorations","Custom spans inserted into the source. Eg –scrape-examples uses this to highlight function calls"],["HrefContext","This type is needed in case we want to render links on items to allow to go to their definition."],["PeekIter","This iterator comes from the same idea than “Peekable” except that it allows to “peek” more than just the next item by using `peek_next`. The `peek` method always returns the next item after the current one whereas `peek_next` will return the next item after the last one peeked."],["TokenHandler","This type is used as a conveniency to prevent having to pass all its fields as arguments into the various functions (which became its methods)."],["TokenIter",""]]};