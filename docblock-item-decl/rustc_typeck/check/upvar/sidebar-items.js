window.SIDEBAR_ITEMS = {"enum":[["PlaceAncestryRelation","Describe the relationship between the paths of two places eg:"],["UpvarMigrationInfo","Intermediate format to store the hir_id pointing to the use that resulted in the corresponding place being captured and a String which contains the captured value’s name (i.e: a.b.c)"]],"fn":[["adjust_for_move_closure","Truncate deref of any reference."],["adjust_for_non_move_closure","Adjust closure capture just that if taking ownership of data, only move data from enclosing stack frame."],["apply_capture_kind_on_capture_ty","Returns a Ty that applies the specified capture kind on the provided capture Ty"],["construct_capture_info_string",""],["construct_capture_kind_reason_string",""],["construct_path_string",""],["construct_place_string",""],["determine_capture_info","Helper function to determine if we need to escalate CaptureKind from CaptureInfo A to B and returns the escalated CaptureInfo. (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)"],["determine_place_ancestry_relation","Determines the Ancestry relationship of Place A relative to Place B"],["drop_location_span","Returns the Span of where the value with the provided HirId would be dropped"],["enable_precise_capture","Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if user is using Rust Edition 2021 or higher."],["migration_suggestion_for_2229","Return a two string tuple (s1, s2)"],["restrict_capture_precision","Truncate projections so that following rules are obeyed by the captured `place`:"],["restrict_precision_for_drop_types","Rust doesn’t permit moving fields out of a type that implements drop"],["restrict_precision_for_unsafe","Truncate `place` so that an `unsafe` block isn’t required to capture it."],["restrict_repr_packed_field_ref_capture","Truncate the capture so that the place being borrowed is in accordance with RFC 1240, which states that it’s unsafe to take a reference into a struct marked `repr(packed)`."],["should_do_rust_2021_incompatible_closure_captures_analysis",""],["truncate_capture_for_optimization","Reduces the precision of the captured place when the precision doesn’t yield any benefit from borrow checking perspective, allowing us to save us on the size of the capture."],["truncate_place_to_len_and_update_capture_kind","Truncates `place` to have up to `len` projections. `curr_mode` is the current required capture kind for the place. Returns the truncated `place` and the updated required capture kind."],["var_name",""]],"struct":[["InferBorrowKind",""],["InferBorrowKindVisitor",""],["MigrationLintNote","Intermediate format to store information needed to generate a note in the migration lint."],["MigrationWarningReason","Reasons that we might issue a migration warning."],["NeededMigration","Intermediate format to store the hir id of the root variable and a HashSet containing information on why the root variable should be fully captured"]],"type":[["InferredCaptureInformation","Intermediate format to store a captured `Place` and associated `ty::CaptureInfo` during capture analysis. Information in this map feeds into the minimum capture analysis pass."]]};