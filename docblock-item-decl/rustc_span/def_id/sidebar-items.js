window.SIDEBAR_ITEMS = {"constant":[["CRATE_DEF_ID",""],["CRATE_DEF_INDEX","The crate root is always assigned index 0 by the AST Map code, thanks to `NodeCollector::new`."],["LOCAL_CRATE","Item definitions in the currently-compiled crate would have the `CrateNum` `LOCAL_CRATE` in their `DefId`."]],"fn":[["default_def_id_debug",""]],"static":[["DEF_ID_DEBUG",""]],"struct":[["CrateNum",""],["DefId","A `DefId` identifies a particular definition, by combining a crate index and a def index."],["DefIndex","A DefIndex is an index into the hir-map for a crate, identifying a particular definition. It should really be considered an interned shorthand for a particular DefPath."],["DefPathHash","A `DefPathHash` is a fixed-size representation of a `DefPath` that is stable across crate and compilation session boundaries. It consists of two separate 64-bit hashes. The first uniquely identifies the crate this `DefPathHash` originates from (see [StableCrateId]), and the second uniquely identifies the corresponding `DefPath` within that crate. Together they form a unique identifier within an entire crate graph."],["LocalDefId","A `LocalDefId` is equivalent to a `DefId` with `krate == LOCAL_CRATE`. Since we encode this information in the type, we can ensure at compile time that no `DefId`s from upstream crates get thrown into the mix. There are quite a few cases where we know that only `DefId`s from the local crate are expected; a `DefId` from a different crate would signify a bug somewhere. This is when `LocalDefId` comes in handy."],["StableCrateId","A [`StableCrateId`] is a 64-bit hash of a crate name, together with all `-Cmetadata` arguments, and some other data. It is to [`CrateNum`] what [`DefPathHash`] is to [`DefId`]. It is stable across compilation sessions."]],"type":[["DefIdMap",""],["DefIdMapEntry",""],["DefIdSet",""],["LocalDefIdMap",""],["LocalDefIdMapEntry",""],["LocalDefIdSet",""]]};