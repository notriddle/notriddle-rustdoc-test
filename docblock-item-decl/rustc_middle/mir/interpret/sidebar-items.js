window.SIDEBAR_ITEMS = {"enum":[["AllocDiscriminant",""],["CheckInAllocMsg","Details of why a pointer had to be in-bounds."],["ConstValue","Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for array length computations, enum discriminants and the pattern matching logic."],["ErrorHandled",""],["GlobalAlloc","An allocation in the global (tcx-managed) memory can be either a function pointer, a static, or a “real” allocation with some data in it."],["InitChunk","A contiguous chunk of initialized or uninitialized memory."],["InterpError",""],["InvalidProgramInfo","Error information for when the program we executed turned out not to actually be a valid program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp where we work on generic code or execution does not have all information available."],["LitToConstError","Error type for `tcx.lit_to_const`."],["ResourceExhaustionInfo","Error information for when the program exhausted the resources granted to it by the interpreter."],["Scalar","A `Scalar` represents an immediate, primitive value existing outside of a `memory::Allocation`. It is in many ways like a small chunk of an `Allocation`, up to 16 bytes in size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes of a simple value or a pointer into another `Allocation`"],["State",""],["UndefinedBehaviorInfo","Error information for when the program caused Undefined Behavior."],["UnsupportedOpInfo","Error information for when the program did something that might (or might not) be correct to do according to the Rust spec, but due to limitations in the interpreter, the operation could not be carried out. These limitations can differ between CTFE and the Miri engine, e.g., CTFE does not support dereferencing pointers at integral addresses."]],"fn":[["alloc_range","Free-starting constructor for less syntactic overhead."],["get_slice_bytes","Gets the bytes of a constant slice value."],["read_target_uint",""],["specialized_encode_alloc_id",""],["struct_error",""],["write_target_uint",""]],"mod":[["allocation","The virtual memory representation of the MIR interpreter."],["error",""],["pointer",""],["queries",""],["value",""]],"struct":[["AllocDecodingSession",""],["AllocDecodingState",""],["AllocId",""],["AllocMap",""],["AllocRange","The information that makes up a memory access: offset and size."],["Allocation","This type represents an Allocation in the Miri/CTFE core engine."],["ConstAlloc","Represents the result of const evaluation via the `eval_to_allocation` query."],["ConstAllocation","Interned types generally have an `Outer` type and an `Inner` type, where `Outer` is a newtype around `Interned<Inner>`, and all the operations are done on `Outer`, because all occurrences are interned. E.g. `Ty` is an outer type and `TyS` is its inner type."],["GlobalId","Uniquely identifies one of the following:"],["InitChunkIter","Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`]."],["InitMask","A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte is initialized. If it is `false` the byte is uninitialized."],["InterpErrorInfo","Packages the kind of error we got from the const code interpreter up with a Rust-level backtrace of where the error occurred. These should always be constructed by calling `.into()` on an `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*` macros for this."],["LitToConstInput","Input argument for `tcx.lit_to_const`."],["Pointer","Represents a pointer in the Miri engine."],["ProvenanceMap","Stores the provenance information of pointers stored in memory."],["ScalarSizeMismatch","Information about a size mismatch."],["UninitBytesAccess","Details of an access to uninitialized bytes where it is not allowed."]],"trait":[["MachineStopType","A trait for machine-specific errors (or other “machine stop” conditions)."],["PointerArithmetic",""],["Provenance","This trait abstracts over the kind of provenance that is associated with a `Pointer`. It is mostly opaque; the `Machine` trait extends it with some more operations that also have access to some global state. We don’t actually care about this `Debug` bound (we use `Provenance::fmt` to format the entire pointer), but `derive` adds some unnecessary bounds."]],"type":[["DecodingSessionId",""],["EvalToAllocationRawResult",""],["EvalToConstValueResult",""],["EvalToValTreeResult",""],["InterpResult",""]]};