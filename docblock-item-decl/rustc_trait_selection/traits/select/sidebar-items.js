window.SIDEBAR_ITEMS = {"enum":[["BuiltinImplConditions","When does the builtin impl for `T: Trait` apply?"],["EvaluationResult","The result of trait evaluation. The order is important here as the evaluation of a list is the maximum of the evaluations."],["IntercrateAmbiguityCause",""],["OverflowError","Indicates that trait evaluation caused overflow and in which pass."],["ProjectionMatchesProjection",""],["SelectionCandidate","The selection process begins by considering all impls, where clauses, and so forth that might resolve an obligation. Sometimes we’ll be able to say definitively that (e.g.) an impl does not apply to the obligation: perhaps it is defined for `usize` but the obligation is for `i32`. In that case, we drop the impl out of the list. But the other cases are considered candidates."]],"mod":[["candidate_assembly","Candidate assembly."],["confirmation","Confirmation."]],"struct":[["EvaluatedCandidate",""],["ProvisionalEvaluation","A cache value for the provisional cache: contains the depth-first number (DFN) and result."],["ProvisionalEvaluationCache","The “provisional evaluation cache” is used to store intermediate cache results when solving auto traits. Auto traits are unusual in that they can support cycles. So, for example, a “proof tree” like this would be ok:"],["SelectionCandidateSet",""],["SelectionContext",""],["TraitObligationStack",""],["TraitObligationStackList",""]],"type":[["EvaluationCache",""],["SelectionCache",""]]};