window.SIDEBAR_ITEMS = {"enum":[["CodegenObligationError","These are the error cases for `codegen_select_candidate`."],["EvaluationResult","The result of trait evaluation. The order is important here as the evaluation of a list is the maximum of the evaluations."],["FulfillmentErrorCode",""],["FutureCompatOverlapErrorKind",""],["ImplSource","Given the successful resolution of an obligation, the `ImplSource` indicates where the impl comes from."],["IntercrateAmbiguityCause",""],["MethodViolationCode","Reasons a method might not be object-safe."],["ObjectSafetyViolation",""],["ObligationCauseCode",""],["OrphanCheckErr",""],["OverflowError","Indicates that trait evaluation caused overflow and in which pass."],["ProjectionCacheEntry",""],["Reveal","Depending on the stage of compilation, we want projection to be more or less conservative."],["SelectionError",""],["SkipLeakCheck","Whether to skip the leak check, as part of a future compatibility warning step."],["StatementAsExpression",""],["TraitQueryMode","The mode that trait queries run in."],["VtblSegment",""],["WellFormedLoc","The ‘location’ at which we try to perform HIR-based wf checking. This information is used to obtain an `hir::Ty`, which we can walk in order to obtain precise spans for any ‘nested’ types (e.g. `Foo` in `Option<Foo>`)."]],"fn":[["add_placeholder_note",""],["astconv_object_safety_violations","Returns the object safety violations that affect astconv – currently, `Self` in supertraits. This is needed because `object_safety_violations` can’t be used during type collection."],["do_normalize_predicates",""],["dump_vtable_entries",""],["elaborate_obligations",""],["elaborate_predicates",""],["elaborate_predicates_with_span",""],["elaborate_trait_ref",""],["elaborate_trait_refs",""],["expand_trait_aliases",""],["fully_normalize","Normalize a type and process all resulting obligations, returning any errors"],["fully_solve_bound","Process a bound (and any nested obligations that come from it) to completion. This is a convenience function for traits that have no generic arguments, such as auto traits, and builtin traits like Copy or Sized."],["fully_solve_obligation","Process an obligation (and any nested obligations that come from it) to completion, returning any errors"],["fully_solve_obligations","Process a set of obligations (and any nested obligations that come from them) to completion"],["get_vtable_index_of_object_method","Given an upcast trait object described by `object`, returns the index of the method `method_def_id` (which should be part of `object.upcast_trait_ref`) within the vtable for `object`."],["impl_item_is_final",""],["impossible_predicates","Normalizes the predicates and checks whether they hold in an empty environment. If this returns true, then either normalize encountered an error or one of the predicates did not hold. Used when creating vtables to check for unsatisfiable methods."],["is_impossible_method","Checks whether a trait’s method is impossible to call on a given impl."],["is_vtable_safe_method","We say a method is vtable safe if it can be invoked on a trait object. Note that object-safe traits can have some non-vtable-safe methods, so long as they require `Self: Sized` or otherwise ensure that they cannot be used when `Self = Trait`."],["normalize","Normalizes any associated type projections in `value`, replacing them with a fully resolved type where possible. The return value combines the normalized result and any additional obligations that were incurred as result."],["normalize_param_env_or_error","Normalizes the parameter environment, reporting errors if they occur."],["normalize_projection_type","The guts of `normalize`: normalize a specific projection like `<T as Trait>::Item`. The result is always a type (and possibly additional obligations). If ambiguity arises, which implies that there are unresolved type variables in the projection, we will substitute a fresh type variable `$X` and generate a new obligation `<T as Trait>::Item == $X` for later."],["normalize_to",""],["orphan_check","Checks the coherence orphan rules. `impl_def_id` should be the `DefId` of a trait impl. To pass, either the trait must be local, or else two conditions must be satisfied:"],["overlapping_impls","If there are types that satisfy both impls, invokes `on_overlap` with a suitably-freshened `ImplHeader` with those types substituted. Otherwise, invokes `no_overlap`."],["own_existential_vtable_entries",""],["predicate_for_trait_def",""],["predicates_for_generics","Creates predicate obligations from the generic bounds."],["prepare_vtable_segments","Prepare the segments for a vtable"],["provide",""],["search_for_adt_const_param_violation","This method traverses the structure of `ty`, trying to find any types that are not allowed to be used in a const generic."],["search_for_structural_match_violation","This method traverses the structure of `ty`, trying to find an instance of an ADT (i.e. struct or enum) that doesn’t implement the structural-match traits, or a generic type parameter (which cannot be determined to be structural-match)."],["subst_and_check_impossible_predicates",""],["supertrait_def_ids",""],["supertraits",""],["transitive_bounds",""],["transitive_bounds_that_define_assoc_type","A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may define the given associated type `assoc_name`. It uses the `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that aren’t related to `assoc_item`.  This is used when resolving types like `Self::Item` or `T::Item` and helps to avoid cycle errors (see e.g. #35237)."],["translate_substs","Given a subst for the requested impl, translate it to a subst appropriate for the actual item definition (whether it be in that impl, a parent impl, or the trait)."],["type_known_to_meet_bound_modulo_regions","Determines whether the type `ty` is known to meet `bound` and returns true if so. Returns false if `ty` either does not meet `bound` or is not known to meet bound (note that this is conservative towards no impl, which is the opposite of the `evaluate` methods)."],["upcast_choices","Casts a trait reference into a reference to one of its super traits; returns `None` if `target_trait_def_id` is not a supertrait."],["vtable_entries","Given a trait `trait_ref`, iterates the vtable entries that come from `trait_ref`, including its supertraits."],["vtable_trait_first_method_offset","Find slot base for trait methods within vtable entries of another trait"],["vtable_trait_upcasting_coercion_new_vptr_slot","Find slot offset for trait vptr within vtable entries of another trait"]],"mod":[["auto_trait","Support code for rustdoc and external tools. You really don’t want to be using this unless you need to."],["chalk_fulfill","Defines a Chalk-based `TraitEngine`"],["codegen",""],["coherence","See Rustc Dev Guide chapters on trait-resolution and trait-specialization for more info on how this works."],["const_evaluatable","Checking that constant values used in types can be successfully evaluated."],["engine",""],["error_reporting",""],["fulfill",""],["misc","Miscellaneous type-system utilities that are too small to deserve their own modules."],["object_safety","“Object safety” refers to the ability for a trait to be converted to an object. In general, traits may only be converted to an object if all of their methods meet certain criteria. In particular, they must:"],["on_unimplemented",""],["outlives_bounds",""],["project","Code for projecting associated types out of trait references."],["query","Experimental types for the trait query interface. The methods defined in this module are all based on canonicalization, which makes a canonical query by replacing unbound inference variables and regions, so that results can be reused more broadly. The providers for the queries defined here can be found in `rustc_traits`."],["relationships",""],["select","Candidate selection. See the rustc dev guide for more information on how this works."],["specialization_graph",""],["specialize","Logic and data structures related to impl specialization, explained in greater detail below."],["structural_match",""],["util",""],["wf",""]],"struct":[["ChalkEnvironmentAndGoal","A chalk environment and goal."],["ChalkFulfillmentContext",""],["ChalkRustInterner",""],["DerivedObligationCause",""],["FulfillmentContext","The fulfillment context is used to drive trait resolution. It consists of a list of obligations that must be (eventually) satisfied. The job is to track which are satisfied, which yielded errors, and which are still pending. At any point, users can call `select_where_possible`, and the fulfillment context will try to do selection, retaining only those obligations that remain ambiguous. This may be helpful in pushing type inference along. Once all type inference constraints have been generated, the method `select_all_or_error` can be used to report any remaining ambiguous cases as errors."],["FulfillmentError",""],["FutureCompatOverlapError",""],["IfExpressionCause",""],["ImplDerivedObligationCause",""],["ImplSourceAutoImplData",""],["ImplSourceBuiltinData",""],["ImplSourceClosureData",""],["ImplSourceConstDestructData",""],["ImplSourceDiscriminantKindData",""],["ImplSourceFnPointerData",""],["ImplSourceGeneratorData",""],["ImplSourceObjectData",""],["ImplSourcePointeeData",""],["ImplSourceTraitAliasData",""],["ImplSourceTraitUpcastingData",""],["ImplSourceUserDefinedData","Identifies a particular impl in the source, along with a set of substitutions from the impl’s type/lifetime parameters. The `nested` vector corresponds to the nested obligations attached to the impl’s type parameters."],["InternedObligationCauseCode",""],["MatchExpressionArmCause",""],["MismatchedProjectionTypes",""],["Normalized",""],["Obligation","An `Obligation` represents some trait reference (e.g., `i32: Eq`) for which the “impl_source” must be found. The process of finding an “impl_source” is called “resolving” the `Obligation`. This process consists of either identifying an `impl` (e.g., `impl Eq for i32`) that satisfies the obligation, or else finding a bound that is in scope. The eventual result is usually a `Selection` (defined below)."],["ObligationCause","The reason why we incurred this obligation; used for error reporting."],["ObligationCtxt","Used if you want to have pleasant experience when dealing with obligations outside of hir or mir typeck."],["OnUnimplementedDirective",""],["OnUnimplementedNote",""],["OverlapError","Information pertinent to an overlapping impl error."],["OverlapResult",""],["PendingPredicateObligation",""],["ProjectionCache","The projection cache. Unlike the standard caches, this can include infcx-dependent type variables, therefore we have to roll the cache back each time we roll a snapshot back, to avoid assumptions on yet-unresolved inference variables. Types with placeholder regions also have to be removed when the respective snapshot ends."],["ProjectionCacheKey",""],["ProjectionCacheStorage",""],["SelectionContext",""],["SupertraitDefIds",""],["TraitAliasExpander","“Trait alias expansion” is the process of expanding a sequence of trait references into another sequence by transitively following all trait aliases. e.g. If you have bounds like `Foo + Send`, a trait alias `trait Foo = Bar + Sync;`, and another trait alias `trait Bar = Read + Write`, then the bounds would expand to `Read + Write + Sync + Send`. Expansion is done via a DFS (depth-first search), and the `visited` field is used to avoid cycles."],["UnifyReceiverContext",""]],"trait":[["TraitEngine",""],["TraitEngineExt",""]],"type":[["CanonicalChalkEnvironmentAndGoal",""],["EvaluationCache",""],["NormalizedTy",""],["PredicateObligation",""],["PredicateObligations",""],["Selection",""],["SelectionCache",""],["SelectionResult","When performing resolution, it is typically the case that there can be one of three outcomes:"],["Supertraits",""],["TraitObligation",""]]};