window.SIDEBAR_ITEMS = {"fn":[["anonymize_predicate",""],["elaborate_obligations",""],["elaborate_predicates",""],["elaborate_predicates_with_span",""],["elaborate_trait_ref",""],["elaborate_trait_refs",""],["supertraits",""],["transitive_bounds",""],["transitive_bounds_that_define_assoc_type","A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may define the given associated type `assoc_name`. It uses the `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that aren’t related to `assoc_item`.  This is used when resolving types like `Self::Item` or `T::Item` and helps to avoid cycle errors (see e.g. #35237)."]],"struct":[["Elaborator","“Elaboration” is the process of identifying all the predicates that are implied by a source predicate. Currently, this basically means walking the “supertraits” and other similar assumptions. For example, if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd` holds as well. Similarly, if we have `trait Foo: 'static`, and we know that `T: Foo`, then we know that `T: 'static`."],["FilterToTraits","A filter around an iterator of predicates that makes it yield up just trait references."],["PredicateSet",""]],"type":[["Supertraits",""]]};