window.SIDEBAR_ITEMS = {"enum":[["AnnotationKind",""],["InheritConstStability","Whether to inherit const stability flags for nested items. In most cases, we do not want to inherit const stability: just because an enclosing `fn` is const-stable does not mean all `extern` imports declared in it should be const-stable! However, trait methods inherit const stability attributes from their parent and do not have their own."],["InheritDeprecation","Whether to inherit deprecation flags for nested items. In most cases, we do want to inherit deprecation, because nested items rarely have individual deprecation attributes, and so should be treated as deprecated if their parent is. However, default generic parameters have separate deprecation attributes from their parents, so we do not wish to inherit deprecation in this case. For example, inheriting deprecation for `T` in `Foo<T>` would cause a duplicate warning arising from both `Foo` and `T` being deprecated."],["InheritStability",""]],"fn":[["check_mod_unstable_api_usage","Cross-references the feature names of unstable APIs with enabled features and possibly prints errors."],["check_unused_or_stable_features","Given the list of enabled features that were not language features (i.e., that were expected to be library features), and the list of features used from libraries, identify activated features that donâ€™t exist and error about them."],["duplicate_feature_err",""],["is_unstable_reexport","Check whether a path is a `use` item that has been marked as unstable."],["missing_const_err",""],["provide",""],["stability_index",""],["unnecessary_partially_stable_feature_lint",""],["unnecessary_stable_feature_lint",""]],"struct":[["Annotator","A private tree-walker for producing an `Index`."],["CheckTraitImplStable",""],["Checker",""],["MissingStabilityAnnotations",""]]};