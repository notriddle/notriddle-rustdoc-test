window.SIDEBAR_ITEMS = {"enum":[["RlibFlavor",""]],"fn":[["add_apple_sdk",""],["add_gcc_ld_path",""],["add_late_link_args","Add arbitrary “late link” args defined by the target spec. FIXME: Determine where exactly these args need to be inserted."],["add_library_search_dirs","Add sysroot and other globally set directories to the directory search list."],["add_link_script","Add a link script embedded in the target, if applicable."],["add_linked_symbol_object","Add a synthetic object file that contains reference to all symbols that we want to expose to the linker."],["add_local_crate_allocator_objects","Add object files for allocator code linked once for the whole crate tree."],["add_local_crate_metadata_objects","Add object files containing metadata for the current crate."],["add_local_crate_regular_objects","Add object files containing code from the current crate."],["add_local_native_libraries","Native library linking"],["add_order_independent_options",""],["add_post_link_args","Add arbitrary “post-link” args defined by the target spec. FIXME: Determine where exactly these args need to be inserted."],["add_post_link_objects","Add post-link object files defined by the target spec."],["add_pre_link_args","Add arbitrary “pre-link” args defined by the target spec or from command line. FIXME: Determine where exactly these args need to be inserted."],["add_pre_link_objects","Add pre-link object files defined by the target spec."],["add_relro_args","Add options making relocation sections in the produced ELF files read-only and suppressing lazy binding."],["add_rpath_args","Add library search paths used at runtime by dynamic linkers."],["add_sanitizer_libraries",""],["add_upstream_native_libraries","Link in all of our upstream crates’ native dependencies. Remember that all of these upstream native dependencies are all non-static dependencies. We’ve got two cases then:"],["add_upstream_rust_crates","Linking Rust crates and their non-bundled static libraries"],["add_user_defined_link_args","Add arbitrary “user defined” args defined from command line. FIXME: Determine where exactly these args need to be inserted."],["archive_search_paths",""],["are_upstream_rust_objects_already_included",""],["collate_raw_dylibs","Extract all symbols defined in raw-dylib libraries, collated by library name."],["collect_natvis_visualizers",""],["detect_self_contained_mingw",""],["each_linked_rlib",""],["ensure_removed",""],["escape_string",""],["exec_linker",""],["get_apple_sdk_root",""],["get_object_file_path",""],["ignored_for_lto","Returns a boolean indicating whether the specified crate should be ignored during LTO."],["link_binary","Performs the linkage portion of the compilation phase. This will generate all of the requested outputs for this compilation session."],["link_dwarf_object","Use `thorin` (rust implementation of a dwarf packaging utility) to link DWARF objects into a DWARF package."],["link_natively","Create a dynamic library or executable."],["link_output_kind",""],["link_rlib","Create an ‘rlib’."],["link_sanitizer_runtime",""],["link_staticlib","Create a static archive."],["linker_and_flavor",""],["linker_with_args","Produce the linker command line containing linker path and arguments."],["preserve_objects_for_their_debuginfo","Returns a pair of boolean indicating whether we should preserve the object and dwarf object files on the filesystem for their debug information. This is often useful with split-dwarf like schemes."],["print_native_static_libs",""],["relevant_lib",""],["self_contained","Various toolchain components used during linking are used from rustc distribution instead of being found somewhere on the host system. We only provide such support for a very limited number of targets."],["strip_symbols_in_osx",""],["strip_value",""]]};