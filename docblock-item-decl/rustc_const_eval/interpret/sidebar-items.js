window.SIDEBAR_ITEMS = {"enum":[["AllocKind","The return value of `get_alloc_info` indicates the “kind” of the allocation."],["CheckInAllocMsg","Details of why a pointer had to be in-bounds."],["ConstValue","Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for array length computations, enum discriminants and the pattern matching logic."],["CtfeValidationMode","Extra things to check for during validation of CTFE results."],["ErrorHandled",""],["FnVal","The value of a function pointer."],["GlobalAlloc","An allocation in the global (tcx-managed) memory can be either a function pointer, a static, or a “real” allocation with some data in it."],["Immediate","An `Immediate` represents a single immediate self-contained Rust value."],["InitChunk","A contiguous chunk of initialized or uninitialized memory."],["InternKind",""],["InterpError",""],["InvalidProgramInfo","Error information for when the program we executed turned out not to actually be a valid program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp where we work on generic code or execution does not have all information available."],["LitToConstError","Error type for `tcx.lit_to_const`."],["LocalValue","Current value of a local variable"],["MemPlaceMeta","Information required for the sound usage of a `MemPlace`."],["MemoryKind",""],["Operand","An `Operand` is the result of computing a `mir::Operand`. It can be immediate, or still in memory. The latter is an optimization, to delay reading that chunk of memory and to avoid having to store arbitrary-sized data here."],["Place",""],["ResourceExhaustionInfo","Error information for when the program exhausted the resources granted to it by the interpreter."],["Scalar","A `Scalar` represents an immediate, primitive value existing outside of a `memory::Allocation`. It is in many ways like a small chunk of an `Allocation`, up to 16 bytes in size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes of a simple value or a pointer into another `Allocation`"],["StackPopCleanup",""],["StackPopJump","Data returned by Machine::stack_pop, to provide further control over the popping of the stack frame"],["StackPopUnwind","Unwind information."],["UndefinedBehaviorInfo","Error information for when the program caused Undefined Behavior."],["UnsupportedOpInfo","Error information for when the program did something that might (or might not) be correct to do according to the Rust spec, but due to limitations in the interpreter, the operation could not be carried out. These limitations can differ between CTFE and the Miri engine, e.g., CTFE does not support dereferencing pointers at integral addresses."]],"fn":[["alloc_range","Free-starting constructor for less syntactic overhead."],["get_slice_bytes","Gets the bytes of a constant slice value."],["intern_const_alloc_recursive","Intern `ret` and everything it references."],["read_target_uint",""],["specialized_encode_alloc_id",""],["struct_error",""],["write_target_uint",""]],"macro":[["compile_time_machine",""],["err_exhaust",""],["err_inval",""],["err_machine_stop",""],["err_ub",""],["err_ub_format",""],["err_unsup",""],["err_unsup_format",""],["throw_exhaust",""],["throw_inval",""],["throw_machine_stop",""],["throw_ub",""],["throw_ub_format",""],["throw_unsup",""],["throw_unsup_format",""]],"mod":[["cast",""],["eval_context",""],["intern","This module specifies the type based interner for constants."],["intrinsics","Intrinsics and other functions that the miri engine executes without looking at their MIR. Intrinsics/functions supported here are shared by CTFE and miri."],["machine","This module contains everything needed to instantiate an interpreter. This separation exists to ensure that no fancy miri features like interpreting common C functions leak into CTFE."],["memory","The memory subsystem."],["operand","Functions concerning immediate values and operands, and reading from operands. All high-level functions to read from memory work on operands as sources."],["operator",""],["place","Computations on places – field projections, going from mir::Place, and writing into a place. All high-level functions to write to memory work on places as destinations."],["projection","This file implements “place projections”; basically a symmetric API for 3 types: MPlaceTy, OpTy, PlaceTy."],["step","This module contains the `InterpCx` methods for executing a single step of the interpreter."],["terminator",""],["traits",""],["util",""],["validity","Check the validity invariant of a given value, and tell the user where in the value it got violated. In const context, this goes even further and tries to approximate const safety. That’s useful because it means other passes (e.g. promotion) can rely on `const`s to be const-safe."],["visitor","Visitor for a run-time value with a given layout: Traverse enums, structs and other compound types until we arrive at the leaves, with custom handling for primitive types."]],"struct":[["AllocDecodingSession",""],["AllocDecodingState",""],["AllocId",""],["AllocRange","The information that makes up a memory access: offset and size."],["AllocRef","A reference to some allocation that was already bounds-checked for the given region and had the on-access machine hooks run."],["AllocRefMut","A reference to some allocation that was already bounds-checked for the given region and had the on-access machine hooks run."],["Allocation","This type represents an Allocation in the Miri/CTFE core engine."],["ConstAlloc","Represents the result of const evaluation via the `eval_to_allocation` query."],["ConstAllocation","Interned types generally have an `Outer` type and an `Inner` type, where `Outer` is a newtype around `Interned<Inner>`, and all the operations are done on `Outer`, because all occurrences are interned. E.g. `Ty` is an outer type and `TyS` is its inner type."],["Frame","A stack frame."],["FrameInfo","What we store about a frame in an interpreter backtrace."],["GlobalId","Uniquely identifies one of the following:"],["ImmTy",""],["InitChunkIter","Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`]."],["InitMask","A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte is initialized. If it is `false` the byte is uninitialized."],["InterpCx",""],["InterpErrorInfo","Packages the kind of error we got from the const code interpreter up with a Rust-level backtrace of where the error occurred. These should always be constructed by calling `.into()` on an `InterpError`. In `rustc_mir::interpret`, we have `throw_err_*` macros for this."],["LitToConstInput","Input argument for `tcx.lit_to_const`."],["LocalState","State of a local variable including a memoized layout"],["MPlaceTy","A MemPlace with its layout. Constructing it is only possible in this module."],["MemPlace",""],["Memory",""],["OpTy",""],["PlaceTy",""],["Pointer","Represents a pointer in the Miri engine."],["ProvenanceMap","Stores the provenance information of pointers stored in memory."],["RefTracking","State for tracking recursive validation of references"],["ScalarSizeMismatch","Information about a size mismatch."],["UninitBytesAccess","Details of an access to uninitialized bytes where it is not allowed."]],"trait":[["AllocMap","The functionality needed by memory to manage its allocations"],["Machine","Methods of this trait signifies a point where CTFE evaluation would fail and some use case dependent behaviour can instead be applied."],["MachineStopType","A trait for machine-specific errors (or other “machine stop” conditions)."],["MayLeak","Whether this kind of memory is allowed to leak"],["MutValueVisitor",""],["PointerArithmetic",""],["Provenance","This trait abstracts over the kind of provenance that is associated with a `Pointer`. It is mostly opaque; the `Machine` trait extends it with some more operations that also have access to some global state. We don’t actually care about this `Debug` bound (we use `Provenance::fmt` to format the entire pointer), but `derive` adds some unnecessary bounds."],["Value","A thing that we can project into, and that has a layout. This wouldn’t have to depend on `Machine` but with the current type inference, that’s just more convenient to work with (avoids repeating all the `Machine` bounds)."],["ValueVisitor",""]],"type":[["EvalToAllocationRawResult",""],["EvalToConstValueResult",""],["EvalToValTreeResult",""],["InterpResult",""]]};