window.SIDEBAR_ITEMS = {"enum":[["DefiningAnchor",""],["FixupError",""],["IntVarValue",""],["LateBoundRegionConversionTime","Times when we replace late-bound regions with variables:"],["NllRegionVariableOrigin",""],["RegionResolutionError",""],["RegionVariableOrigin","Reasons to create a region inference variable"],["SubregionOrigin","The origin of a `r1 <= r2` constraint."],["TyOrConstInferVar","Helper for `ty_or_const_infer_var_changed` (see comment on that), currently used only for `traits::fulfill`’s list of `stalled_on` inference variables."],["ValuePairs","See the `error_reporting` module for more details."]],"fn":[["replace_param_and_infer_substs_with_placeholder","Replaces substs that reference param or infer variables with suitable placeholders. This function is meant to remove these param and infer substs when they’re not actually needed to evaluate a constant."]],"mod":[["at","A nice interface for working with the infcx. The basic idea is to do `infcx.at(cause, param_env)`, which sets the “cause” of the operation as well as the surrounding parameter environment. Then you can do something like `.sub(a, b)` or `.eq(a, b)` to create a subtype or equality relationship respectively. The first argument is always the “expected” output from the POV of diagnostics."],["canonical","Canonicalization is the key to constructing a query in the middle of type inference. Ordinarily, it is not possible to store types from type inference in query keys, because they contain references to inference variables whose lifetimes are too short and so forth. Canonicalizing a value T1 using `canonicalize_query` produces two things:"],["combine","There are four type combiners: [Equate], [Sub], [Lub], and [Glb]. Each implements the trait [TypeRelation] and contains methods for combining two instances of various things and yielding a new instance. These combiner methods always yield a `Result<T>`. To relate two types, you can use `infcx.at(cause, param_env)` which then allows you to use the relevant methods of At."],["equate",""],["error_reporting","Error Reporting Code for the inference engine"],["free_regions","This module handles the relationships between “free regions”, i.e., lifetime parameters. Ordinarily, free regions are unrelated to one another, but they can be related via implied or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type, and use that to decide when one free region outlives another, and so forth."],["freshen","Freshening is the process of replacing unknown variables with fresh types. The idea is that the type, after freshening, contains no inference variables but instead contains either a value for each variable or fresh “arbitrary” types wherever a variable would have been."],["fudge",""],["glb","Greatest lower bound. See [`lattice`]."],["higher_ranked","Helper routines for higher-ranked things. See the `doc` module at the end of the file for details."],["lattice","Lattice variables"],["lexical_region_resolve","Lexical region resolution."],["lub","Least upper bound. See [`lattice`]."],["nll_relate","This code is kind of an alternate way of doing subtyping, supertyping, and type equating, distinct from the `combine.rs` code but very similar in its effect and design. Eventually the two ought to be merged. This code is intended for use in NLL and chalk."],["opaque_types",""],["outlives","Various code related to computing outlives relations."],["projection",""],["region_constraints","See `README.md`."],["resolve",""],["sub",""],["type_variable",""],["undo_log",""]],"struct":[["CombinedSnapshot",""],["InferCtxt",""],["InferCtxtBuilder","A temporary returned by `tcx.infer_ctxt()`. This is necessary for multiple `InferCtxt` to share the same `in_progress_typeck_results` without using `Rc` or something similar."],["InferCtxtInner","This type contains all the things within `InferCtxt` that sit within a `RefCell` and are involved with taking/rolling back snapshots. Snapshot operations are hot enough that we want only one call to `borrow_mut` per call to `start_snapshot` and `rollback_to`."],["InferOk",""],["InferenceLiteralEraser","Replace `{integer}` with `i32` and `{float}` with `f64`. Used only for diagnostics."],["RegionObligation","See the `region_obligations` field for more information."],["ShallowResolver",""],["TypeFreshener",""],["TypeTrace","The trace designates the path through inference that we took to encounter an error or subtyping constraint."]],"trait":[["TyCtxtInferExt",""]],"type":[["Bound",""],["FixupResult",""],["InferResult",""],["UnificationTable",""],["UnitResult",""]]};