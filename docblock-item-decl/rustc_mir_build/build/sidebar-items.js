window.SIDEBAR_ITEMS = {"enum":[["BlockFrame",""],["ForGuard","`ForGuard` indicates whether we are talking about:"],["LocalsForNode",""],["NeedsTemporary",""]],"fn":[["construct_const",""],["construct_error","Construct MIR for an item that has had errors in type checking."],["construct_fn","the main entry point for building MIR for a function"],["mir_build","Construct the MIR for a given `DefId`."],["mir_built",""],["parse_float_into_constval",""],["parse_float_into_scalar",""]],"macro":[["unpack","Update a block pointer and return the value. Use it like `let x = unpack!(block = self.foo(block, foo))`."]],"mod":[["block",""],["cfg","Routines for manipulating the control-flow graph."],["expr","Builds MIR from expressions. As a caller into this module, you have many options, but the first thing you have to decide is whether you are evaluating this expression for its value, its location, or as a constant."],["matches","Code related to match expressions. These are sufficiently complex to warrant their own module and submodules. :) This main module includes the high-level algorithm, the submodules contain the details."],["misc","Miscellaneous builder routines that are not specific to building any particular kind of thing."],["scope","Managing the scope stack. The scopes are tied to lexical scopes, so as we descend the THIR, we push a scope on the stack, build its contents, and then pop it off. Every scope is named by a `region::Scope`."]],"struct":[["BlockAnd","The `BlockAnd` “monad” packages up the new basic block along with a produced value (sometimes just unit, of course). The `unpack!` macro (and methods below) makes working with `BlockAnd` much more convenient."],["BlockContext",""],["Builder",""],["CFG",""],["Capture",""],["GuardFrame",""],["GuardFrameLocal",""],["ScopeId",""]],"trait":[["BlockAndExtension",""]],"type":[["CaptureMap",""]]};